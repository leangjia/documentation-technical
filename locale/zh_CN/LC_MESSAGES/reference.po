#
msgid ""
msgstr ""
"Project-Id-Version: odoo master\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2015-09-06 04:27+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#: ../../reference.rst:3
msgid "Reference"
msgstr "参考"

#: ../../reference/actions.rst:7
msgid "Actions"
msgstr "行动"

#: ../../reference/actions.rst:9
msgid ""
"Actions define the behavior of the system in response to user actions: "
"login, action button, selection of an invoice, ..."
msgstr "操作定义响应用户操作的系统的行为：登录，操作按钮，选择发票的，..."

#: ../../reference/actions.rst:12
msgid ""
"Actions can be stored in the database or returned directly as dictionaries "
"in e.g. button methods. All actions share two mandatory attributes:"
msgstr "动作可存储在数据库中，或直接作为例如按钮的方法的字典返回。所有操作都有两个必选属性："

#: ../../reference/actions.rst:16 ../../reference/actions.rst:273
#: ../../reference/data.rst:116 ../../reference/views.rst:214
#: ../../reference/views.rst:749 ../../reference/views.rst:773
msgid "``type``"
msgstr "``type``"

#: ../../reference/actions.rst:16
msgid ""
"the category of the current action, determines which fields may be used and "
"how the action is interpreted"
msgstr "当前操作，的类别确定哪些字段可以被使用，并且动作如何解释"

#: ../../reference/actions.rst:20 ../../reference/views.rst:216
#: ../../reference/views.rst:249 ../../reference/views.rst:1098
#: ../../reference/views.rst:1158
msgid "``name``"
msgstr "``name``"

#: ../../reference/actions.rst:19
msgid ""
"short user-readable description of the action, may be displayed in the "
"client's interface"
msgstr "短用户可读的动作的说明中，可以显示在客户端的接口"

#: ../../reference/actions.rst:22
msgid "A client can get actions in 4 forms:"
msgstr "客户端可以让行动4形式："

#: ../../reference/actions.rst:24
msgid "``False``"
msgstr "``False``"

#: ../../reference/actions.rst:25
msgid "if any action dialog is currently open, close it"
msgstr "如果任何操作对话框当前处于打开状态，请将其关闭"

#: ../../reference/actions.rst:27
msgid "A string"
msgstr "字符串"

#: ../../reference/actions.rst:27
msgid ""
"if a :ref:`client action <reference/actions/client>` matches, interpret as a"
" client action's tag, otherwise treat as a number"
msgstr "如果：参考：`客户端动作<参考/动作/客户端>`比赛中，解释为一个客户端操作的标记，否则视为一个数字"

#: ../../reference/actions.rst:30
msgid "A number"
msgstr "一个号码"

#: ../../reference/actions.rst:30
msgid ""
"read the corresponding action record from the database, may be a database "
"identifier or an :term:`external id`"
msgstr "从数据库中读取相应的操作记录，可以是数据库标识符或一个：术语：`外部ID`"

#: ../../reference/actions.rst:33
msgid "A dictionary"
msgstr "一本字典"

#: ../../reference/actions.rst:33
msgid "treat as a client action descriptor and execute"
msgstr "视为客户端操作描述符和执行"

#: ../../reference/actions.rst:38
msgid "Window Actions (``ir.actions.act_window``)"
msgstr "窗口操作（``ir.actions.act_window``）"

#: ../../reference/actions.rst:40
msgid ""
"The most common action type, used to present visualisations of a model "
"through :ref:`views <reference/views>`: a window action defines a set of "
"view types (and possibly specific views) for a model (and possibly specific "
"record of the model)."
msgstr "最常见的动作类型，用于通过提出一个模型的可视化：参考：`观点<参考/视图>`：一个窗口的动作定义一组视图类型（以及可能的具体意见）为模型（和可能的特殊纪录该模型）。"

#: ../../reference/actions.rst:45
msgid "Its fields are:"
msgstr "它的字段有："

#: ../../reference/actions.rst:47
msgid "``res_model``"
msgstr "``res_model``"

#: ../../reference/actions.rst:48
msgid "model to present views for"
msgstr "模型提出的意见进行"

#: ../../reference/actions.rst:56
msgid "``views``"
msgstr "``views``"

#: ../../reference/actions.rst:50
msgid ""
"a list of ``(view_id, view_type)`` pairs. The second element of each pair is"
" the category of the view (tree, form, graph, ...) and the first is an "
"optional database id (or ``False``). If no id is provided, the client should"
" fetch the default view of the specified type for the requested model (this "
"is automatically done by :meth:`~openerp.models.Model.fields_view_get`). The"
" first type of the list is the default view type and will be open by default"
" when the action is executed. Each view type should be present at most once "
"in the list"
msgstr "中``（view_id来，view_type来）``对的列表。每对的第二个元素是视图（树，表格，图表，...）的范畴，首先是一个可选的数据库ID（或``False``）。如果没有ID提供，客户应取指定类型的请求模型的默认视图（这是自动完成的：甲：`〜openerp.models.Model.fields_view_get`）。列表的第一种类型是默认视图类型并且在执行动作时将开放默认。每个视图类型应该是目前最多一次在列表"

#: ../../reference/actions.rst:59
msgid "``res_id`` (optional)"
msgstr "``res_id``（可选）"

#: ../../reference/actions.rst:59
msgid ""
"if the default view is ``form``, specifies the record to load (otherwise a "
"new record should be created)"
msgstr "如果默认视图是``form``，指定记录加载（否则应该创建一个新的记录）"

#: ../../reference/actions.rst:63
msgid "``search_view_id`` (optional)"
msgstr "``search_view_id``（可选）"

#: ../../reference/actions.rst:62
msgid ""
"``(id, name)`` pair, ``id`` is the database identifier of a specific search "
"view to load for the action. Defaults to fetching the default search view "
"for the model"
msgstr "``（ID，姓名）``对，``id``是一个特定的搜索视图的数据库标识符加载的行动。默认为获取默认的搜索视图模型"

#: ../../reference/actions.rst:66
msgid "``target`` (optional)"
msgstr "``target``（可选）"

#: ../../reference/actions.rst:66
msgid ""
"whether the views should be open in the main content area (``current``) or "
"in a dialog/popup (``new``). Defaults to ``current``."
msgstr "该意见是否应在主要内容区开放（``current``），或在一个对话框/弹出（``new``）。默认为``current``。"

#: ../../reference/actions.rst:68 ../../reference/actions.rst:178
msgid "``context`` (optional)"
msgstr "``context``（可选）"

#: ../../reference/actions.rst:69
msgid "additional context data to pass to the views"
msgstr "附加的上下文数据传递到次"

#: ../../reference/actions.rst:70
msgid "``domain`` (optional)"
msgstr "``domain``（可选）"

#: ../../reference/actions.rst:71
msgid "filtering domain to implicitly add to all view search queries"
msgstr "过滤域隐式添加到所有视图搜索查询"

#: ../../reference/actions.rst:73
msgid "``limit`` (optional)"
msgstr "``limit``（可选）"

#: ../../reference/actions.rst:73
msgid ""
"number of records to display in lists by default. Defaults to 80 in the web "
"client"
msgstr "记录数为默认的列表中显示。默认为8​​0，在Web客户端"

#: ../../reference/actions.rst:77
msgid "``auto_search`` (optional)"
msgstr "``auto_search``（可选）"

#: ../../reference/actions.rst:76
msgid ""
"whether a search should be performed immediately after loading the default "
"view. Defaults to ``True``"
msgstr "是否搜索应加载默认视图后立即进行。默认为值为``True``"

#: ../../reference/actions.rst:79
msgid ""
"For instance, to open customers (partner with the ``customer`` flag set) "
"with list and form views::"
msgstr "例如，打开客户（合作伙伴的``customer``标志集）与名单，并形成观点::"

#: ../../reference/actions.rst:89
msgid ""
"Or to open the form view of a specific product (obtained separately) in a "
"new dialog::"
msgstr "或者打开一个特定的产品在一个新的对话框表单视图（单独获得）::"

#: ../../reference/actions.rst:100
msgid ""
"In-database window actions have a few different fields which should be "
"ignored by clients, mostly to use in composing the ``views`` list:"
msgstr "在数据库窗口中的操作有一些不同的领域应该由客户端被忽略，大多在构成``views``列表中使用："

#: ../../reference/actions.rst:104
msgid "``view_mode``"
msgstr "``view_mode``"

#: ../../reference/actions.rst:104
msgid ""
"comma-separated list of view types as a string. All of these types will be "
"present in the generated ``views`` list (with at least a ``False`` view_id)"
msgstr "逗号分隔的视图类型列表作为字符串。所有这些类型的将存在于生成的``views``列表（与至少一个``False``的view_id）"

#: ../../reference/actions.rst:107
msgid "``view_ids``"
msgstr "``view_ids``"

#: ../../reference/actions.rst:107
msgid ""
"M2M\\ [#notquitem2m]_ to view objects, defines the initial content of "
"``views``"
msgstr "M2M \\ [＃notquitem2m] _查看对象，定义了``views``的初始内容"

#: ../../reference/actions.rst:112
msgid "``view_id``"
msgstr "``view_id``"

#: ../../reference/actions.rst:110
msgid ""
"specific view added to the ``views`` list in case its type is part of the "
"``view_mode`` list and not already filled by one of the views in "
"``view_ids``"
msgstr "具体的观点加入到``views``列表中的情况下，它的类型是``view_mode``名单的一部分，并且尚未填补的``view_ids``一个视图"

#: ../../reference/actions.rst:114
msgid ""
"These are mostly used when defining actions from :ref:`reference/data`:"
msgstr "参考：`参考/ data`这些定义，从行为时，大多使用："

#: ../../reference/actions.rst:125
msgid ""
"will use the \"my_specific_view\" view even if that's not the default view "
"for the model."
msgstr "将使用\“my_specific_view \”的观点，即使这不是该型号的默认视图。"

#: ../../reference/actions.rst:128
msgid ""
"The server-side composition of the ``views`` sequence is the following:"
msgstr "在``views``序列的服务器端组成如下："

#: ../../reference/actions.rst:130
msgid "get each ``(id, type)`` from ``view_ids`` (ordered by ``sequence``)"
msgstr "获得每个``（ID，类型）``的``view_ids``（订购``sequence``）"

#: ../../reference/actions.rst:131
msgid ""
"if ``view_id`` is defined and its type isn't already filled, append its "
"``(id, type)``"
msgstr "如果``view_id``的定义，其类型是不是已经填满，追加了``（ID，类型）``"

#: ../../reference/actions.rst:133
msgid "for each unfilled type in ``view_mode``, append ``(False, type)``"
msgstr "每个填充类型``view_mode``，追加``（假，类型）``"

#: ../../reference/actions.rst:146
msgid "URL Actions (``ir.actions.act_url``)"
msgstr "URL操作（``ir.actions.act_url``）"

#: ../../reference/actions.rst:148
msgid ""
"Allow opening a URL (website/web page) via an Odoo action. Can be customized"
" via two fields:"
msgstr "允许通过Odoo操作打开URL（网站/网页）。可以通过两个字段定制："

#: ../../reference/actions.rst:151
msgid "``url``"
msgstr "``url``"

#: ../../reference/actions.rst:152
msgid "the address to open when activating the action"
msgstr "地址来激活操作时打开"

#: ../../reference/actions.rst:155
msgid "``target``"
msgstr "``target``"

#: ../../reference/actions.rst:154
msgid ""
"opens the address in a new window/page if ``new``, replaces the current "
"content with the page if ``self``. Defaults to ``new``"
msgstr "打开该地址在新窗口/网页，如果``new``，替换当前内容的页面，如果``self``。默认为``new``"

#: ../../reference/actions.rst:165
msgid "will replace the current content section by the Odoo home page."
msgstr "将取代由Odoo主页当前的内容部分。"

#: ../../reference/actions.rst:170
msgid "Server Actions (``ir.actions.server``)"
msgstr "服务器操作（``ir.actions.server``）"

#: ../../reference/actions.rst:172
msgid ""
"Allow triggering complex server code from any valid action location. Only "
"two fields are relevant to clients:"
msgstr "允许从任何有效的行动定位触发复杂的服务器代码。只有两个领域相关的客户："

#: ../../reference/actions.rst:175 ../../reference/data.rst:51
#: ../../reference/data.rst:136 ../../reference/data.rst:200
#: ../../reference/data.rst:210 ../../reference/reports.rst:34
msgid "``id``"
msgstr "``id``"

#: ../../reference/actions.rst:176
msgid "the in-database identifier of the server action to run"
msgstr "在数据库内标识的服务器操作的运行"

#: ../../reference/actions.rst:178
msgid "context data to use when running the server action"
msgstr "运行服务器操作时的上下文数据使用"

#: ../../reference/actions.rst:180
msgid ""
"In-database records are significantly richer and can perform a number of "
"specific or generic actions based on their ``state``. Some fields (and "
"corresponding behaviors) are shared between states:"
msgstr "数据库内记录显著更丰富，可以执行许多基于它们``state``特定或通用行动。某些字段（以及相应的行为）的国家之间共享："

#: ../../reference/actions.rst:185
msgid "``model_id``"
msgstr "``model_id``"

#: ../../reference/actions.rst:185
msgid ""
"Odoo model linked to the action, made available in :ref:`evaluation contexts"
" <reference/actions/server/context>`"
msgstr "裁判：挂动作Odoo模式，提供`评价上下文<参考/动作/服务器/背景>`"

#: ../../reference/actions.rst:190
msgid "``condition`` (optional)"
msgstr "``condition``（可选）"

#: ../../reference/actions.rst:188
msgid ""
"evaluated as Python code using the server action's :ref:`evaluation context "
"<reference/actions/server/context>`. If ``False``, prevents the action from "
"running. Default: ``True``"
msgstr "评价使用服务器操作的Python代码：参考：`评价方面<参考/动作/服务器/背景>`。如果``False``，阻止操作运行。默认值：值为``True``"

#: ../../reference/actions.rst:192
msgid ""
"Valid action types (``state`` field) are extensible, the default types are:"
msgstr "有效的操作类型（``state``场）是可扩展的，默认的类型是："

#: ../../reference/actions.rst:195 ../../reference/actions.rst:203
msgid "``code``"
msgstr "``code``"

#: ../../reference/actions.rst:197
msgid ""
"The default and most flexible server action type, executes arbitrary Python "
"code with the action's :ref:`evaluation context "
"<reference/actions/server/context>`. Only uses one specific type-specific "
"field:"
msgstr "默认的和最灵活的服务器动作类型，执行任意的Python代码与操作的：参考：`评价方面<参考/动作/服务器/背景>`。只使用一个特定的类型特定字段："

#: ../../reference/actions.rst:203
msgid "a piece of Python code to execute when the action is called"
msgstr "一段Python代码执行时的动作被称为"

#: ../../reference/actions.rst:217
msgid ""
"The code segment can define a variable called ``action``, which will be "
"returned to the client as the next action to execute:"
msgstr "代码段可以定义一个称为``action``变量，这将被返回给客户机的下一个操作执行："

#: ../../reference/actions.rst:236
msgid ""
"will ask the client to open a form for the record if it fullfils some "
"condition"
msgstr "会要求客户打开记录的表格，如果它fullfils一些条件"

#: ../../reference/actions.rst:239
msgid ""
"This tends to be the only action type created from :ref:`data files "
"<reference/data>`, other types aside from "
":ref:`reference/actions/server/multi` are simpler than Python code to define"
" from the UI, but not from :ref:`data files <reference/data>`."
msgstr "这往往是从创建的唯一动作类型：参考：`数据文件<参考/数据>`，其他类型的除了：参考：`参考/动作/服务器/ multi`比Python代码简单的从UI定义，但不能从：参考：`数据文件<参考/数据>`。"

#: ../../reference/actions.rst:247
msgid "``object_create``"
msgstr "``object_create``"

#: ../../reference/actions.rst:249
msgid ""
"Creates a new record, from scratch (via "
":meth:`~openerp.models.Model.create`) or by copying an existing record (via "
":meth:`~openerp.models.Model.copy`)"
msgstr "创建一个新的记录，从头开始（通过：甲：`〜openerp.models.Model.create`），或者通过复制现有的记录（通过：甲：`〜openerp.models.Model.copy`）"

#: ../../reference/actions.rst:261
msgid "``use_create``"
msgstr "``use_create``"

#: ../../reference/actions.rst:253
msgid "the creation policy, one of:"
msgstr "创建策略，之一："

#: ../../reference/actions.rst:255
msgid "``new``"
msgstr "``new``"

#: ../../reference/actions.rst:256
msgid "creates a record in the model specified by ``model_id``"
msgstr "通过``model_id``指定的模型创建了创纪录"

#: ../../reference/actions.rst:257
msgid "``new_other``"
msgstr "``new_other``"

#: ../../reference/actions.rst:258
msgid "creates a record in the model specified by ``crud_model_id``"
msgstr "创建由``指定的模型记录crud_model_id``"

#: ../../reference/actions.rst:259
msgid "``copy_current``"
msgstr "``copy_current``"

#: ../../reference/actions.rst:260
msgid "copies the record on which the action was invoked"
msgstr "副本在其上调用操作记录"

#: ../../reference/actions.rst:261
msgid "``copy_other``"
msgstr "``copy_other``"

#: ../../reference/actions.rst:262
msgid "copies an other record, obtained via ``ref_object``"
msgstr "副本的其他记录，通过``ref_object``获得"

#: ../../reference/actions.rst:273 ../../reference/actions.rst:309
msgid "``fields_lines``"
msgstr "``fields_lines``"

#: ../../reference/actions.rst:264
msgid ""
"fields to override when creating or copying the record. "
":class:`~openerp.fields.One2many` with the fields:"
msgstr "字段来创建或复制记录时覆盖。产品类别：`〜openerp.fields.One2many`的领域："

#: ../../reference/actions.rst:267
msgid "``col1``"
msgstr "``col1``"

#: ../../reference/actions.rst:268
msgid "``ir.model.fields`` to set in the model implied by ``use_create``"
msgstr "``ir.model.fields``在由``use_create``所隐含的模式设置"

#: ../../reference/actions.rst:269 ../../reference/javascript.rst:648
#: ../../reference/orm.rst:1000
msgid "``value``"
msgstr "``value``"

#: ../../reference/actions.rst:270
msgid "value for the field, interpreted via ``type``"
msgstr "值领域，通过``type``解释"

#: ../../reference/actions.rst:272
msgid ""
"If ``value``, the ``value`` field is interpreted as a literal value "
"(possibly converted), if ``equation`` the ``value`` field is interpreted as "
"a Python expression and evaluated"
msgstr "如果``value``的``value``场被解释为一个文本值（可能是转换），如果``equation``的``value``字段被解释为一个Python表达式和评估"

#: ../../reference/actions.rst:276 ../../reference/actions.rst:311
msgid "``crud_model_id``"
msgstr "``crud_model_id``"

#: ../../reference/actions.rst:276
msgid ""
"model in which to create a new record, if ``use_create`` is set to "
"``new_other``"
msgstr "模式，即创建一个新的记录，如果``use_create``设置为``new_other``"

#: ../../reference/actions.rst:279 ../../reference/actions.rst:314
msgid "``ref_object``"
msgstr "``ref_object``"

#: ../../reference/actions.rst:279
msgid ""
":class:`~openerp.fields.Reference` to an arbitrary record to copy, used if "
"``use_create`` is set to ``copy_other``"
msgstr "产品类别：`〜openerp.fields.Reference`到任意的记录复制，使用，如果``use_create``设置为``copy_other``"

#: ../../reference/actions.rst:282
msgid "``link_new_record``"
msgstr "``link_new_record``"

#: ../../reference/actions.rst:282
msgid ""
"boolean flag linking the newly created record to the current one via a "
"many2one field specified through ``link_field_id``, defaults to ``False``"
msgstr "布尔标志通过通``link_field_id``指定many2one场连接新创建的记录当前的，默认为``False``"

#: ../../reference/actions.rst:286
msgid "``link_field_id``"
msgstr "``link_field_id``"

#: ../../reference/actions.rst:285
msgid ""
"many2one to ``ir.model.fields``, specifies the current record's m2o field on"
" which the newly created record should be set (models should match)"
msgstr "many2one到``ir.model.fields``，指明该新创建的记录应设置（型号应匹配）当前记录的M2O领域"

#: ../../reference/actions.rst:289
msgid "``object_write``"
msgstr "``object_write``"

#: ../../reference/actions.rst:291
msgid ""
"Similar to :ref:`reference/actions/server/object_create` but alters an "
"existing records instead of creating one"
msgstr "类似的：参考：`参考/动作/服务器/ object_create`但会改变现有的记录，而不是创建1"

#: ../../reference/actions.rst:303
msgid "``use_write``"
msgstr "``use_write``"

#: ../../reference/actions.rst:295
msgid "write policy, one of:"
msgstr "写入策略，之一："

#: ../../reference/actions.rst:297
msgid "``current``"
msgstr "``current``"

#: ../../reference/actions.rst:298
msgid "write to the current record"
msgstr "写入当前记录"

#: ../../reference/actions.rst:300
msgid "``other``"
msgstr "``other``"

#: ../../reference/actions.rst:300
msgid ""
"write to an other record selected via ``crud_model_id`` and ``ref_object``"
msgstr "写经选择的其他记录``crud_model_id``和``ref_object``"

#: ../../reference/actions.rst:303
msgid "``expression``"
msgstr "``expression``"

#: ../../reference/actions.rst:303
msgid ""
"write to an other record whose model is selected via ``crud_model_id`` and "
"whose id is selected by evaluating ``write_expression``"
msgstr "将数据写入到其他记录，其模型通过``crud_model_id``被选中，其ID被选中评价``write_expression``"

#: ../../reference/actions.rst:307
msgid "``write_expression``"
msgstr "``write_expression``"

#: ../../reference/actions.rst:306
msgid ""
"Python expression returning a record or an object id, used when "
"``use_write`` is set to ``expression`` in order to decide which record "
"should be modified"
msgstr "Python表达式返回记录或对象ID，以便决定使用时``use_write``设置为``expression``该记录应修改"

#: ../../reference/actions.rst:310 ../../reference/actions.rst:312
#: ../../reference/actions.rst:314
msgid "see :ref:`reference/actions/server/object_create`"
msgstr "请参阅：参考：`参考/动作/服务器/ object_create`"

#: ../../reference/actions.rst:319
msgid "``multi``"
msgstr "``multi``"

#: ../../reference/actions.rst:321
msgid ""
"Executes multiple actions one after the other. Actions to execute are "
"defined via the ``child_ids`` m2m. If sub-actions themselves return actions,"
" the last one will be returned to the client as the multi's own next action"
msgstr "执行多个动作一个接一个。操作执行是通过``child_ids`` M2M定义。如果子动作本身返回的动作，最后一个将被返回给客户端作为多自己下一个动作"

#: ../../reference/actions.rst:326
msgid "``trigger``"
msgstr "``trigger``"

#: ../../reference/actions.rst:328
msgid "Sends a signal to a workflow."
msgstr "将信号发送到一个工作流程。"

#: ../../reference/actions.rst:330
msgid "``wkf_transition_id``"
msgstr "``wkf_transition_id``"

#: ../../reference/actions.rst:331
msgid ""
":class:`~openerp.fields.Many2one` to a ``workflow.transition`` to trigger"
msgstr "产品类别：`〜openerp.fields.Many2one`到``workflow.transition``触发"

#: ../../reference/actions.rst:335
msgid "``use_relational_model``"
msgstr "``use_relational_model``"

#: ../../reference/actions.rst:333
msgid ""
"if ``base`` (the default), trigger the signal on behalf of the current "
"record. If ``relational``, trigger the signal on behalf of a field of the "
"current record selected through ``wkf_model_id`` and ``wkf_field_id``"
msgstr "如果``base``（默认值），触发代表当前记录的信号。如果``relational``，触发信号代表当前记录，通过``wkf_model_id``和``wkf_field_id``选择一个领域"

#: ../../reference/actions.rst:338
msgid "``client_action``"
msgstr "``client_action``"

#: ../../reference/actions.rst:340
msgid ""
"Indirection for directly returning an other action defined using "
"``action_id``. Simply returns that action to the client for execution."
msgstr "使用``action_id``间接直接返回一个其他操作规定。简单地返回该操作的客户端执行。"

#: ../../reference/actions.rst:346
msgid "Evaluation context"
msgstr "评价范围内"

#: ../../reference/actions.rst:348
msgid ""
"A number of keys are available in the evaluation context of or surrounding "
"server actions:"
msgstr "有多个键的或周围服务器操作的评估上下文中可用​​："

#: ../../reference/actions.rst:351
msgid "``self``"
msgstr "``self``"

#: ../../reference/actions.rst:352
msgid "the model object linked to the action via ``model_id``"
msgstr "通过``model_id``链接到操作模型对象"

#: ../../reference/actions.rst:354
msgid "``object``, ``obj``"
msgstr "``object``，``obj``"

#: ../../reference/actions.rst:354
msgid ""
"only available if ``active_model`` and ``active_id`` are provided (via "
"context) otherwise ``None``. The actual record selected by ``active_id``"
msgstr "只有提供``active_model``和``active_id``可以（通过上下文），否则``None``。通过``active_id``选择的实际记录"

#: ../../reference/actions.rst:356
msgid "``pool``"
msgstr "``pool``"

#: ../../reference/actions.rst:357
msgid "the current database registry"
msgstr "当前数据库注册表"

#: ../../reference/actions.rst:358
msgid "``datetime``, ``dateutil``, ``time``"
msgstr "``datetime``，``dateutil``，``time``"

#: ../../reference/actions.rst:359
msgid "corresponding Python modules"
msgstr "相应的Python模块"

#: ../../reference/actions.rst:360
msgid "``cr``"
msgstr "``cr``"

#: ../../reference/actions.rst:361
msgid "the current cursor"
msgstr "当前光标"

#: ../../reference/actions.rst:362 ../../reference/reports.rst:122
msgid "``user``"
msgstr "``user``"

#: ../../reference/actions.rst:363
msgid "the current user record"
msgstr "当前用户记录"

#: ../../reference/actions.rst:364 ../../reference/data.rst:53
#: ../../reference/views.rst:236 ../../reference/views.rst:399
#: ../../reference/views.rst:1127 ../../reference/views.rst:1154
msgid "``context``"
msgstr "``context``"

#: ../../reference/actions.rst:365
msgid "execution context"
msgstr "执行上下文"

#: ../../reference/actions.rst:367
msgid "``Warning``"
msgstr "``Warning``"

#: ../../reference/actions.rst:367
msgid "constructor for the ``Warning`` exception"
msgstr "构造函数``Warning``异常"

#: ../../reference/actions.rst:375
msgid "Report Actions (``ir.actions.report.xml``)"
msgstr "报表操作（``ir.actions.report.xml``）"

#: ../../reference/actions.rst:377
msgid "Triggers the printing of a report"
msgstr "触发报表的打印"

#: ../../reference/actions.rst:380 ../../reference/reports.rst:37
#: ../../reference/reports.rst:242 ../../reference/views.rst:19
#: ../../reference/views.rst:354
msgid "``name`` (mandatory)"
msgstr "``name``（必选）"

#: ../../reference/actions.rst:380 ../../reference/reports.rst:37
#: ../../reference/reports.rst:242
msgid ""
"only useful as a mnemonic/description of the report when looking for one in "
"a list of some sort"
msgstr "只有在某种类型的列表作为报告的记忆/描述有用找一当"

#: ../../reference/actions.rst:382 ../../reference/reports.rst:39
msgid "``model`` (mandatory)"
msgstr "``model``（必选）"

#: ../../reference/actions.rst:383 ../../reference/reports.rst:40
msgid "the model your report will be about"
msgstr "该模型报告将左右"

#: ../../reference/actions.rst:384 ../../reference/reports.rst:41
msgid "``report_type`` (mandatory)"
msgstr "``report_type``（必选）"

#: ../../reference/actions.rst:385 ../../reference/reports.rst:42
msgid "either ``qweb-pdf`` for PDF reports or ``qweb-html`` for HTML"
msgstr "无论是``qweb-pdf``的PDF报告或``qweb-html``为HTML"

#: ../../reference/actions.rst:386 ../../reference/reports.rst:43
msgid "``report_name``"
msgstr "``report_name``"

#: ../../reference/actions.rst:387 ../../reference/reports.rst:44
msgid "the name of your report (which will be the name of the PDF output)"
msgstr "报告的名称（这将是PDF输出的名称）"

#: ../../reference/actions.rst:389 ../../reference/views.rst:34
msgid "``groups_id``"
msgstr "``groups_id``"

#: ../../reference/actions.rst:389 ../../reference/reports.rst:46
msgid ""
":class:`~openerp.fields.Many2many` field to the groups allowed to view/use "
"the current report"
msgstr "产品类别：`〜openerp.fields.Many2many`领域允许查看组/使用当前的报告"

#: ../../reference/actions.rst:392
msgid "``paperformat_id``"
msgstr "``paperformat_id``"

#: ../../reference/actions.rst:392
msgid ""
":class:`~openerp.fields.Many2one` field to the paper format you wish to use "
"for this report (if not specified, the company format will be used)"
msgstr "产品类别：`〜openerp.fields.Many2one`场要使用此报告（如果不指定，该公司的格式将被使用）的文件格式"

#: ../../reference/actions.rst:399 ../../reference/reports.rst:51
msgid "``attachment_use``"
msgstr "``attachment_use``"

#: ../../reference/actions.rst:395
msgid ""
"if set to ``True``, the report is only generated once the first time it is "
"requested, and re-printed from the stored report afterwards instead of being"
" re-generated every time."
msgstr "如果设置为``True``，那么该报告只产生一次，第一次被请求，并重新打印从存储的报告之后，而不是被重新生成的每个时间。"

#: ../../reference/actions.rst:399
msgid ""
"Can be used for reports which must only be generated once (e.g. for legal "
"reasons)"
msgstr "可用于必须只能使用一次生成的报告（例如出于法律原因）"

#: ../../reference/actions.rst:403 ../../reference/reports.rst:55
msgid "``attachment``"
msgstr "``attachment``"

#: ../../reference/actions.rst:402
msgid ""
"python expression that defines the name of the report; the record is "
"accessible as the variable ``object``"
msgstr "定义报表的名称蟒蛇表达;该记录是可以访问的变量``object``"

#: ../../reference/actions.rst:408
msgid "Client Actions (``ir.actions.client``)"
msgstr "客户端操作（``ir.actions.client``）"

#: ../../reference/actions.rst:410
msgid "Triggers an action implemented entirely in the client."
msgstr "触发完全在客户机中实现的操作。"

#: ../../reference/actions.rst:413
msgid "``tag``"
msgstr "``tag``"

#: ../../reference/actions.rst:413
msgid ""
"the client-side identifier of the action, an arbitrary string which the "
"client should know how to react to"
msgstr "动作的客户端标识符，一个任意字符串客户机应该知道如何作出反应，以"

#: ../../reference/actions.rst:417
msgid "``params`` (optional)"
msgstr "``params``（可选）"

#: ../../reference/actions.rst:416
msgid ""
"a Python dictionary of additional data to send to the client, alongside the "
"client action tag"
msgstr "附加数据一个Python字典来发送给客户端，旁边的客户端动作标签"

#: ../../reference/actions.rst:426
msgid ""
"tells the client to start the Point of Sale interface, the server has no "
"idea how the POS interface works."
msgstr "通知客户端开始销售界面的角度来看，服务器有不知道如何在POS接口工作。"

#: ../../reference/actions.rst:429
msgid ""
"technically not an M2M: adds a sequence field and may be composed of just a "
"view type, without a view id."
msgstr "技术上没有一个M2M：增加了一个序列字段可以由只是一个视图类型的，没有一个视图id。"

#: ../../reference/async.rst:6
msgid "Asynchronous Operations"
msgstr "异步操作"

#: ../../reference/async.rst:8
msgid ""
"As a language (and runtime), javascript is fundamentally single-threaded. "
"This means any blocking request or computation will block the whole page "
"(and, in older browsers, the software itself even preventing users from "
"switching to another tab): a javascript environment can be seen as an event-"
"based runloop where application developers have no control over the runloop "
"itself."
msgstr "作为一门语言（和运行时），JavaScript是从根本上单线程的。这意味着任何阻拦的请求或计算将阻止整个页面（和，在旧的浏览器，软件本身甚至阻止用户切换到另一个选项卡）：一个JavaScript环境可以看作是基于事件的runloop，其中应用程序开发人员没有控制在runloop本身。"

#: ../../reference/async.rst:15
msgid ""
"As a result, performing long-running synchronous network requests or other "
"types of complex and expensive accesses is frowned upon and asynchronous "
"APIs are used instead."
msgstr "其结果是，在执行长期运行的同步网络请求或其他类型的复杂且昂贵的访问是令人难以接受的和异步API用于代替。"

#: ../../reference/async.rst:19
msgid ""
"The goal of this guide is to provide some tools to deal with asynchronous "
"systems, and warn against systemic issues or dangers."
msgstr "本指南的目标是提供一些工具来处理异步系统，并警告反对系统性的问题或危险。"

#: ../../reference/async.rst:23
msgid "Deferreds"
msgstr "Deferreds"

#: ../../reference/async.rst:25
msgid ""
"Deferreds are a form of `promises`_. OpenERP Web currently uses `jQuery's "
"deferred`_."
msgstr "Deferreds是`promises`_的一种形式。 OpenERP的网站目前使用'jQuery的deferred`_。"

#: ../../reference/async.rst:28
msgid ""
"The core idea of deferreds is that potentially asynchronous methods will "
"return a :js:class:`Deferred` object instead of an arbitrary value or (most "
"commonly) nothing."
msgstr "deferreds的核心思想是，潜在的异步方法将返回：JS：类：`Deferred`对象，而不是一个任意值或（最常见），什么都没有。"

#: ../../reference/async.rst:32
msgid ""
"This object can then be used to track the end of the asynchronous operation "
"by adding callbacks onto it, either success callbacks or error callbacks."
msgstr "此对象然后可用于通过添加回调到它跟踪异步操作的结束，无论是成功的回调或错误回调。"

#: ../../reference/async.rst:36
msgid ""
"A great advantage of deferreds over simply passing callback functions "
"directly to asynchronous methods is the ability to :ref:`compose them "
"<reference/async/composition>`."
msgstr "deferreds过干脆直接传递回调函数来异步方法一大优点是能够：REF：`撰写他们<参考/异步/组合>`。"

#: ../../reference/async.rst:41
msgid "Using deferreds"
msgstr "使用deferreds"

#: ../../reference/async.rst:43
msgid ""
"Deferreds's most important method is :js:func:`Deferred.then`. It is used to"
" attach new callbacks to the deferred object."
msgstr "Deferreds的最重要的方法是：JS：FUNC：`Deferred.then`。它是用来连接新的回调延迟对象。"

#: ../../reference/async.rst:46
msgid ""
"the first parameter attaches a success callback, called when the deferred "
"object is successfully resolved and provided with the resolved value(s) for "
"the asynchronous operation."
msgstr "第一个参数附加一个成功的回调，调用时延迟的对象被成功解决，并提供与解析值（S）的异步操作。"

#: ../../reference/async.rst:50
msgid ""
"the second parameter attaches a failure callback, called when the deferred "
"object is rejected and provided with rejection values (often some sort of "
"error message)."
msgstr "第二个参数附加一个失败的回调，调用时延迟的对象被拒绝，并提供了拒绝值（通常是某种错误消息）。"

#: ../../reference/async.rst:54
msgid ""
"Callbacks attached to deferreds are never \"lost\": if a callback is "
"attached to an already resolved or rejected deferred, the callback will be "
"called (or ignored) immediately. A deferred is also only ever resolved or "
"rejected once, and is either resolved or rejected: a given deferred can not "
"call a single success callback twice, or call both a success and a failure "
"callbacks."
msgstr "连接到deferreds回调是永远\“丢失\”：如果回调连接到一个已经解决或拒绝延期，则回调将会被调用（或忽略）立即。一个Deferred也永远只能解决或拒绝一次，是解决或拒绝：给定延期不能称之为一个成功的回调两次，或拨打成功及失败的回调。"

#: ../../reference/async.rst:61
msgid ""
":js:func:`~Deferred.then` should be the method you'll use most often when "
"interacting with deferred objects (and thus asynchronous APIs)."
msgstr "：JS：FUNC：`〜Deferred.then`应与延迟对象（因此异步API）的交互时，你会最常使用的方法。"

#: ../../reference/async.rst:65
msgid "Building deferreds"
msgstr "建筑deferreds"

#: ../../reference/async.rst:67
msgid ""
"After using asynchronous APIs may come the time to build them: for mocks_, "
"to compose deferreds from multiple source in a complex manner, in order to "
"let the current operations repaint the screen or give other events the time "
"to unfold, ..."
msgstr "使用异步的API后可能出现的时间来建立他们，因mocks_，组成从多个源deferreds以复杂的方式，为了让目前的操作重绘屏幕或给予其他事件展开的时候，..."

#: ../../reference/async.rst:72
msgid "This is easy using jQuery's deferred objects."
msgstr "这是很容易使用jQuery的延迟对象。"

#: ../../reference/async.rst:74
msgid ""
"this section is an implementation detail of jQuery Deferred objects, the "
"creation of promises is not part of any standard (even tentative) that I "
"know of. If you are using deferred objects which are not jQuery's, their API"
" may (and often will) be completely different."
msgstr "这一部分是jQuery的递延对象的实现细节，创造的承诺是不是任何标准（甚至暂定），我知道的一部分。如果您使用的不是jQuery的延迟对象，他们的API可能（而且往往会）是完全不同的。"

#: ../../reference/async.rst:80
msgid ""
"Deferreds are created by invoking their constructor [#]_ without any "
"argument. This creates a :js:class:`Deferred` instance object with the "
"following methods:"
msgstr "Deferreds通过调用其构造[＃] _不带任何参数创建。这将创建一个：JS：类：`以下方法Deferred`实例对象："

#: ../../reference/async.rst:84
msgid ":js:func:`Deferred.resolve`"
msgstr "：JS：FUNC：`Deferred.resolve`"

#: ../../reference/async.rst:86
msgid ""
"As its name indicates, this method moves the deferred to the \"Resolved\" "
"state. It can be provided as many arguments as necessary, these arguments "
"will be provided to any pending success callback."
msgstr "正如其名称所示，这种方法移动推迟到\“已解决\”状态。它可以被提供作为根据需要，这些参数将被提供给任何未决的成功回调很多争论。"

#: ../../reference/async.rst:91
msgid ":js:func:`Deferred.reject`"
msgstr "：JS：FUNC：`Deferred.reject`"

#: ../../reference/async.rst:93
msgid ""
"Similar to :js:func:`~Deferred.resolve`, but moves the deferred to the "
"\"Rejected\" state and calls pending failure handlers."
msgstr "类似：JS：FUNC：`〜Deferred.resolve`，但移动推迟到\“拒绝\”状态，并呼吁正在申请失败处理。"

#: ../../reference/async.rst:96
msgid ":js:func:`Deferred.promise`"
msgstr "：JS：FUNC：`Deferred.promise`"

#: ../../reference/async.rst:98
msgid ""
"Creates a readonly view of the deferred object. It is generally a good idea "
"to return a promise view of the deferred to prevent callers from resolving "
"or rejecting the deferred in your stead."
msgstr "创建延迟对象的只读视图。它一般是返回的承诺视图推迟到防止对方解决或拒绝推迟代替你一个好主意。"

#: ../../reference/async.rst:102
msgid ""
":js:func:`~Deferred.reject` and :js:func:`~Deferred.resolve` are used to "
"inform callers that the asynchronous operation has failed (or succeeded). "
"These methods should simply be called when the asynchronous operation has "
"ended, to notify anybody interested in its result(s)."
msgstr "：JS：FUNC：`〜Deferred.reject`和：JS：FUNC：`〜Deferred.resolve`被用来通知主叫方的异步操作失败（或成功）。这些方法应该简单地调用时异步操作已经结束，通知任何人感兴趣的结果（S）。"

#: ../../reference/async.rst:111
msgid "Composing deferreds"
msgstr "撰写deferreds"

#: ../../reference/async.rst:113
msgid ""
"What we've seen so far is pretty nice, but mostly doable by passing "
"functions to other functions (well adding functions post-facto would "
"probably be a chore... still, doable)."
msgstr "我们到目前为止看到的是相当不错的，但通过传递函数的其他功能（以及增加功能事后可能会是一个苦差事......不过，是可行的）主要是可行的。"

#: ../../reference/async.rst:117
msgid ""
"Deferreds truly shine when code needs to compose asynchronous operations in "
"some way or other, as they can be used as a basis for such composition."
msgstr "当代码需要构成异步操作以某种方式或其他Deferreds真正亮，因为它们可以被用作该组合物的基础。"

#: ../../reference/async.rst:121
msgid ""
"There are two main forms of compositions over deferred: multiplexing and "
"piping/cascading."
msgstr "有超过延期组成的两种主要形式：复用和管道/级联。"

#: ../../reference/async.rst:125
msgid "Deferred multiplexing"
msgstr "递延复"

#: ../../reference/async.rst:127
msgid ""
"The most common reason for multiplexing deferred is simply performing "
"multiple asynchronous operations and wanting to wait until all of them are "
"done before moving on (and executing more stuff)."
msgstr "延迟只是执行多个异步操作，并希望等到所有的人都对移动（和执行更多的东西）之前完成的最常见原因多路。"

#: ../../reference/async.rst:131
msgid "The jQuery multiplexing function for promises is :js:func:`when`."
msgstr "jQuery的复用功能的承诺是：JS：FUNC：`when`。"

#: ../../reference/async.rst:133
msgid ""
"the multiplexing behavior of jQuery's :js:func:`when` is an (incompatible, "
"mostly) extension of the behavior defined in `CommonJS Promises/B`_."
msgstr "jQuery的的复用特性：JS：FUNC：`when`是一个（不兼容的，主要是）在`CommonJS的承诺/ B`_定义的行为的延伸。"

#: ../../reference/async.rst:137
msgid ""
"This function can take any number of promises [#]_ and will return a "
"promise."
msgstr "该功能可以采取任何数量的承诺[＃] _，并会返回一个承诺。"

#: ../../reference/async.rst:140
msgid ""
"The returned promise will be resolved when *all* multiplexed promises are "
"resolved, and will be rejected as soon as one of the multiplexed promises is"
" rejected (it behaves like Python's ``all()``, but with promise objects "
"instead of boolean-ish)."
msgstr "当*所有*复用的承诺都解决了返回的承诺将得到解决，并会尽快复用的承诺之一是拒绝被拒绝（它像Python的``所有（）``，但与承诺对象，而不是boolean- ISH）。"

#: ../../reference/async.rst:145
msgid ""
"The resolved values of the various promises multiplexed via :js:func:`when` "
"are mapped to the arguments of :js:func:`when`'s success callback, if they "
"are needed. The resolved values of a promise are at the same index in the "
"callback's arguments as the promise in the :js:func:`when` call so you will "
"have:"
msgstr "通过复用的各种承诺的决心值：JS：FUNC：`when`分别对应的参数：JS：FUNC：`when`的成功回调，如果需要他们。的承诺的决心值是在回调的论据作为承诺相同指数在：JS：FUNC：`when`调用，所以你将有："

#: ../../reference/async.rst:160
msgid ""
"in a normal mapping, each parameter to the callback would be an array: each "
"promise is conceptually resolved with an array of 0..n values and these "
"values are passed to :js:func:`when`'s callback. But jQuery treats deferreds"
" resolving a single value specially, and \"unwraps\" that value."
msgstr "在一个正常的映射，每个参数的回调将是一个数组：每个承诺在概念上解决了与0到n值的数组，这些价值传递到：JS：FUNC：`when`的回调。但是jQuery的治疗deferreds解决单个值特别，和\“解开\”的价值。"

#: ../../reference/async.rst:166
msgid ""
"For instance, in the code block above if the index of each promise is the "
"number of values it resolves (0 to 3), ``results0`` is an empty array, "
"``results2`` is an array of 2 elements (a pair) but ``results1`` is the "
"actual value resolved by ``p1``, not an array."
msgstr "例如，在码块上方如果每个许的索引是它解决值的数目（0至3），``results0``为空数组，``results2``是2元件的阵列（一一对），但``results1``是由``p1``，不是数组解决的实际值。"

#: ../../reference/async.rst:172
msgid "Deferred chaining"
msgstr "递延链接"

#: ../../reference/async.rst:174
msgid ""
"A second useful composition is starting an asynchronous operation as the "
"result of an other asynchronous operation, and wanting the result of both: "
"with the tools described so far, handling e.g. OpenERP's search/read "
"sequence with this would require something along the lines of:"
msgstr "第二种有用组合物开始异步操作作为其它异步操作的结果，并希望两者的结果是：与所描述的工具，到目前为止，处理例如OpenERP的搜索/读取该序列将需要沿着的路线的东西："

#: ../../reference/async.rst:190
msgid ""
"While it doesn't look too bad for trivial code, this quickly gets unwieldy."
msgstr "虽然它看起来并不太坏了琐碎的代码，这很快就会笨重。"

#: ../../reference/async.rst:193
msgid ""
"But :js:func:`~Deferred.then` also allows handling this kind of chains: it "
"returns a new promise object, not the one it was called with, and the return"
" values of the callbacks is important to this behavior: whichever callback "
"is called,"
msgstr "但是：JS：FUNC：`〜Deferred.then`还可以处理这类链：它返回一个新的承诺的对象，而不是一个，它被称为用，而回调的返回值是很重要的这种行为：任何回调叫，"

#: ../../reference/async.rst:198
msgid ""
"If the callback is not set (not provided or left to null), the resolution or"
" rejection value(s) is simply forwarded to :js:func:`~Deferred.then`'s "
"promise (it's essentially a noop)"
msgstr "如果回调不设置（不提供或不为空），分辨率或拒绝值（s）是简单地转发至：JS：FUNC：`〜Deferred.then`的承诺（它本质上是一个空操作）"

#: ../../reference/async.rst:202
msgid ""
"If the callback is set and does not return an observable object (a deferred "
"or a promise), the value it returns (``undefined`` if it does not return "
"anything) will replace the value it was given, e.g."
msgstr "如果回调设置，不返回一个可观察的对象（延迟或承诺），该值将返回（``undefined``，如果它不返回任何东西）将代替它被赋予的价值，例如："

#: ../../reference/async.rst:212
msgid "will resolve with the sole value ``undefined``."
msgstr "将解决与唯一的价值``undefined``。"

#: ../../reference/async.rst:214
msgid ""
"If the callback is set and returns an observable object, that object will be"
" the actual resolution (and result) of the pipe. This means a resolved "
"promise from the failure callback will resolve the pipe, and a failure "
"promise from the success callback will reject the pipe."
msgstr "如果回叫被设置并返回一个可观察对象，该对象将是管的实际分辨率（和结果）。这意味着从失败回调一个解决承诺将解决管，和从成功回调失败承诺将拒绝该管。"

#: ../../reference/async.rst:220
msgid ""
"This provides an easy way to chain operation successes, and the previous "
"piece of code can now be rewritten:"
msgstr "这提供了一种简单的方法，以连锁经营的成功，与前一段代码可以改写为："

#: ../../reference/async.rst:229
msgid ""
"the result of the whole expression will encode failure if either ``search`` "
"or ``read`` fails (with the right rejection values), and will be resolved "
"with ``read``'s resolution values if the chain executes correctly."
msgstr "如果任一``search``或``read``失败（用正确的拒绝值），整个表达式的结果将编码失效，并会与``read``的分辨率值来解决，如果链条正确执行。"

#: ../../reference/async.rst:234
msgid ""
":js:func:`~Deferred.then` is also useful to adapt third-party promise-based "
"APIs, in order to filter their resolution value counts for instance (to take"
" advantage of :js:func:`when` 's special treatment of single-value "
"promises)."
msgstr "：JS：FUNC：`〜Deferred.then`也是适应第三方承诺为基础的API，以过滤其分辨率值计数实例（占便宜有用：JS：FUNC：`when`的特殊处理单值的承诺）。"

#: ../../reference/async.rst:240
msgid "jQuery.Deferred API"
msgstr "jQuery.Deferred API"

#: ../../reference/async.rst:244
msgid "deferred objects to multiplex"
msgstr "递延对象复"

#: ../../reference/async.rst:245
msgid "a multiplexed deferred"
msgstr "多路复用推迟"

#: ../../reference/async.rst:246 ../../reference/async.rst:268
#: ../../reference/async.rst:285 ../../reference/async.rst:300
msgid ":js:class:`Deferred`"
msgstr "：JS：类：`Deferred`"

#: ../../reference/async.rst:252
msgid ""
"Attaches new callbacks to the resolution or rejection of the deferred "
"object. Callbacks are executed in the order they are attached to the "
"deferred."
msgstr "重视新的回调递延对象的分辨率或拒绝。回调在它们所连接的延迟的顺序执行。"

#: ../../reference/async.rst:256
msgid ""
"To provide only a failure callback, pass ``null`` as the ``doneCallback``, "
"to provide only a success callback the second argument can just be ignored "
"(and not passed at all)."
msgstr "只提供一个失败的回调，通``null``为``doneCallback``，只提供一个成功的回调（都过去了，没有）可以直接被忽略了第二个参数。"

#: ../../reference/async.rst:260
msgid ""
"Returns a new deferred which resolves to the result of the corresponding "
"callback, if a callback returns a deferred itself that new deferred will be "
"used as the resolution of the chain."
msgstr "返回一个新的推迟解析为相应的回调的结果，如果回调函数返回一个deferred本身新的延期将用作链的分辨率。"

#: ../../reference/async.rst:265 ../../reference/async.rst:282
msgid "function called when the deferred is resolved"
msgstr "函数调用时的延迟得到解决"

#: ../../reference/async.rst:266 ../../reference/async.rst:297
msgid "function called when the deferred is rejected"
msgstr "函数调用时的延迟被拒绝"

#: ../../reference/async.rst:267 ../../reference/async.rst:284
#: ../../reference/async.rst:299
msgid "the deferred object on which it was called"
msgstr "在它被称为延迟的对象"

#: ../../reference/async.rst:272
msgid ""
"Attaches a new success callback to the deferred, shortcut for "
"``deferred.then(doneCallback)``."
msgstr "附加一个新的成功回调至推迟，快捷方式``deferred.then（doneCallback）``。"

#: ../../reference/async.rst:275
msgid ""
"a difference is the result of :js:func:`Deferred.done`'s is ignored rather "
"than forwarded through the chain"
msgstr "的差的结果：JS：函数：`Deferred.done`的被忽略，而不是通过该链转发"

#: ../../reference/async.rst:278
msgid ""
"This is a jQuery extension to `CommonJS Promises/A`_ providing little value "
"over calling :js:func:`~Deferred.then` directly, it should be avoided."
msgstr "这是一个jQuery扩展`CommonJS的承诺/ A`_几乎没有价值超过致电：JS：FUNC：`〜Deferred.then`直接，应该避免。"

#: ../../reference/async.rst:289
msgid ""
"Attaches a new failure callback to the deferred, shortcut for "
"``deferred.then(null, failCallback)``."
msgstr "附加一个新的故障回调的延期，快捷方式``deferred.then（空，failCallback）``。"

#: ../../reference/async.rst:292
msgid ""
"A second jQuery extension to `Promises/A <CommonJS Promises/A>`_. Although "
"it provides more value than :js:func:`~Deferred.done`, it still is not much "
"and should be avoided as well."
msgstr "第二jQuery的扩展'的承诺/ A <CommonJS的娓娓道来/ A>`_。虽然它提供了比更多的价值：JS：FUNC：`〜Deferred.done`，但它仍然是没有太大的，应该避免。"

#: ../../reference/async.rst:304
msgid ""
"Returns a read-only view of the deferred object, with all mutators (resolve "
"and reject) methods removed."
msgstr "返回递延对象的只读视图，所有的存取器（解决和拒绝）中删除的方法。"

#: ../../reference/async.rst:309
msgid ""
"Called to resolve a deferred, any value provided will be passed onto the "
"success handlers of the deferred object."
msgstr "调用此方法来解决延迟，任何规定将被传递到延迟的对象的成功处理程序的价值。"

#: ../../reference/async.rst:312
msgid ""
"Resolving a deferred which has already been resolved or rejected has no "
"effect."
msgstr "解决了延迟已经被解决或拒绝没有任何影响。"

#: ../../reference/async.rst:317
msgid ""
"Called to reject (fail) a deferred, any value provided will be passed onto "
"the failure handler of the deferred object."
msgstr "调用拒绝（失败）一推迟，所提供的任何值将被传递到递延对象的故障处理程序。"

#: ../../reference/async.rst:320
msgid ""
"Rejecting a deferred which has already been resolved or rejected has no "
"effect."
msgstr "拒绝延期它已经得到解决或拒绝没有任何影响。"

#: ../../reference/async.rst:323
msgid ""
"or simply calling :js:class:`Deferred` as a function, the result is the same"
msgstr "或者简单地调用：JS：类：`Deferred`作为一个函数，结果是一样的"

#: ../../reference/async.rst:326
msgid ""
"or not-promises, the `CommonJS Promises/B`_ role of :js:func:`when` is to be"
" able to treat values and promises uniformly: :js:func:`when` will pass "
"promises through directly, but non-promise values and objects will be "
"transformed into a resolved promise (resolving themselves with the value "
"itself)."
msgstr "或不承诺，请`CommonJS的承诺/的B`_作用：JS：FUNC：`when`是能够均匀地对待价值观和承诺：JS：FUNC：`when`将通过承诺通过直接，但非-promise值和对象将被改造成一个解决的承诺（与本身的价值解析自理）。"

#: ../../reference/async.rst:332
msgid ""
"jQuery's :js:func:`when` keeps this behavior making deferreds easy to build "
"from \"static\" values, or allowing defensive code where expected promises "
"are wrapped in :js:func:`when` just in case."
msgstr "jQuery的：JS：FUNC：`when`保持这种行为使得deferreds容易建立从\“静\”的价值观，或允许防守代码中预计的承诺被包裹在：JS：FUNC：`when`以防万一。"

#: ../../reference/cmdline.rst:7
msgid "Command-line interface: odoo.py"
msgstr "命令行界面：odoo.py"

#: ../../reference/cmdline.rst:12
msgid "Running the server"
msgstr "运行服务器"

#: ../../reference/cmdline.rst:18
msgid "database used when installing or updating modules."
msgstr "数据库使用安装或更新模块时。"

#: ../../reference/cmdline.rst:22
msgid ""
"comma-separated list of modules to install before running the server "
"(requires :option:`-d`)."
msgstr "模块在运行服务器之前安装的逗号分隔的列表（要求：选项：`-d`）。"

#: ../../reference/cmdline.rst:27
msgid ""
"comma-separated list of modules to update before running the server "
"(requires :option:`-d`)."
msgstr "模块在运行服务器之前更新的逗号分隔的列表（要求：选项：`-d`）。"

#: ../../reference/cmdline.rst:32
msgid ""
"comma-separated list of directories in which modules are stored. These "
"directories are scanned for modules (nb: when and why?)"
msgstr "在模块存储目录的逗号分隔的列表。这些目录扫描模块（注：什么时候，为什么？）"

#: ../../reference/cmdline.rst:37
msgid ""
"if ``count`` is not 0 (the default), enables multiprocessing and sets up the"
" specified number of HTTP workers (sub-processes processing HTTP and RPC "
"requests)."
msgstr "如果``count``不为0（默认值），使多并设置HTTP工人的指定数目（子进程处理HTTP和RPC请求）。"

#: ../../reference/cmdline.rst:41
msgid "multiprocessing mode is only available on Unix-based systems"
msgstr "多模式仅适用于基于Unix的系统"

#: ../../reference/cmdline.rst:43
msgid "A number of options allow limiting and recyling workers:"
msgstr "有很多选项，允许限制和循环的竞争工人："

#: ../../reference/cmdline.rst:47
msgid ""
"Number of requests a worker will process before being recycled and "
"restarted."
msgstr "被回收并重新启动要求工人将之前处理的数量。"

#: ../../reference/cmdline.rst:50
msgid "Defaults to 8196."
msgstr "默认为8​​196。"

#: ../../reference/cmdline.rst:54
msgid ""
"Maximum allowed virtual memory per worker. If the limit is exceeded, the "
"worker is killed and recycled at the end of the current request."
msgstr "每个工人允许的最大虚拟内存。如果超过限制，该名工人死亡，回收在当前请求结束。"

#: ../../reference/cmdline.rst:57
msgid "Defaults to 640MB."
msgstr "默认为640MB。"

#: ../../reference/cmdline.rst:61
msgid ""
"Hard limit on virtual memory, any worker exceeding the limit will be "
"immediately killed without waiting for the end of the current request "
"processing."
msgstr "虚拟内存硬性限制，任何工人超过限制将被立即杀死而不等待当前请求处理结束。"

#: ../../reference/cmdline.rst:65
msgid "Defaults to 768MB."
msgstr "默认为768MB。"

#: ../../reference/cmdline.rst:69
msgid ""
"Prevents the worker from using more than <limit> CPU seconds for each "
"request. If the limit is exceeded, the worker is killed."
msgstr "防止使用超过<极限> CPU秒为每个请求的工人。如果超出限制，工人被杀害。"

#: ../../reference/cmdline.rst:72
msgid "Defaults to 60."
msgstr "默认为60。"

#: ../../reference/cmdline.rst:76
msgid ""
"Prevents the worker from taking longer than <limit> seconds to process a "
"request. If the limit is exceeded, the worker is killed."
msgstr "防止时间超过<极限>秒来处理请求的工人。如果超出限制，工人被杀害。"

#: ../../reference/cmdline.rst:79
msgid ""
"Differs from :option:`--limit-time-cpu` in that this is a \"wall time\" "
"limit including e.g. SQL queries."
msgstr "不同于：选项：`--limit-时间cpu`的，这是一个\“挂钟时间\”的限制，包括如SQL查询。"

#: ../../reference/cmdline.rst:82
msgid "Defaults to 120."
msgstr "默认为120。"

#: ../../reference/cmdline.rst:86
msgid ""
"number of workers dedicated to cron jobs. Defaults to 2. The workers are "
"threads in multithreading mode and processes in multiprocessing mode."
msgstr "职工人数致力于cron作业。默认为2。工人们在多进程模式，多线程模式线程和进程。"

#: ../../reference/cmdline.rst:89
msgid ""
"For multiprocessing mode, this is in addition to the HTTP worker processes."
msgstr "对于多处理模式，这是除了HTTP工作进程。"

#: ../../reference/cmdline.rst:94
msgid "provide an alternate configuration file"
msgstr "提供一个备用的配置文件"

#: ../../reference/cmdline.rst:98
msgid ""
"saves the server configuration to the current configuration file "
"(:file:`{$HOME}/.openerp_serverrc` by default, overridable using "
":option:`-c`)"
msgstr "保存服务器配置到当前配置文件（即：file：`{$ HOME} /默认openerp_serverrc`，重写的使用：选项：`-c`）"

#: ../../reference/cmdline.rst:104
msgid ""
"enables the use of ``X-Forwarded-*`` headers through `Werkzeug's proxy "
"support`_."
msgstr "支持通过`WERKZEUG的代理support`_使用``的X Forwarded- *``头。"

#: ../../reference/cmdline.rst:107
msgid "proxy mode *must not* be enabled outside of a reverse proxy scenario"
msgstr "代理模式*不能*反向代理方案之外启用"

#: ../../reference/cmdline.rst:112
msgid "runs tests after installing modules"
msgstr "运行安装模块后测试"

#: ../../reference/cmdline.rst:116
msgid ""
"when an unexpected error is raised (not a warning or an access error), "
"automatically starts :mod:`python:pdb` before logging and returning the "
"error"
msgstr "时，引发意外的错误（不是警告或访问错误），将自动启动：MOD：`蟒蛇：pdb`记录前，返回错误"

#: ../../reference/cmdline.rst:123
msgid "database"
msgstr "数据库"

#: ../../reference/cmdline.rst:127
msgid "database username, used to connect to PostgreSQL."
msgstr "数据库用户名，用于连接到PostgreSQL。"

#: ../../reference/cmdline.rst:131
msgid "database password, if using `password authentication`_."
msgstr "数据库密码，如果使用`密码authentication`_。"

#: ../../reference/cmdline.rst:135
msgid "host for the database server"
msgstr "主机数据库服务器"

#: ../../reference/cmdline.rst:137
msgid "``localhost`` on Windows"
msgstr "``localhost``在Windows"

#: ../../reference/cmdline.rst:138
msgid "UNIX socket otherwise"
msgstr "UNIX插座，否则"

#: ../../reference/cmdline.rst:142
msgid "port the database listens on, defaults to 5432"
msgstr "端口数据库监听，默认为5432"

#: ../../reference/cmdline.rst:146
msgid ""
"hides databases that do not match ``<filter>``. The filter is a `regular "
"expression`_, with the additions that:"
msgstr "隐藏的数据库不匹配``<滤镜>``。该过滤器是一个`定期expression`_，用加的是："

#: ../../reference/cmdline.rst:149
msgid "``%h`` is replaced by the whole hostname the request is made on."
msgstr "%h替换整个主机的请求作出。"

#: ../../reference/cmdline.rst:150
msgid ""
"``%d`` is replaced by the subdomain the request is made on, with the "
"exception of ``www`` (so domain ``odoo.com`` and ``www.odoo.com`` both match"
" the database ``odoo``)"
msgstr "%d被替换为子域的请求作出，除``www``（所以域``odoo.com``和``www.odoo.com``两者匹配数据库``odoo``）"

#: ../../reference/cmdline.rst:156
msgid ""
"when creating new databases from the database-management screens, use the "
"specified `template database`_. Defaults to ``template1``."
msgstr "创建从数据库管理界面的新数据库时，使用指定的`模板database`_。默认为``template1``。"

#: ../../reference/cmdline.rst:160
msgid "built-in HTTP"
msgstr "内置的HTTP"

#: ../../reference/cmdline.rst:164
msgid ""
"do not start the HTTP or long-polling workers (may still start cron workers)"
msgstr "不要启动HTTP或长轮询工人（仍然可以启动cron的工作人员）"

#: ../../reference/cmdline.rst:167
msgid ""
"has no effect if :option:`--test-enable` is set, as tests require an "
"accessible HTTP server"
msgstr "如果有任何影响：选项：'--test-enable`设置，作为测试要求可访问的HTTP服务器"

#: ../../reference/cmdline.rst:172
msgid ""
"TCP/IP address on which the HTTP server listens, defaults to ``0.0.0.0`` "
"(all addresses)"
msgstr "在其上的HTTP服务器监听TCP / IP地址，默认为``0.0.0.0``（所有地址）"

#: ../../reference/cmdline.rst:177
msgid "Port on which the HTTP server listens, defaults to 8069."
msgstr "端口上的HTTP服务器监听，默认为8069。"

#: ../../reference/cmdline.rst:181
msgid ""
"TCP port for long-polling connections in multiprocessing or gevent mode, "
"defaults to 8072. Not used in default (threaded) mode."
msgstr "对于长轮询连接的多或GEVENT模式的TCP端口，默认为8072.未使用的默认值（线程）模式。"

#: ../../reference/cmdline.rst:185
msgid "logging"
msgstr "记录"

#: ../../reference/cmdline.rst:187
msgid ""
"By default, Odoo displays all logging of level_ ``info`` except for workflow"
" logging (``warning`` only), and log output is sent to ``stdout``. Various "
"options are available to redirect logging to other destinations and to "
"customize the amout of logging output"
msgstr "默认情况下，Odoo显示所有记录level_的``info``除了工作流程记录（``只warning``），和日志的输出发送到``stdout``。各种选项可用来记录重定向到其他目的地，并自定义日志输出的大写金额"

#: ../../reference/cmdline.rst:194
msgid ""
"sends logging output to the specified file instead of stdout. On Unix, the "
"file `can be managed by external log rotation programs "
"<https://docs.python.org/2/library/logging.handlers.html#watchedfilehandler>`_"
" and will automatically be reopened when replaced"
msgstr "发送日志输出到指定的文件，而不是标准输出。在Unix上，文件'可以通过外部的日志轮换计划管理<https://docs.python.org/2/library/logging.handlers.html#watchedfilehandler>`_，并会自动进行更换时，重新打开"

#: ../../reference/cmdline.rst:201
msgid ""
"enables `log rotation "
"<https://docs.python.org/2/library/logging.handlers.html#timedrotatingfilehandler>`_"
" daily, keeping 30 backups. Log rotation frequency and number of backups is "
"not configurable."
msgstr "使`日志旋转<https://docs.python.org/2/library/logging.handlers.html#timedrotatingfilehandler>`_每日，保持30备份。日志旋转频率和备份的数量不可配置。"

#: ../../reference/cmdline.rst:207
msgid ""
"logs to the system's event logger: `syslog on unices "
"<https://docs.python.org/2/library/logging.handlers.html#sysloghandler>`_ "
"and `the Event Log on Windows "
"<https://docs.python.org/2/library/logging.handlers.html#nteventloghandler>`_."
msgstr "登录到系统的事件记录器：`系统日志在Unix系统<https://docs.python.org/2/library/logging.handlers.html#sysloghandler>`_和`事件日志在Windows <https：//开头的文档。 python.org/2/library/logging.handlers.html#nteventloghandler>`_。"

#: ../../reference/cmdline.rst:210
msgid "Neither is configurable"
msgstr "无论是配置"

#: ../../reference/cmdline.rst:214
msgid ""
"logs to the ``ir.logging`` model (``ir_logging`` table) of the specified "
"database. The database can be the name of a database in the \"current\" "
"PostgreSQL, or `a PostgreSQL URI`_ for e.g. log aggregation"
msgstr "登录到指定的数据库的``ir.logging``模型（``ir_logging``表）。该数据库可以在\数据库名称“当前\”PostgreSQL或`一个PostgreSQL URI`_用于例如日志汇总"

#: ../../reference/cmdline.rst:220
msgid ""
":samp:`{LOGGER}:{LEVEL}`, enables ``LOGGER`` at the provided ``LEVEL`` e.g. "
"``openerp.models:DEBUG`` will enable all logging messages at or above "
"``DEBUG`` level in the models."
msgstr "：SAMP：`{}记录器：{LEVEL}`，使``LOGGER``在提供``LEVEL``如``openerp.models：DEBUG``将使所有日志消息或高于``DEBUG``在模型中的水平。"

#: ../../reference/cmdline.rst:224
msgid "The colon ``:`` is mandatory"
msgstr "冒号``：``是必需的"

#: ../../reference/cmdline.rst:225
msgid "The logger can be omitted to configure the root (default) handler"
msgstr "记录器可以被省略，以配置根（默认）的处理程序"

#: ../../reference/cmdline.rst:226
msgid "If the level is omitted, the logger is set to ``INFO``"
msgstr "如果液位被省略，记录器被设置为``INFO``"

#: ../../reference/cmdline.rst:228
msgid "The option can be repeated to configure multiple loggers e.g."
msgstr "可重复的选项配置多个记录器如"

#: ../../reference/cmdline.rst:236
msgid ""
"enable DEBUG logging for RPC requests, equivalent to ``--log-"
"handler=openerp.http.rpc.request:DEBUG``"
msgstr "启用调试日志记录RPC请求，相当于``--log处理程序= openerp.http.rpc.request：DEBUG``"

#: ../../reference/cmdline.rst:241
msgid ""
"enable DEBUG logging for RPC responses, equivalent to ``--log-"
"handler=openerp.http.rpc.response:DEBUG``"
msgstr "启用调试日志记录RPC响应，相当于``--log处理程序= openerp.http.rpc.response：DEBUG``"

#: ../../reference/cmdline.rst:246
msgid ""
"enables DEBUG logging of HTTP requests and responses, equivalent to ``--log-"
"handler=openerp.http:DEBUG``"
msgstr "允许HTTP请求和响应的调试日志，相当于``--log处理程序= openerp.http：DEBUG``"

#: ../../reference/cmdline.rst:251
msgid ""
"enables DEBUG logging of SQL querying, equivalent to ``--log-"
"handler=openerp.sql_db:DEBUG``"
msgstr "使SQL查询的调试日志，相当于``--log处理程序= openerp.sql_db：DEBUG``"

#: ../../reference/cmdline.rst:256
msgid ""
"Shortcut to more easily set predefined levels on specific loggers. \"real\" "
"levels (``critical``, ``error``, ``warn``, ``debug``) are set on the "
"``openerp`` and ``werkzeug`` loggers (except for ``debug`` which is only set"
" on ``openerp``)."
msgstr "快捷更方便地设置具体的记录器预定的水平。 \“真正的\”水平（``critical``，``error``，``warn``，``debug``）是在``openerp``设置和``werkzeug``记录器（除``debug``这是只有设置``openerp``）。"

#: ../../reference/cmdline.rst:261
msgid ""
"Odoo also provides debugging pseudo-levels which apply to different sets of "
"loggers:"
msgstr "Odoo还提供了调试伪级别适用于不同组记录器："

#: ../../reference/cmdline.rst:266
msgid "``debug_sql``"
msgstr "``debug_sql``"

#: ../../reference/cmdline.rst:265
msgid "sets the SQL logger to ``debug``"
msgstr "设置SQL记录器``debug``"

#: ../../reference/cmdline.rst:267
msgid "equivalent to ``--log-sql``"
msgstr "相当于``--log-sql``"

#: ../../reference/cmdline.rst:270
msgid "``debug_rpc``"
msgstr "``debug_rpc``"

#: ../../reference/cmdline.rst:269
msgid "sets the ``openerp`` and HTTP request loggers to ``debug``"
msgstr "设置了``openerp``和HTTP请求记录仪``debug``"

#: ../../reference/cmdline.rst:271
msgid "equivalent to ``--log-level debug --log-request``"
msgstr "相当于``--log级调试--log-request``"

#: ../../reference/cmdline.rst:276
msgid "``debug_rpc_answer``"
msgstr "``debug_rpc_answer``"

#: ../../reference/cmdline.rst:273
msgid ""
"sets the ``openerp`` and HTTP request and response loggers to ``debug``"
msgstr "设置了``openerp``和HTTP请求和响应记录器``debug``"

#: ../../reference/cmdline.rst:276
msgid "equivalent to ``--log-level debug --log-request --log-response``"
msgstr "相当于``--log级调试--log请求--log-response``"

#: ../../reference/cmdline.rst:280
msgid ""
"In case of conflict between :option:`--log-level` and :option:`--log-"
"handler`, the latter is used"
msgstr "万一发生冲突的：选项：'--log-level`和：选项：'--log-handler`，后者用于"

#: ../../reference/cmdline.rst:284
msgid "Advanced options"
msgstr "高级选项"

#: ../../reference/cmdline.rst:288
msgid ""
"enable auto-reloading of python files and xml files without having to "
"restart the server. Requires pyinotify_."
msgstr "启用自动重新加载Python的文件和XML文件，而无需重新启动服务器。需要pyinotify_。"

#: ../../reference/cmdline.rst:294
msgid "Scaffolding"
msgstr "脚手架"

#: ../../reference/cmdline.rst:298
msgid ""
"Scaffolding is the automated creation of a skeleton structure to simplify "
"bootstrapping (of new modules, in the case of Odoo). While not necessary it "
"avoids the tedium of setting up basic structures and looking up what all "
"starting requirements are."
msgstr "脚手架的骨架结构的自动创建以简化自举（新模块，在Odoo的情况下）。虽然没有必要，避免了建立基本结构，望着什么都开始要求的单调乏味。"

#: ../../reference/cmdline.rst:303
msgid ""
"Scaffolding is available via the :command:`odoo.py scaffold` subcommand."
msgstr "命令：`odoo.py scaffold`子脚手架通过可用。"

#: ../../reference/cmdline.rst:307
msgid ""
"a template directory, files are passed through jinja2_ then copied to the "
"``destination`` directory"
msgstr "模板目录下，文件是通过jinja2_然后复制到``destination``目录传递"

#: ../../reference/cmdline.rst:312
msgid ""
"the name of the module to create, may munged in various manners to generate "
"programmatic names (e.g. module directory name, model names, …)"
msgstr "模块创建，名称可以以各种方式被改写的，以产生编程的名称（如模块目录名称，型号名称，...）"

#: ../../reference/cmdline.rst:317
msgid ""
"directory in which to create the new module, defaults to the current "
"directory"
msgstr "在目录中创建新的模块，默认为当前目录"

#: ../../reference/cmdline.rst:323
msgid "Configuration file"
msgstr "配置文件"

#: ../../reference/cmdline.rst:325
msgid ""
"Most of the command-line options can also be specified via a configuration "
"file. Most of the time, they use similar names with the prefix ``-`` removed"
" and other ``-`` are replaced by ``_`` e.g. :option:`--db-template` becomes "
"``db_template``."
msgstr "大多数的命令行选项，也可以通过配置文件中指定。选项​​：`--db-template`变得``db_template``在大多数情况下，他们使用类似名称的前缀``-``删除等``-``通过``_``如被替换。"

#: ../../reference/cmdline.rst:330
msgid "Some conversions don't match the pattern:"
msgstr "有些转换不匹配的格局："

#: ../../reference/cmdline.rst:332
msgid ":option:`--db-filter` becomes ``dbfilter``"
msgstr "：选项：`--db-filter`变得``dbfilter``"

#: ../../reference/cmdline.rst:333
msgid ":option:`--no-xmlrpc` corresponds to the ``xmlrpc`` boolean"
msgstr "：选项：`--no-xmlrpc`相当于``xmlrpc``布尔"

#: ../../reference/cmdline.rst:334
msgid ""
"logging presets (all options starting with ``--log-`` except for :option"
":`--log-handler` and :option:`--log-db`) just add content to "
"``log_handler``, use that directly in the configuration file"
msgstr "记录预设（所有选项开始``--log-``除外：选项：'--log-handler`和：选项：'--log-db`）只是将内容添加到``log_handler``，使用直接在配置文件"

#: ../../reference/cmdline.rst:337
msgid ":option:`--smtp` is stored as ``smtp_server``"
msgstr "：选项：`--smtp`存储为``smtp_server``"

#: ../../reference/cmdline.rst:338
msgid ":option:`--database` is stored as ``dbname``"
msgstr "：选项：`--database`存储为``dbname``"

#: ../../reference/cmdline.rst:339
msgid ":option:`--debug` is stored as ``debug_mode`` (a boolean)"
msgstr "：选项：`--debug`存储为``debug_mode``（一个布尔值）"

#: ../../reference/cmdline.rst:340
msgid ""
":option:`--i18n-import` and :option:`--i18n-export` aren't available at all "
"from configuration files"
msgstr "：选项：`--i18n-import`和：选项：`--i18n-export`不可用在所有的配置文件"

#: ../../reference/cmdline.rst:343
msgid ""
"The default configuration file is :file:`{$HOME}/.openerp_serverrc` which "
"can be overridden using :option:`--config <odoo.py -c>`. Specifying "
":option:`--save <odoo.py -s>` will save the current configuration state back"
" to that file."
msgstr "默认的配置文件是：文件：`{$ HOME} / openerp_serverrc`可使用被覆盖。选项：`--config <odoo.py -c>`。指定：选项：`--save <odoo.py -s>`将保存当前配置的状态恢复到该文件。"

#: ../../reference/data.rst:7
msgid "Data Files"
msgstr "数据文件"

#: ../../reference/data.rst:9
msgid ""
"Odoo is greatly data-driven, and a big part of modules definition is thus "
"the definition of the various records it manages: UI (menus and views), "
"security (access rights and access rules), reports and plain data are all "
"defined via records."
msgstr "Odoo是极大的数据驱动的，因而模块定义的一个重要组成部分，是各个记录它所管理的定义：用户界面（菜单和视图），安全性（访问权限和访问规则），报告和普通数据都是通过记录定义。"

#: ../../reference/data.rst:15
msgid "Structure"
msgstr "结构体"

#: ../../reference/data.rst:17
msgid ""
"The main way to define data in Odoo is via XML data files: The broad "
"structure of an XML data file is the following:"
msgstr "在Odoo定义数据的主要途径是通过XML数据文件：XML数据文件的大体结构如下："

#: ../../reference/data.rst:20
msgid "Any number of operation elements within the root element ``odoo``"
msgstr "任何数量的根元素``内的操作元素odoo``"

#: ../../reference/data.rst:30
msgid ""
"Data files are executed sequentially, operations can only refer to the "
"result of operations defined previously"
msgstr "数据的文件被顺序地执行，操作只能引用操作先前定义的结果"

#: ../../reference/data.rst:34
msgid "Core operations"
msgstr "核心业务"

#: ../../reference/data.rst:39 ../../reference/views.rst:863
msgid "``record``"
msgstr "``record``"

#: ../../reference/data.rst:41
msgid ""
"``record`` appropriately defines or updates a database record, it has the "
"following attributes:"
msgstr "``record``适当定义或更新的数据库记录，它具有下列特性："

#: ../../reference/data.rst:44 ../../reference/data.rst:134
msgid "``model`` (required)"
msgstr "``model``（必填）"

#: ../../reference/data.rst:45
msgid "name of the model to create (or update)"
msgstr "该模型的名称以创建（或更新）"

#: ../../reference/data.rst:47
msgid ""
"the :term:`external identifier` for this record. It is strongly recommended "
"to provide one"
msgstr "中：短期：`外部identifier`此记录。强烈建议，以提供一个"

#: ../../reference/data.rst:50
msgid ""
"for record creation, allows subsequent definitions to either modify or refer"
" to this record"
msgstr "备案创作，让后续的定义，要么修改或引用此记录"

#: ../../reference/data.rst:52
msgid "for record modification, the record to modify"
msgstr "备案变更，备案修改"

#: ../../reference/data.rst:54
msgid "context to use when creating the record"
msgstr "上下文创建记录时使用"

#: ../../reference/data.rst:58
msgid "``forcecreate``"
msgstr "``forcecreate``"

#: ../../reference/data.rst:56
msgid ""
"in update mode whether the record should be created if it doesn't exist"
msgstr "在更新模式是否该记录应该创建，如果它不存在"

#: ../../reference/data.rst:58
msgid "Requires an :term:`external id`, defaults to ``True``."
msgstr "需要一个：短期：`外部ID`，默认值为``True``。"

#: ../../reference/data.rst:61 ../../reference/views.rst:284
#: ../../reference/views.rst:425 ../../reference/views.rst:841
#: ../../reference/views.rst:1138
msgid "``field``"
msgstr "``field``"

#: ../../reference/data.rst:63
msgid ""
"Each record can be composed of ``field`` tags, defining values to set when "
"creating the record. A ``record`` with no ``field`` will use all default "
"values (creation) or do nothing (update)."
msgstr "每个记录可以由``field``标签，定义价值创造的纪录时设置。一个``record``没有``field``将使用所有默认值（创建），或者什么也不做（更新）。"

#: ../../reference/data.rst:67
msgid ""
"A ``field`` has a mandatory ``name`` attribute, the name of the field to "
"set, and various methods to define the value itself:"
msgstr "甲``field``具有强制性``name``属性，该字段设置的名称，以及各种方法来定义的值本身："

#: ../../reference/data.rst:72
msgid "Nothing"
msgstr "没有"

#: ../../reference/data.rst:71
msgid ""
"if no value is provided for the field, an implicit ``False`` will be set on "
"the field. Can be used to clear a field, or avoid using a default value for "
"the field."
msgstr "如果提供的字段没有值，一个隐式``False``将在字段进行设置。可以用来清除字段，或避免使用的字段的缺省值。"

#: ../../reference/data.rst:79 ../../reference/data.rst:140
msgid "``search``"
msgstr "``search``"

#: ../../reference/data.rst:75
msgid ""
"for :ref:`relational fields <reference/orm/fields/relational>`, should be a "
":ref:`domain <reference/orm/domains>` on the field's model."
msgstr "为：参考：`关系领域<参考/ ORM /场/关系>`，应该是：参考：'域<参考/ ORM /域>`在球场上的典范。"

#: ../../reference/data.rst:78
msgid ""
"Will evaluate the domain, search the field's model using it and set the "
"search's result as the field's value. Will only use the first result if the "
"field is a :class:`~openerp.fields.Many2one`"
msgstr "将评估领域，利用其搜索领域的模式和设定搜索的结果作为该字段的值。将只使用第一个结果，如果该字段为：类：`〜openerp.fields.Many2one`"

#: ../../reference/data.rst:85
msgid "``ref``"
msgstr "``ref``"

#: ../../reference/data.rst:82
msgid ""
"if a ``ref`` attribute is provided, its value must be a valid "
":term:`external id`, which will be looked up and set as the field's value."
msgstr "如果提供了``ref``属性，它的值必须是有效的：期限：`外部ID`，这将是抬起头，设置为字段的值。"

#: ../../reference/data.rst:85
msgid ""
"Mostly for :class:`~openerp.fields.Many2one` and "
":class:`~openerp.fields.Reference` fields"
msgstr "主要用于：类：`〜openerp.fields.Many2one`和：类：`〜openerp.fields.Reference`领域"

#: ../../reference/data.rst:88
msgid ""
"if a ``type`` attribute is provided, it is used to interpret and convert the"
" field's content. The field's content can be provided through an external "
"file using the ``file`` attribute, or through the node's body."
msgstr "如果提供了``type``属性，它是用来解释并转换该字段的内容。该字段的内容可以通过一个外部文件使用``file``属性来提供，或通过节点的身体。"

#: ../../reference/data.rst:92
msgid "Available types are:"
msgstr "可用的类型有："

#: ../../reference/data.rst:96
msgid "``xml``, ``html``"
msgstr "``xml``，``html``"

#: ../../reference/data.rst:95
msgid ""
"extracts the ``field``'s children as a single document, evaluates any "
":term:`external id` specified with the form ``%(external_id)s``. ``%%`` can "
"be used to output actual *%* signs."
msgstr "提取``field``的孩子作为一个单一的文件，任何评估：短期：`的形式``％（external_id）s``指定的外部ID`。 ``%%``可用于输出实际*％*迹象。"

#: ../../reference/data.rst:99
msgid "``file``"
msgstr "``file``"

#: ../../reference/data.rst:99
msgid ""
"ensures that the field content is a valid file path in the current model, "
"saves the pair :samp:`{module},{path}` as the field value"
msgstr "确保该字段的内容是在当前模型一个有效的文件路径，保存对：SAMP：`{模块}，{路径}`作为字段值"

#: ../../reference/data.rst:102
msgid "``char``"
msgstr "``char``"

#: ../../reference/data.rst:102
msgid ""
"sets the field content directly as the field's value without alterations"
msgstr "直接设置字段内容没有改变该字段的值"

#: ../../reference/data.rst:105
msgid "``base64``"
msgstr "``base64``"

#: ../../reference/data.rst:105
msgid ""
"base64_-encodes the field's content, useful combined with the ``file`` "
"*attribute* to load e.g. image data into attachments"
msgstr "base64_-编码字段的内容，有用的结合``file`` *属性*到如图像数据加载到附件"

#: ../../reference/data.rst:108
msgid "``int``"
msgstr "``int``"

#: ../../reference/data.rst:108
msgid ""
"converts the field's content to an integer and sets it as the field's value"
msgstr "该字段的内容转换为整数，并将其设置该字段的值"

#: ../../reference/data.rst:111
msgid "``float``"
msgstr "``float``"

#: ../../reference/data.rst:111
msgid ""
"converts the field's content to a float and sets it as the field's value"
msgstr "该字段的内容转换为浮动，并将其设置字段的值"

#: ../../reference/data.rst:116
msgid "``list``, ``tuple``"
msgstr "``list``，``tuple``"

#: ../../reference/data.rst:114
msgid ""
"should contain any number of ``value`` elements with the same properties as "
"``field``, each element resolves to an item of a generated tuple or list, "
"and the generated collection is set as the field's value"
msgstr "应该包含任何数目的``value``元件具有相同属性如``field``，每个元素解析为生成元组或列表的一个项目，并将所产生的集合被设置为字段的值"

#: ../../reference/data.rst:126
msgid "``eval``"
msgstr "``eval``"

#: ../../reference/data.rst:119
msgid ""
"for cases where the previous methods are unsuitable, the ``eval`` attributes"
" simply evaluates whatever Python expression it is provided and sets the "
"result as the field's value."
msgstr "为在先前的方法是不适合的情况下，``eval``属性简单地计算任何Python表达式它被设置，并设置其结果作为该字段的值。"

#: ../../reference/data.rst:123
msgid ""
"The evaluation context contains various modules (``time``, ``datetime``, "
"``timedelta``, ``relativedelta``), a function to resolve :term:`external "
"identifiers` (``ref``) and the model object for the current field if "
"applicable (``obj``)"
msgstr "评价范围内包含各种模块（``time``，``datetime``，``timedelta``，``relativedelta``），一个函数来解决：短期：`外部identifiers`（``ref``）和当前场中的模型对象（如果适用）（``obj``）"

#: ../../reference/data.rst:129 ../../reference/views.rst:891
msgid "``delete``"
msgstr "``delete``"

#: ../../reference/data.rst:131
msgid ""
"The ``delete`` tag can remove any number of records previously defined. It "
"has the following attributes:"
msgstr "该``delete``标签可以删除先前定义的任何数量的记录。它具有以下属性："

#: ../../reference/data.rst:135
msgid "the model in which a specified record should be deleted"
msgstr "其中一个指定的记录应予以删除模型"

#: ../../reference/data.rst:137
msgid "the :term:`external id` of a record to remove"
msgstr "中：短期：`创纪录的外部ID`删除"

#: ../../reference/data.rst:139
msgid ""
"a :ref:`domain <reference/orm/domains>` to find records of the model to "
"remove"
msgstr "答：参考：'域<参考/ ORM /域>`来找到模型的记录删除"

#: ../../reference/data.rst:142
msgid "``id`` and ``search`` are exclusive"
msgstr "``id``和``search``是互斥"

#: ../../reference/data.rst:145
msgid "``function``"
msgstr "``function``"

#: ../../reference/data.rst:147
msgid ""
"The ``function`` tag calls a method on a model, with provided parameters. It"
" has two mandatory parameters ``model`` and ``name`` specifying respectively"
" the model and the name of the method to call."
msgstr "该``function``标签调用一个模型，提供的参数的方法。它有两个强制参数``model``和``name``分别指定模型和调用的方法的名称。"

#: ../../reference/data.rst:151
msgid ""
"Parameters can be provided using ``eval`` (should evaluate to a sequence of "
"parameters to call the method with) or ``value`` elements (see ``list`` "
"values)."
msgstr "参数可以使用``eval``（应该评估的参数序列与调用方法）或``value``元素（见``list``值）来提供。"

#: ../../reference/data.rst:156
msgid "``workflow``"
msgstr "``workflow``"

#: ../../reference/data.rst:158
msgid ""
"The ``workflow`` tag sends a signal to an existing workflow. The workflow "
"can be specified via a ``ref`` attribute (the :term:`external id` of an "
"existing workflow) or a ``value`` tag returning the id of a workflow."
msgstr "在``workflow``标签发送信号到现有的工作流程。 （：短期：`现有工作流程的外部ID`的）或``value``标签返回一个工作流的ID的工作流可以通过``ref``属性来指定。"

#: ../../reference/data.rst:162
msgid ""
"The tag also has two mandatory attributes ``model`` (the model linked to the"
" workflow) and ``action`` (the name of the signal to send to the workflow)."
msgstr "标签也有两个必选属性``model``（链接到工作流模型）和``action``（信号的名称发送到工作流）。"

#: ../../reference/data.rst:168
msgid "Shortcuts"
msgstr "快捷键"

#: ../../reference/data.rst:170
msgid ""
"Because some important structural models of Odoo are complex and involved, "
"data files provide shorter alternatives to defining them using :ref:`record "
"tags <reference/data/record>`:"
msgstr "由于Odoo的一些重要结构模型非常复杂，涉及到数据文件提供给使用定义它们更短的替代方案：参考：`记录标记<参考/数据/记录>`："

#: ../../reference/data.rst:175
msgid "``menuitem``"
msgstr "``menuitem``"

#: ../../reference/data.rst:177
msgid ""
"Defines an ``ir.ui.menu`` record with a number of defaults and fallbacks:"
msgstr "定义了一些默认值和回退的``ir.ui.menu``记录："

#: ../../reference/data.rst:186
msgid "Parent menu"
msgstr "父菜单"

#: ../../reference/data.rst:180
msgid ""
"If a ``parent`` attribute is set, it should be the :term:`external id` of an"
" other menu item, used as the new item's parent"
msgstr "如果``parent``属性设置，它应该是：期限：`的其他菜单项的外部ID`，用作新项目的父"

#: ../../reference/data.rst:182
msgid ""
"If no ``parent`` is provided, tries to interpret the ``name`` attribute as a"
" ``/``-separated sequence of menu names and find a place in the menu "
"hierarchy. In that interpretation, intermediate menus are automatically "
"created"
msgstr "如果没有``parent``提供，试图解释``name``属性为``/`` - 分隔菜单名称的序列，发现在菜单层级的地方。在这种解释，自动创建中间的菜单"

#: ../../reference/data.rst:186
msgid ""
"Otherwise the menu is defined as a \"top-level\" menu item (*not* a menu "
"with no parent)"
msgstr "否则，菜单被定义为一个\“顶层\”菜单项（*不*没有父菜单）"

#: ../../reference/data.rst:189
msgid "Menu name"
msgstr "菜单名称"

#: ../../reference/data.rst:189
msgid ""
"If no ``name`` attribute is specified, tries to get the menu name from a "
"linked action if any. Otherwise uses the record's ``id``"
msgstr "如果没有指定``name``属性，试图从一个链接的行动，如果得到任何菜单名称。否则，使用记录的``id``"

#: ../../reference/data.rst:194
msgid "Groups"
msgstr "组"

#: ../../reference/data.rst:192
msgid ""
"A ``groups`` attribute is interpreted as a comma-separated sequence of "
":term:`external identifiers` for ``res.groups`` models. If an "
":term:`external identifier` is prefixed with a minus (``-``), the group is "
"*removed* from the menu's groups"
msgstr "一个``groups``属性被解释为一个逗号分隔的序列：术语：`外部identifiers`的``res.groups``车型。如果：短期：`外部identifier`前缀为负（``-``），该集团*删除*从菜单中的组"

#: ../../reference/data.rst:197 ../../reference/views.rst:214
msgid "``action``"
msgstr "``action``"

#: ../../reference/data.rst:197
msgid ""
"if specified, the ``action`` attribute should be the :term:`external id` of "
"an action to execute when the menu is open"
msgstr "如果指定了``action``属性应该是：条件：执行操作的'外部ID`当菜单打开"

#: ../../reference/data.rst:200
msgid "the menu item's :term:`external id`"
msgstr "菜单项的：期限：`外部ID`"

#: ../../reference/data.rst:205
msgid "``template``"
msgstr "``template``"

#: ../../reference/data.rst:207
msgid ""
"Creates a :ref:`QWeb view <reference/views/qweb>` requiring only the "
"``arch`` section of the view, and allowing a few *optional* attributes:"
msgstr "创建：参考：`QWeb查看<参考/视图/ qweb>`要求来看，只有``arch``部分，并允许一些*可选*属性："

#: ../../reference/data.rst:211
msgid "the view's :term:`external identifier`"
msgstr "该视图的：期限：`外部identifier`"

#: ../../reference/data.rst:213
msgid "``name``, ``inherit_id``, ``priority``"
msgstr "``name``，``inherit_id``，``priority``"

#: ../../reference/data.rst:213
msgid ""
"same as the corresponding field on ``ir.ui.view`` (nb: ``inherit_id`` should"
" be an :term:`external identifier`)"
msgstr "同为相应的字段``ir.ui.view``（注意：``inherit_id``应该是：期限：`外部identifier`）"

#: ../../reference/data.rst:216
msgid "``primary``"
msgstr "``primary``"

#: ../../reference/data.rst:216
msgid ""
"if set to ``True`` and combined with a ``inherit_id``, defines the view as a"
" primary"
msgstr "如果设置为``True和结合了``inherit_id``，定义视图作为主"

#: ../../reference/data.rst:218 ../../reference/reports.rst:46
#: ../../reference/views.rst:258 ../../reference/views.rst:384
#: ../../reference/views.rst:1129 ../../reference/views.rst:1164
msgid "``groups``"
msgstr "``groups``"

#: ../../reference/data.rst:219
msgid "comma-separated list of group :term:`external identifiers`"
msgstr "长期：组逗号分隔的列表`外部identifiers`"

#: ../../reference/data.rst:221
msgid "``page``"
msgstr "``page``"

#: ../../reference/data.rst:221
msgid ""
"if set to ``\"True\"``, the template is a website page (linkable to, "
"deletable)"
msgstr "如果设置为``\“真正的\”``，该模板是一个网站的页面（可链接到，可删除）"

#: ../../reference/data.rst:226
msgid "``optional``"
msgstr "``optional``"

#: ../../reference/data.rst:224
msgid ""
"``enabled`` or ``disabled``, whether the view can be disabled (in the "
"website interface) and its default status. If unset, the view is always "
"enabled."
msgstr "``enabled``或``disabled``，视图是否可以被禁用（在网站界面）和它的默认状态。如果未设置，视图始终启用。"

#: ../../reference/data.rst:229
msgid "``report``"
msgstr "``report``"

#: ../../reference/data.rst:231
msgid "Creates a ``ir.actions.report.xml`` record with a few default values."
msgstr "创建一个带有一些默认值``ir.actions.report.xml``记录。"

#: ../../reference/data.rst:233
msgid ""
"Mostly just proxies attributes to the corresponding fields on "
"``ir.actions.report.xml``, but also automatically creates the item in the "
":guilabel:`More` menu of the report's ``model``."
msgstr "大多只是委托书``ir.actions.report.xml``属性对应的字段，而且还自动创建的项目：guilabel：`报告的``model``的More`菜单。"

#: ../../reference/data.rst:240
msgid "CSV data files"
msgstr "CSV数据文件"

#: ../../reference/data.rst:242
msgid ""
"XML data files are flexible and self-descriptive, but very verbose when "
"creating a number of simple records of the same model in bulk."
msgstr "造就了一批散装相同型号的简单记录时XML数据文件是灵活的，自描述的，但很冗长。"

#: ../../reference/data.rst:245
msgid ""
"For this case, data files can also use csv_, this is often the case for "
":ref:`access rights <reference/security/acl>`:"
msgstr "对于这种情况，数据文件，也可以使用csv_，这往往是这样的：REF：访问权限<参考/安全/ ACL>``："

#: ../../reference/data.rst:248
msgid "the file name is :file:`{model_name}.csv`"
msgstr "该文件的名称是：文件：`{} MODEL_NAME .csv`"

#: ../../reference/data.rst:249
msgid ""
"the first row lists the fields to write, with the special field ``id`` for "
":term:`external identifiers` (used for creation or update)"
msgstr "第一行列出的字段来写，用专业的``id``为：期限：`外部identifiers`（用于创建或更新）"

#: ../../reference/data.rst:251
msgid "each row thereafter creates a new record"
msgstr "每一行之后创建一个新记录"

#: ../../reference/data.rst:253
msgid ""
"Here's the first lines of the data file defining US states "
"``res.country.state.csv``"
msgstr "下面是数据文件的第一行定义美国各州``res.country.state.csv``"

#: ../../reference/data.rst:260
msgid "rendered in a more readable format:"
msgstr "呈现在一个更可读的格式："

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "id"
msgstr "ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "country_id:id"
msgstr "COUNTRY_ID：ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "name"
msgstr "名字"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "code"
msgstr "代码"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_1"
msgstr "state_au_1"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "au"
msgstr "金"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Australian Capital Territory"
msgstr "澳大利亚首都直辖区"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ACT"
msgstr "ACT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_2"
msgstr "state_au_2"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New South Wales"
msgstr "新南威尔士"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NSW"
msgstr "新南威尔士州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_3"
msgstr "state_au_3"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Northern Territory"
msgstr "北领地"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NT"
msgstr "新台币"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_4"
msgstr "state_au_4"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Queensland"
msgstr "昆士兰"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "QLD"
msgstr "昆士兰州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_5"
msgstr "state_au_5"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Australia"
msgstr "南澳大利亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SA"
msgstr "SA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_6"
msgstr "state_au_6"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Tasmania"
msgstr "塔斯马尼亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TAS"
msgstr "TAS"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_7"
msgstr "state_au_7"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Victoria"
msgstr "维多利亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VIC"
msgstr "VIC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_8"
msgstr "state_au_8"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Western Australia"
msgstr "西澳大利亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WA"
msgstr "WA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_1"
msgstr "state_us_1"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "us"
msgstr "我们"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Alabama"
msgstr "阿拉巴马州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AL"
msgstr "AL"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_2"
msgstr "state_us_2"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Alaska"
msgstr "阿拉斯加州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AK"
msgstr "AK"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_3"
msgstr "state_us_3"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Arizona"
msgstr "亚利桑那"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AZ"
msgstr "AZ"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_4"
msgstr "state_us_4"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Arkansas"
msgstr "阿肯色州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AR"
msgstr "AR"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_5"
msgstr "state_us_5"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "California"
msgstr "加利福尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CA"
msgstr "CA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_6"
msgstr "state_us_6"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Colorado"
msgstr "科罗拉多州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CO"
msgstr "CO"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_7"
msgstr "state_us_7"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Connecticut"
msgstr "康涅狄格"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CT"
msgstr "CT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_8"
msgstr "state_us_8"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Delaware"
msgstr "特拉华州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "DE"
msgstr "DE"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_9"
msgstr "state_us_9"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "District of Columbia"
msgstr "哥伦比亚区"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "DC"
msgstr "DC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_10"
msgstr "state_us_10"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Florida"
msgstr "佛罗里达"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "FL"
msgstr "佛罗里达州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_11"
msgstr "state_us_11"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Georgia"
msgstr "格鲁吉亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "GA"
msgstr "GA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_12"
msgstr "state_us_12"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Hawaii"
msgstr "夏威夷"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "HI"
msgstr "您好"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_13"
msgstr "state_us_13"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Idaho"
msgstr "爱达荷州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ID"
msgstr "ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_14"
msgstr "state_us_14"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Illinois"
msgstr "伊利诺伊"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IL"
msgstr "IL"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_15"
msgstr "state_us_15"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Indiana"
msgstr "印地安那"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IN"
msgstr "在"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_16"
msgstr "state_us_16"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Iowa"
msgstr "爱荷华州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IA"
msgstr "IA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_17"
msgstr "state_us_17"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Kansas"
msgstr "堪萨斯州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "KS"
msgstr "KS"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_18"
msgstr "state_us_18"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Kentucky"
msgstr "肯塔基州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "KY"
msgstr "KY"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_19"
msgstr "state_us_19"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Louisiana"
msgstr "路易斯安那州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "LA"
msgstr "LA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_20"
msgstr "state_us_20"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Maine"
msgstr "缅因"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ME"
msgstr "ME"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_21"
msgstr "state_us_21"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Montana"
msgstr "蒙大拿"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MT"
msgstr "MT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_22"
msgstr "state_us_22"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Nebraska"
msgstr "内布拉斯加"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NE"
msgstr "NE"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_23"
msgstr "state_us_23"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Nevada"
msgstr "内华达"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NV"
msgstr "NV"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_24"
msgstr "state_us_24"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Hampshire"
msgstr "新罕布什尔"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NH"
msgstr "NH"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_25"
msgstr "state_us_25"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Jersey"
msgstr "新泽西州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NJ"
msgstr "新泽西州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_26"
msgstr "state_us_26"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Mexico"
msgstr "新墨西哥"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NM"
msgstr "NM"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_27"
msgstr "state_us_27"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New York"
msgstr "纽约"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NY"
msgstr "纽约"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_28"
msgstr "state_us_28"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "North Carolina"
msgstr "北卡罗来纳"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NC"
msgstr "NC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_29"
msgstr "state_us_29"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "North Dakota"
msgstr "北达科他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ND"
msgstr "ND"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_30"
msgstr "state_us_30"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Ohio"
msgstr "俄亥俄"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OH"
msgstr "OH"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_31"
msgstr "state_us_31"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Oklahoma"
msgstr "俄克拉何马州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OK"
msgstr "行"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_32"
msgstr "state_us_32"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Oregon"
msgstr "俄勒冈"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OR"
msgstr "要么"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_33"
msgstr "state_us_33"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Maryland"
msgstr "马里兰"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MD"
msgstr "MD"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_34"
msgstr "state_us_34"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Massachusetts"
msgstr "马萨诸塞州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MA"
msgstr "嘛"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_35"
msgstr "state_us_35"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Michigan"
msgstr "密歇根"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MI"
msgstr "MI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_36"
msgstr "state_us_36"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Minnesota"
msgstr "明尼苏达州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MN"
msgstr "MN"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_37"
msgstr "state_us_37"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Mississippi"
msgstr "密西西比"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MS"
msgstr "女士"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_38"
msgstr "state_us_38"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Missouri"
msgstr "密苏里州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MO"
msgstr "MO"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_39"
msgstr "state_us_39"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Pennsylvania"
msgstr "宾夕法尼亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "PA"
msgstr "PA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_40"
msgstr "state_us_40"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Rhode Island"
msgstr "罗德岛"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "RI"
msgstr "RI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_41"
msgstr "state_us_41"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Carolina"
msgstr "南卡罗来纳"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SC"
msgstr "SC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_42"
msgstr "state_us_42"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Dakota"
msgstr "南达科他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SD"
msgstr "SD"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_43"
msgstr "state_us_43"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Tennessee"
msgstr "田纳西"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TN"
msgstr "TN"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_44"
msgstr "state_us_44"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Texas"
msgstr "得克萨斯州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TX"
msgstr "TX"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_45"
msgstr "state_us_45"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Utah"
msgstr "犹他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "UT"
msgstr "UT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_46"
msgstr "state_us_46"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Vermont"
msgstr "佛蒙特"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VT"
msgstr "VT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_47"
msgstr "state_us_47"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Virginia"
msgstr "弗吉尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VA"
msgstr "VA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_48"
msgstr "state_us_48"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Washington"
msgstr "华盛顿"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_49"
msgstr "state_us_49"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "West Virginia"
msgstr "西弗吉尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WV"
msgstr "WV"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_50"
msgstr "state_us_50"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Wisconsin"
msgstr "威斯康星"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WI"
msgstr "WI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_51"
msgstr "state_us_51"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Wyoming"
msgstr "怀俄明"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WY"
msgstr "WY"

#: ../../reference/data.rst:267
msgid "For each row (record):"
msgstr "对于每一行（记录）："

#: ../../reference/data.rst:269
msgid ""
"the first column is the :term:`external id` of the record to create or "
"update"
msgstr "第一列是：期限：`记录创建或更新的外部ID`"

#: ../../reference/data.rst:271
msgid ""
"the second column is the :term:`external id` of the country object to link "
"to (country objects must have been defined beforehand)"
msgstr "第二列是：期限：`全国对象链接到外部ID`（国家对象必须已预先定义）"

#: ../../reference/data.rst:273
msgid "the third column is the ``name`` field for ``res.country.state``"
msgstr "第三列是``name``领域``res.country.state``"

#: ../../reference/data.rst:274
msgid "the fourth column is the ``code`` field for ``res.country.state``"
msgstr "第四列是``code``领域``res.country.state``"

#: ../../reference/guidelines.rst:7
msgid "Odoo Guidelines"
msgstr "Odoo指南"

#: ../../reference/guidelines.rst:9
msgid ""
"This page introduce the new Odoo Coding Guidelines. These guidelines aim to "
"improve the quality of the code (better readability of source, ...) and  "
"Odoo Apps. Indeed, proper code ought ease maintenance, aid debugging, lower "
"complexity and promote reliability."
msgstr "此页面介绍新Odoo编码指南。这些指南的目的是提高代码的质量（更好的可读性源，...）和Odoo应用程序。事实上，正确的代码应该便于维护，帮助调试，降低复杂性，并促进可靠性。"

#: ../../reference/guidelines.rst:15
msgid "Module structure"
msgstr "模块结构"

#: ../../reference/guidelines.rst:18
msgid "Directories"
msgstr "目录"

#: ../../reference/guidelines.rst:19
msgid "A module is organised in a few directory :"
msgstr "一个模块被组织在几个目录："

#: ../../reference/guidelines.rst:21
msgid "*data/* : demo and data xml"
msgstr "*数据/ *：演示和数据的XML"

#: ../../reference/guidelines.rst:22
msgid "*models/* : models definition"
msgstr "*型号/ *：模型定义"

#: ../../reference/guidelines.rst:23
msgid "*controllers/* : contains controllers (http routes)."
msgstr "*控制器/ *：包含控制器（HTTP路由）。"

#: ../../reference/guidelines.rst:24
msgid "*views/* : contains the views and templates"
msgstr "*意见/ *：包含的意见和模板"

#: ../../reference/guidelines.rst:25
msgid ""
"*static/* : contains the web assets, separated into *css/, js/, img/, lib/, "
"...*"
msgstr "*静态/ *：包含web资源，分离成* CSS /，JS /，IMG /，LIB / ... *"

#: ../../reference/guidelines.rst:28
msgid "File naming"
msgstr "文件命名"

#: ../../reference/guidelines.rst:29
msgid ""
"For *views* declarations, split backend views from (frontend) templates in 2"
" differents files."
msgstr "对于*意见*声明，拆分后端从（前端）的2型动物文件模板的意见。"

#: ../../reference/guidelines.rst:32
msgid ""
"For *models*, split the business logic by sets of models, in each set select"
" a main model, this model gives its name to the set. If there is only one "
"model, its name is the same as the module name. For each set named "
"<main_model> the following files may be created:"
msgstr "对于*型号*，拆分业务逻辑通过套模型，在每一组中选择一个主要的模式，这一模式给它的名字集合。如果只有一个模型，它的名字是相同的模块的名字。对于每一组名为<MAIN_MODEL>下列文件可以被创建："

#: ../../reference/guidelines.rst:37
msgid ":file:`models/{<main_model>}.py`"
msgstr "：文件：`模型/ {<MAIN_MODEL>} py`"

#: ../../reference/guidelines.rst:38
msgid ":file:`models/{<inherited_main_model>}.py`"
msgstr "：文件：`模型/ {<inherited_main_model>} py`"

#: ../../reference/guidelines.rst:39
msgid ":file:`views/{<main_model>}_templates.xml`"
msgstr "：文件：`观点/ {<MAIN_MODEL>} _ templates.xml`"

#: ../../reference/guidelines.rst:40
msgid ":file:`views/{<main_model>}_views.xml`"
msgstr "：文件：`观点/ {<MAIN_MODEL>} _ views.xml`"

#: ../../reference/guidelines.rst:42
msgid ""
"For instance, *sale* module introduces ``sale_order`` and "
"``sale_order_line`` where ``sale_order`` is dominant. So the "
"``<main_model>`` files will be named :file:`models/sale_order.py` and "
":file:`views/sale_order_views.py`."
msgstr "例如，*销售*模块引入了``sale_order``和``sale_order_line``其中``sale_order``占主导地位。所以``<MAIN_MODEL>``文件将被命名为：文件：`模型/ sale_order.py`和：文件：`观点/ sale_order_views.py`。"

#: ../../reference/guidelines.rst:48
msgid ""
"For *data*, split them by purpose : demo or data. The filename will be the "
"main_model name, suffixed by *_demo.xml* or *_data.xml*."
msgstr "演示或数据：对于*数据*，按用途分割。文件名会是MAIN_MODEL名称，由* _demo.xml *或* _data.xml *后缀。"

#: ../../reference/guidelines.rst:51
msgid "For *controller*, the only file should be named *main.py*."
msgstr "对于*器*，唯一的文件应该命名为* main.py *。"

#: ../../reference/guidelines.rst:53
msgid ""
"For *static files*, the name pattern is *<module_name>.ext* (i.e. : "
"static/js/im_chat.js, static/css/im_chat.css, static/xml/im_chat.xml, ...). "
"Don't link data (image, libraries) outside Odoo : don't use an url to an "
"image but copy it in our codebase instead."
msgstr "对于*静态文件*，名字模式是* <模块> .EXT *（即：静态/ JS / im_chat.js，静态/ CSS / im_chat.css，静态/ XML / im_chat.xml，...）。不要链接数据（图像，图书馆）Odoo外：不使用的URL的图像，但其复制到我们的代码库，而不是。"

#: ../../reference/guidelines.rst:58
msgid "The complete tree should look like"
msgstr "整个树看起来应该像"

#: ../../reference/guidelines.rst:100
msgid ""
"File names should only contain ``[a-z0-9_]`` (lowercase alphanumerics and "
"``_``)"
msgstr "文件名应该只包含``[A-Z0-9 _]``（小写字母数字和``_``）"

#: ../../reference/guidelines.rst:103
msgid "Use correct file permissions : folder 755 and file 644."
msgstr "使用正确的文件权限：文件夹755和文件644。"

#: ../../reference/guidelines.rst:106
msgid "XML files"
msgstr "XML文件"

#: ../../reference/guidelines.rst:109
msgid "Format"
msgstr "格式"

#: ../../reference/guidelines.rst:110
msgid "When declaring a record in XML,"
msgstr "当XML声明的记录，"

#: ../../reference/guidelines.rst:112
msgid "Place ``id`` attribute before ``model``"
msgstr "地方``model``之前``id``属性"

#: ../../reference/guidelines.rst:113
msgid ""
"For field declaration, ``name`` attribute is first. Then place the *value* "
"either in the ``field`` tag, either in the ``eval`` attribute, and finally "
"other attributes (widget, options, ...) ordered by importance."
msgstr "对于现场报关，``name``属性是第一位。然后把*值*无论是在``field``标签，无论是在``eval``属性，最后其他属性（窗口小部件，选项...）订购的重要性。"

#: ../../reference/guidelines.rst:118
msgid ""
"Try to group the record by model. In case of dependencies between "
"action/menu/views, the convention may not be applicable."
msgstr "要力图通过模型的记录。如果动作/菜单/视图之间的依赖关系，该公约可能不适用。"

#: ../../reference/guidelines.rst:120
msgid "Use naming convention defined at the next point"
msgstr "当时所用的下一个点定义命名规则"

#: ../../reference/guidelines.rst:121
msgid ""
"The tag *<data>* is only used to set not-updatable data with ``noupdate=1``"
msgstr "标签* <数据> *仅用于与``NOUPD​​ATE = 1``设置未更新数据"

#: ../../reference/guidelines.rst:139
msgid "Naming xml_id"
msgstr "命名xml_id"

#: ../../reference/guidelines.rst:142
msgid "Security, View and Action"
msgstr "安全，查看和操作"

#: ../../reference/guidelines.rst:144
msgid "Use the following pattern :"
msgstr "请使用以下方式："

#: ../../reference/guidelines.rst:146
msgid "For a menu: :samp:`{<model_name>}_menu`"
msgstr "对于菜单：SAMP：`{<MODEL_NAME>} _ menu`"

#: ../../reference/guidelines.rst:147
msgid ""
"For a view: :samp:`{<model_name>}_view_{<view_type>}`, where *view_type* is "
"``kanban``, ``form``, ``tree``, ``search``, ..."
msgstr "对于一个观点：SAMP：`{<MODEL_NAME>} _观点_ {<的view_type>}`，其中*的view_type *是``kanban``，``form``，``tree``，``search``， ..."

#: ../../reference/guidelines.rst:149
msgid ""
"For an action: the main action respects :samp:`{<model_name>}_action`. "
"Others are suffixed with :samp:`_{<detail>}`, where *detail* is a lowercase "
"string briefly explaining the action. This is used only if multiple actions "
"are declared for the model."
msgstr "对于一个动作：主操作方面：SAMP：`{<MODEL_NAME>} _ action`。其他人则后缀：SAMP：`_ {<详细>}`，其中*详细*是一个小写的字符串，简要说明操作。这是仅用于多个动作的模式声明。"

#: ../../reference/guidelines.rst:154
msgid ""
"For a group: :samp:`{<model_name>}_group_{<group_name>}` where *group_name* "
"is the name of the group, generally 'user', 'manager', ..."
msgstr "对于组：SAMP：`{<MODEL_NAME>} _组_ {<组>}`，其中*组名*是组，一般“用户”，“经理”，的名称..."

#: ../../reference/guidelines.rst:156
msgid ""
"For a rule: :samp:`{<model_name>}_rule_{<concerned_group>}` where "
"*concerned_group* is the short name of the concerned group ('user' for the "
"'model_name_group_user', 'public' for public user, 'company' for multi-"
"company rules, ...)."
msgstr "对于一个规则：SAMP：`{<MODEL_NAME>} _规则_ {<concerned_group>}`，其中* concerned_group *是关注组（'用户'的'model_name_group_user“的简称，”公开“公开的用户，”公司多公司规定，...）。"

#: ../../reference/guidelines.rst:200
msgid ""
"View names use dot notation ``my.model.view_type`` or "
"``my.model.view_type.inherit`` instead of *\"This is the form view of My "
"Model\"*."
msgstr "查看名称使用点符号``my.model.view_type``或``my.model.view_type.inherit``，而不是* \“这是我的模型\表单视图”*。"

#: ../../reference/guidelines.rst:206
msgid "Inherited XML"
msgstr "继承XML"

#: ../../reference/guidelines.rst:208
msgid ""
"The naming pattern of inherited view is "
":samp:`{<base_view>}_inherit_{<current_module_name>}`. A module may only "
"extend a view once.  Suffix the orginal name with "
":samp:`_inherit_{<current_module_name>}` where *current_module_name* is the "
"technical name of the module extending the view."
msgstr "继承视图的命名模式是：SAMP：`{<base_view>} _继承_ {<current_module_name>}`。一个模块可能只扩展视图一次。后缀原单名：SAMP：`_inherit _ {<current_module_name>}`，其中* current_module_name *是扩展视图模块的技术名称。"

#: ../../reference/guidelines.rst:223 ../../reference/qweb.rst:319
msgid "Python"
msgstr "蟒蛇"

#: ../../reference/guidelines.rst:226
msgid "PEP8 options"
msgstr "PEP8选项"

#: ../../reference/guidelines.rst:228
msgid ""
"Using a linter can help show syntax and semantic warnings or errors. Odoo "
"source code tries to respect Python standard, but some of them can be "
"ignored."
msgstr "使用棉绒可以帮助显示语法和语义警告或错误。 Odoo源代码试图尊重Python标准，但其中一些可以忽略不计。"

#: ../../reference/guidelines.rst:231
msgid "E501: line too long"
msgstr "E501：线太长"

#: ../../reference/guidelines.rst:232
msgid "E301: expected 1 blank line, found 0"
msgstr "E301：预计1空行，发现0"

#: ../../reference/guidelines.rst:233
msgid "E302: expected 2 blank lines, found 1"
msgstr "E302：预计2空白行，发现1"

#: ../../reference/guidelines.rst:234
msgid "E126: continuation line over-indented for hanging indent"
msgstr "过缩进悬挂缩进续行：E126"

#: ../../reference/guidelines.rst:235
msgid ""
"E123: closing bracket does not match indentation of opening bracket's line"
msgstr "E123：右括号不匹配左括号的行缩进"

#: ../../reference/guidelines.rst:236
msgid "E127: continuation line over-indented for visual indent"
msgstr "过缩进视觉缩进续行：E127"

#: ../../reference/guidelines.rst:237
msgid "E128: continuation line under-indented for visual indent"
msgstr "下缩进的视觉缩进续行：E128"

#: ../../reference/guidelines.rst:238
msgid "E265: block comment should start with '# '"
msgstr "E265：块注释应该以'＃'"

#: ../../reference/guidelines.rst:241
msgid "Imports"
msgstr "进口"

#: ../../reference/guidelines.rst:242
msgid "The imports are ordered as"
msgstr "在进口定购"

#: ../../reference/guidelines.rst:244
msgid "External libraries (one per line sorted and split in python stdlib)"
msgstr "外部库（每行一个分类和分裂蟒蛇STDLIB）"

#: ../../reference/guidelines.rst:245
msgid "Imports of ``openerp``"
msgstr "的``openerp``进口"

#: ../../reference/guidelines.rst:246
msgid "Imports from Odoo modules (rarely, and only if necessary)"
msgstr "从Odoo模块（很少，只有在必要时）的进口"

#: ../../reference/guidelines.rst:248
msgid "Inside these 3 groups, the imported lines are alphabetically sorted."
msgstr "这里面3组，进口线按字母顺序排序。"

#: ../../reference/guidelines.rst:267
msgid "Idioms"
msgstr "成语"

#: ../../reference/guidelines.rst:269
msgid ""
"Prefer ``%`` over ``.format()``, prefer ``%(varname)`` instead of position "
"(This is better for translation)"
msgstr "而不是位置身高``％``在``.format（）``，宁可``％（varname的）``（这是翻译好）"

#: ../../reference/guidelines.rst:270
msgid "Try to avoid generators and decorators"
msgstr "尽量避免发电机和装饰"

#: ../../reference/guidelines.rst:271
msgid ""
"Always favor *Readability* over *conciseness* or using the language features"
" or idioms."
msgstr "总是青睐*可读性*在*简洁*或使用该语言的功能或成语。"

#: ../../reference/guidelines.rst:272
msgid ""
"Use list comprehension, dict comprehension, and basic manipulation using "
"``map``, ``filter``, ``sum``, ... They make the code easier to read."
msgstr "使用``map``，``filter``，``sum``使用列表理解，快译通的理解和基本操作，......他们使代码更易于阅读。"

#: ../../reference/guidelines.rst:273
msgid ""
"The same applies for recordset methods : use ``filtered``, ``mapped``, "
"``sorted``, ..."
msgstr "这同样适用于记录方法：使用``filtered``，``mapped``，``sorted``，..."

#: ../../reference/guidelines.rst:274
msgid "Each python file should have ``# -*- coding: utf-8 -*-`` as first line"
msgstr "每个Python文件应该有``＃ -  *  - 编码：UTF-8  -  *  - ``作为一线"

#: ../../reference/guidelines.rst:275
msgid ""
"Use the ``UserError`` defined in ``openerp.exceptions`` instead of "
"overriding ``Warning``, or find a more appropriate exception in "
"*exceptions.py*"
msgstr "在使用``定义的``UserError`` openerp.exceptions``，而不是覆盖``Warning``，或发现* exceptions.py更合适的异常*"

#: ../../reference/guidelines.rst:276
msgid ""
"Document your code (docstring on methods, simple comments for the tricky "
"part of the code)"
msgstr "记录下你的代码（文档字符串的方法，代码的棘手的部分简单的评论）"

#: ../../reference/guidelines.rst:277
msgid "Use meaningful variable/class/method names"
msgstr "使用有意义的变量/类/方法名"

#: ../../reference/guidelines.rst:282
msgid "Symbols"
msgstr "符号"

#: ../../reference/guidelines.rst:284
msgid ""
"Odoo Python Class : use camelcase for code in api v8, underscore lowercase "
"notation for old api."
msgstr "Odoo Python类：使用CamelCase在API v8的代码，强调对旧的API小写符号。"

#: ../../reference/guidelines.rst:297
msgid "Variable name :"
msgstr "变量名："

#: ../../reference/guidelines.rst:295
msgid "use camelcase for model variable"
msgstr "使用大小写混合的模型变量"

#: ../../reference/guidelines.rst:296
msgid "use underscore lowercase notation for common variable."
msgstr "用下划线为普通变量小写符号。"

#: ../../reference/guidelines.rst:297
msgid ""
"since new API works with record or recordset instead of id list, don't "
"suffix variable name with *_id* or *_ids* if they not contain id or list of "
"id."
msgstr "因为新的API，可与记录或记录，而不是ID列表，没有后缀的变量名* _id *或* _ids *如果他们不包含ID或ID的列表。"

#: ../../reference/guidelines.rst:305
msgid ""
"``One2Many`` and ``Many2Many`` fields should always have *_ids* as suffix "
"(example: sale_order_line_ids)"
msgstr "``One2Many``和``Many2Many``领域应该始终有* _ids *作为后缀（例如：sale_order_line_ids）"

#: ../../reference/guidelines.rst:306
msgid ""
"``Many2One`` fields should have *_id* as suffix (example : partner_id, "
"user_id, ...)"
msgstr "``Many2One``领域应该有* _id *作为后缀（例如：partner_id，USER_ID，...）"

#: ../../reference/guidelines.rst:313
msgid "Method conventions"
msgstr "法公约"

#: ../../reference/guidelines.rst:308
msgid "Compute Field : the compute method pattern is *_compute_<field_name>*"
msgstr "计算领域：计算方法模式是* _compute_ <FIELD_NAME> *"

#: ../../reference/guidelines.rst:309
msgid "Search method : the search method pattern is *_search_<field_name>*"
msgstr "搜索方法：搜索方法模式是* _search_ <FIELD_NAME> *"

#: ../../reference/guidelines.rst:310
msgid "Default method : the default method pattern is *_default_<field_name>*"
msgstr "默认的方法：默认的方法模式是* _default_ <FIELD_NAME> *"

#: ../../reference/guidelines.rst:311
msgid ""
"Onchange method : the onchange method pattern is *_onchange_<field_name>*"
msgstr "onchange的方法：中为onchange方法模式是* _onchange_ <FIELD_NAME> *"

#: ../../reference/guidelines.rst:312
msgid ""
"Constraint method : the constraint method pattern is "
"*_check_<constraint_name>*"
msgstr "约束方法：约束方法模式是* _check_ <constraint_name命令> *"

#: ../../reference/guidelines.rst:313
msgid ""
"Action method : an object action method is prefix with *action_*. Its "
"decorator is ``@api.multi``, but since it use only one record, add "
"``self.ensure_one()`` at the beginning of the method."
msgstr "操作方法：一个对象操作方法是前缀* action_ *。它的装饰是``@ api.multi``，但由于它仅使用一条记录，添加``self.ensure_one（）``在方法的开始。"

#: ../../reference/guidelines.rst:323
msgid "In a Model attribute order should be"
msgstr "模型中的属性顺序应该是"

#: ../../reference/guidelines.rst:316
msgid "Private attributes (``_name``, ``_description``, ``_inherit``, ...)"
msgstr "私有属性（``_name``，``_description``，``_inherit``，...）"

#: ../../reference/guidelines.rst:317
msgid "Default method and ``_default_get``"
msgstr "默认的方法和``_default_get``"

#: ../../reference/guidelines.rst:318
msgid "Field declarations"
msgstr "现场申报"

#: ../../reference/guidelines.rst:319
msgid "Compute and search methods in the same order as field declaration"
msgstr "计算和搜索方法，顺序相同域声明"

#: ../../reference/guidelines.rst:320
msgid ""
"Constrains methods (``@api.constrains``) and onchange methods "
"(``@api.onchange``)"
msgstr "约束方法（``@ api.constrains``）和onchange的方法（``@ api.onchange``）"

#: ../../reference/guidelines.rst:321
msgid "CRUD methods (ORM overrides)"
msgstr "CRUD方法（ORM覆盖）"

#: ../../reference/guidelines.rst:322
msgid "Action methods"
msgstr "操作方法"

#: ../../reference/guidelines.rst:323
msgid "And finally, other business methods."
msgstr "最后，其他的业务方法。"

#: ../../reference/guidelines.rst:375
msgid "Javascript and CSS"
msgstr "JavaScript和CSS"

#: ../../reference/guidelines.rst:376
msgid "**For javascript :**"
msgstr "**为Javascript：**"

#: ../../reference/guidelines.rst:378
msgid "``use strict;`` is recommended for all javascript files"
msgstr "``使用严格的;``建议所有的JavaScript文件"

#: ../../reference/guidelines.rst:379
msgid "Use a linter (jshint, ...)"
msgstr "使用棉绒（jshint，...）"

#: ../../reference/guidelines.rst:380
msgid "Never add minified Javascript Libraries"
msgstr "切勿将缩小的JavaScript库"

#: ../../reference/guidelines.rst:381
msgid "Use camelcase for class declaration"
msgstr "使用大小写混合的类声明"

#: ../../reference/guidelines.rst:383
msgid "**For CSS :**"
msgstr "**对于CSS：**"

#: ../../reference/guidelines.rst:385
msgid ""
"Prefix all your class with *o_<module_name>* where *module_name* is the "
"technical name of the module ('sale', 'im_chat', ...) or the main route "
"reserved by the module (for website module mainly, i.e. : 'o_forum' for "
"website_forum module). The only exception for this rule is the webclient : "
"it simply use *o_* prefix."
msgstr "前缀所有的类* O_ <模块> *，其中* *模块名是模块（'销售'，'im_chat'，...）或模块预留的主要途径（对网站的模块的主要的技术名称，即：“o_forum”为website_forum模块）。该规则唯一的例外是Web客户端：它只需使用* O_ *前缀。"

#: ../../reference/guidelines.rst:386
msgid "Avoid using id"
msgstr "避免使用ID"

#: ../../reference/guidelines.rst:387
msgid "Use bootstrap native class"
msgstr "使用自举机类"

#: ../../reference/guidelines.rst:388
msgid "Use underscore lowercase notation to name class"
msgstr "使用下划线小写符号来命名类"

#: ../../reference/guidelines.rst:391
msgid "Git"
msgstr "混帐"

#: ../../reference/guidelines.rst:394
msgid "Commit message"
msgstr "提交信息"

#: ../../reference/guidelines.rst:396
msgid "Prefix your commit with"
msgstr "前缀你的提交与"

#: ../../reference/guidelines.rst:398
msgid "**[IMP]** for improvements"
msgstr "** [IMP] **改善"

#: ../../reference/guidelines.rst:399
msgid "**[FIX]** for bug fixes"
msgstr "** [修复] **的bug修复"

#: ../../reference/guidelines.rst:400
msgid "**[REF]** for refactoring"
msgstr "** [参考] **的重构"

#: ../../reference/guidelines.rst:401
msgid "**[ADD]** for adding new resources"
msgstr "** [添加] **添加新资源"

#: ../../reference/guidelines.rst:402
msgid "**[REM]** for removing of resources"
msgstr "** [REM] **去除资源"

#: ../../reference/guidelines.rst:403
msgid "**[MERGE]** for merge commits (only for forward/back-port)"
msgstr "** [MERGE] **的合并提交（仅适用于前进/后退端口）"

#: ../../reference/guidelines.rst:404
msgid "**[CLA]** for signing the Odoo Individual Contributor License"
msgstr "** [CLA] **签署的Odoo独立贡献者许可"

#: ../../reference/guidelines.rst:406
msgid ""
"Then, in the message itself, specify the part of the code impacted by your "
"changes (module name, lib, transversal object, ...) and a description of the"
" changes."
msgstr "然后，消息本身，指定由您的更改（模块名称，lib下，横向的对象，...）和变化的描述影响的代码的一部分。"

#: ../../reference/guidelines.rst:408
msgid ""
"Always include a meaningful commit message: it should be self explanatory "
"(long enough) including the name of the module that has been changed and the"
" reason behind the change. Do not use single words like \"bugfix\" or "
"\"improvements\"."
msgstr "始终有一个有意义的提交信息：它应该是不言而喻的（足够长），其中包括已被更改模块的名称和变化背后的原因。不要使用单个词汇，如\“错误修正\”或\“进步\”。"

#: ../../reference/guidelines.rst:412
msgid ""
"Avoid commits which simultaneously impact multiple modules. Try to split "
"into different commits where impacted modules are different (It will be "
"helpful if we need to revert a module separately)."
msgstr "不要提交它同时影响多个模块。尝试拆分成不同的提交，其中受影响的模块是不同的（这将是有益的，如果我们需要分别恢复模块）。"

#: ../../reference/guidelines.rst:433
msgid ""
"Use the long description to explain the *why* not the *what*, the *what* can"
" be seen in the diff"
msgstr "使用长的描述来解释为什么* *不*什么*中，*什么*可以在差异中可见"

#: ../../reference/http.rst:5
msgid "Web Controllers"
msgstr "网络控制器"

#: ../../reference/http.rst:10
msgid "Routing"
msgstr "路由"

#: ../../../openerp/http.pydocstring of openerp.http.route:1
msgid ""
"Decorator marking the decorated method as being a handler for requests. The "
"method must be part of a subclass of ``Controller``."
msgstr "装饰标记的装饰方法，是一个处理程序的请求。该方法必须是``Controller``一个子类的一部分。"

#: ../../../openerp/http.pydocstring of openerp.http.route:4
msgid ""
"string or array. The route part that will determine which http requests will"
" match the decorated method. Can be a single string or an array of strings. "
"See werkzeug's routing documentation for the format of route expression ( "
"http://werkzeug.pocoo.org/docs/routing/ )."
msgstr "字符串或数组。这条路线的一部分，这将决定哪些HTTP请求将匹配的装饰方法。可以是一个字符串或字符串数​​组。路由表达式的格式（http://werkzeug.pocoo.org/docs/routing/）查看WERKZEUG的路由文档。"

#: ../../../openerp/http.pydocstring of openerp.http.route:9
msgid "The type of request, can be ``'http'`` or ``'json'``."
msgstr "请求的类型，可以是``'http'``或``'json'``。"

#: ../../../openerp/http.pydocstring of openerp.http.route:10
msgid ""
"The type of authentication method, can on of the following:  * ``user``: The"
" user must be authenticated and the current request   will perform using the"
" rights of the user. * ``admin``: The user may not be authenticated and the "
"current request   will perform using the admin user. * ``none``: The method "
"is always active, even if there is no   database. Mainly used by the "
"framework and authentication   modules. There request code will not have any"
" facilities to access   the database nor have any configuration indicating "
"the current   database nor the current user."
msgstr "认证方法的类型，可以对下列内容：*``user``：用户必须通过身份验证和当前请求将执行使用用户的权利。 *``admin``：用户可能不进行身份验证和当前请求将执行使用admin用户。 *``none``：该方法始终是活动的，即使没有数据库。主要用于由框架和验证模块。有请求代码将不会有任何的设施来访问数据库也没有指示当前数据库也不当前用户的任何构造。"

#: ../../../openerp/http.pydocstring of openerp.http.route:10
msgid "The type of authentication method, can on of the following:"
msgstr "认证方法的类型，可以在以下的："

#: ../../../openerp/http.pydocstring of openerp.http.route:12
msgid ""
"``user``: The user must be authenticated and the current request will "
"perform using the rights of the user."
msgstr "``user``：用户必须通过身份验证和当前请求将执行使用用户的权利。"

#: ../../../openerp/http.pydocstring of openerp.http.route:14
msgid ""
"``admin``: The user may not be authenticated and the current request will "
"perform using the admin user."
msgstr "``admin``：用户可能不进行身份验证和当前请求将执行使用admin用户。"

#: ../../../openerp/http.pydocstring of openerp.http.route:16
msgid ""
"``none``: The method is always active, even if there is no database. Mainly "
"used by the framework and authentication modules. There request code will "
"not have any facilities to access the database nor have any configuration "
"indicating the current database nor the current user."
msgstr "``none``：该方法始终是活动的，即使没有数据库。主要用于由框架和验证模块。有请求代码将不会有任何的设施来访问数据库也没有指示当前数据库也不当前用户的任何构造。"

#: ../../../openerp/http.pydocstring of openerp.http.route:21
msgid ""
"A sequence of http methods this route applies to. If not specified, all "
"methods are allowed."
msgstr "HTTP方法序列这条路线适用。如果未指定，所有的方法都是允许的。"

#: ../../../openerp/http.pydocstring of openerp.http.route:23
msgid "The Access-Control-Allow-Origin cors directive value."
msgstr "该访问控制 - 允许 - 产地CORS指令值。"

#: ../../reference/http.rst:17
msgid "Request"
msgstr "求"

#: ../../reference/http.rst:19
msgid ""
"The request object is automatically set on :data:`openerp.http.request` at "
"the start of the request"
msgstr "请求对象是自动设置的：数据：`openerp.http.request`的请求开始"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest:1
msgid ""
"Parent class for all Odoo Web request types, mostly deals with "
"initialization and setup of the request object (the dispatching itself has "
"to be handled by the subclasses)"
msgstr "父类的所有Odoo Web请求的类型，主要是涉及初始化和设置请求的对象（在调度本身必须由子类来处理）"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest:5
msgid "a wrapped werkzeug Request object"
msgstr "包裹WERKZEUG Request对象"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest:10
msgid ""
"the original :class:`werkzeug.wrappers.Request` object provided to the "
"request"
msgstr "原文：类：`werkzeug.wrappers.Request`对象提供给请求"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest:15
msgid ""
":class:`~collections.Mapping` of request parameters, not generally useful as"
" they're provided directly to the handler method as keyword arguments"
msgstr "产品类别：`〜请求参数collections.Mapping`，一般不会因为他们是直接提供给处理方法作为关键字参数有用"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.env:1
msgid ""
"The :class:`~openerp.api.Environment` bound to current request. Raises a "
":class:`RuntimeError` if the current requests is not bound to a database."
msgstr "该产品类别：`〜openerp.api.Environment`势必当前请求。提出了：类：`RuntimeError`如果当前请求没有绑定到数据库。"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.context:1
msgid ""
":class:`~collections.Mapping` of context values for the current request"
msgstr "产品类别：`〜上下文collections.Mapping`值当前请求"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.session:1
msgid ""
"a :class:`OpenERPSession` holding the HTTP session data for the current http"
" session"
msgstr "答：类：`OpenERPSession`持有HTTP会话数据为目前HTTP会话"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.cr:1
msgid ""
":class:`~openerp.sql_db.Cursor` initialized for the current method call."
msgstr "产品类别：`〜openerp.sql_db.Cursor`初始化当前方法调用。"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.cr:4
msgid ""
"Accessing the cursor when the current request uses the ``none`` "
"authentication will raise an exception."
msgstr "访问光标在当前请求使用``none``身份验证将引发异常。"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.debug:1
msgid "Indicates whether the current request is in \"debug\" mode"
msgstr "表示当前请求是否处于\“调试\”模式"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.session_id:1
msgid ""
"opaque identifier for the :class:`OpenERPSession` instance of the current "
"request"
msgstr "不透明的标识符：类：'当前请求的OpenERPSession`实例"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.session_id:6
msgid "Use the ``sid`` attribute on :attr:`.session`"
msgstr "使用的``sid``属性：ATTR：`.session`"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.registry:1
msgid ""
"The registry to the database linked to this request. Can be ``None`` if the "
"current request uses the ``none`` authentication."
msgstr "注册表数据库链接这一要求。可``如果None``当前请求使用``none``认证。"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.registry:6
msgid "use :attr:`.env`"
msgstr "用途：ATTR：`.env`"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.db:1
msgid ""
"The database linked to this request. Can be ``None`` if the current request "
"uses the ``none`` authentication."
msgstr "该数据库链接到该请求。可``如果None``当前请求使用``none``认证。"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.httpsession:1
msgid "HTTP session data"
msgstr "HTTP会话数据"

#: ../../../openerp/http.pydocstring of openerp.http.WebRequest.httpsession:5
msgid "Use :attr:`.session` instead."
msgstr "用途：ATTR：`.session`代替。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:1
msgid "Handler for the ``http`` request type."
msgstr "处理器的``http``请求类型。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:3
msgid ""
"matched routing parameters, query string parameters, form_ parameters and "
"files are passed to the handler method as keyword arguments."
msgstr "匹配的路由参数，查询字符串参数，form_参数和文件传递给处理方法作为关键字参数。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:6
msgid "In case of name conflict, routing parameters have priority."
msgstr "如遇名称冲突，路由参数有优先权。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:8
msgid "The handler method's result can be:"
msgstr "该处理方法的结果可能是："

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:10
msgid ""
"a falsy value, in which case the HTTP response will be an `HTTP 204`_ (No "
"Content)"
msgstr "一个falsy值，在这种情况下，HTTP响应将是一个`的HTTP 204`_（无内容）"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:12
msgid "a werkzeug Response object, which is returned as-is"
msgstr "一个WERKZEUG Response对象，它当做返回"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest:13
msgid ""
"a ``str`` or ``unicode``, will be wrapped in a Response object and "
"interpreted as HTML"
msgstr "一个``str``或``unicode``，将被包裹在一个Response对象，并解释为HTML"

#: ../../../openerp/http.pydocstring of
#: openerp.http.HttpRequest.make_response:1
msgid ""
"Helper for non-HTML responses, or HTML responses with custom response "
"headers or cookies."
msgstr "帮手非HTML的响应，或自定义的响应头或饼干HTML响应。"

#: ../../../openerp/http.pydocstring of
#: openerp.http.HttpRequest.make_response:4
msgid ""
"While handlers can just return the HTML markup of a page they want to send "
"as a string if non-HTML data is returned they need to create a complete "
"response object, or the returned data will not be correctly interpreted by "
"the clients."
msgstr "虽然处理器可以只返回自己想要发送一个字符串，如果返回非HTML数据，他们需要建立一个完整的响应对象，或返回的数据不会被用户正确解释页面的HTML标记。"

#: ../../../openerp/http.pydocstring of
#: openerp.http.HttpRequest.make_response:9
msgid "response body"
msgstr "响应体"

#: ../../../openerp/http.pydocstring of
#: openerp.http.HttpRequest.make_response:10
msgid "HTTP headers to set on the response"
msgstr "HTTP标头的响应设置"

#: ../../../openerp/http.pydocstring of
#: openerp.http.HttpRequest.make_response:12
msgid "cookies to set on the client"
msgstr "饼干在客户端上设置"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.not_found:1
msgid ""
"Shortcut for a `HTTP 404 "
"<http://tools.ietf.org/html/rfc7231#section-6.5.4>`_ (Not Found) response"
msgstr "快捷键的`HTTP 404 <http://tool​​s.ietf.org/html/rfc7231#section-6.5.4>`_（未找到）响应"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:1
msgid "Lazy render of a QWeb template."
msgstr "懒呈现QWeb模板。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:3
msgid ""
"The actual rendering of the given template will occur at then end of the "
"dispatching. Meanwhile, the template and/or qcontext can be altered or even "
"replaced by a static response."
msgstr "给定模板的实际渲染将发生在那么调度的结束。同时，模板和/或qcontext可以改变或甚至通过一个静态响应取代。"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:7
#: ../../../openerp/http.pydocstring of openerp.http.Response:7
msgid "template to render"
msgstr "模板呈现"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:8
#: ../../../openerp/http.pydocstring of openerp.http.Response:8
msgid "Rendering context to use"
msgstr "渲染上下文中使用"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:9
msgid ""
"whether the template rendering should be deferred until the last possible "
"moment"
msgstr "模板渲染是否应推迟到最后一刻"

#: ../../../openerp/http.pydocstring of openerp.http.HttpRequest.render:11
msgid "forwarded to werkzeug's Response object"
msgstr "转发到WERKZEUG的Response对象"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:1
msgid ""
"Request handler for `JSON-RPC 2 <http://www.jsonrpc.org/specification>`_ "
"over HTTP"
msgstr "请求处理程序`JSON-RPC 2 <http://www.jsonrpc.org/specification>`_通过HTTP"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:4
msgid "``method`` is ignored"
msgstr "``method``被忽略"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:5
msgid ""
"``params`` must be a JSON object (not an array) and is passed as keyword "
"arguments to the handler method"
msgstr "``params``必须是一个JSON对象（不是数组），并通过为关键字参数的处理方法"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:7
msgid ""
"the handler method's result is returned as JSON-RPC ``result`` and wrapped "
"in the `JSON-RPC Response "
"<http://www.jsonrpc.org/specification#response_object>`_"
msgstr "该处理方法的返回结果为JSON-RPC``result``包裹在`JSON-RPC响应<http://www.jsonrpc.org/specification#response_object>`_"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:11
msgid "Sucessful request::"
msgstr "SUCESSFUL要求::"

#: ../../../openerp/http.pydocstring of openerp.http.JsonRequest:23
msgid "Request producing a error::"
msgstr "请求产生的错误::"

#: ../../reference/http.rst:31
msgid "Response"
msgstr "响应"

#: ../../../openerp/http.pydocstring of openerp.http.Response:1
msgid "Response object passed through controller route chain."
msgstr "Response对象通过控制器路由链。"

#: ../../../openerp/http.pydocstring of openerp.http.Response:3
msgid ""
"In addition to the :class:`werkzeug.wrappers.Response` parameters, this "
"class's constructor can take the following additional parameters for QWeb "
"Lazy Rendering."
msgstr "除了：类：`werkzeug.wrappers.Response`参数，这个类的构造函数可以采取QWeb延迟渲染以下附加参数。"

#: ../../../openerp/http.pydocstring of openerp.http.Response:9
msgid ""
"User id to use for the ir.ui.view render call, ``None`` to use the request's"
" user (the default)"
msgstr "用户ID用于ir.ui.view渲染调用，``None``使用要求的用户（默认）"

#: ../../../openerp/http.pydocstring of openerp.http.Response:12
msgid ""
"these attributes are available as parameters on the Response object and can "
"be altered at any time before rendering"
msgstr "这些属性可作为响应对象参数，并且可以在任何时间呈现之前被改变"

#: ../../../openerp/http.pydocstring of openerp.http.Response:15
msgid ""
"Also exposes all the attributes and methods of "
":class:`werkzeug.wrappers.Response`."
msgstr "也暴露了所有的属性和方法：类：`werkzeug.wrappers.Response`。"

#: ../../../openerp/http.pydocstring of openerp.http.Response.render:1
msgid "Renders the Response's template, returns the result"
msgstr "呈现响应的模板，返回结果"

#: ../../../openerp/http.pydocstring of openerp.http.Response.flatten:1
msgid ""
"Forces the rendering of the response's template, sets the result as response"
" body and unsets :attr:`.template`"
msgstr "强制响应的模板的渲染，将结果作为响应体和取消设置：ATTR：`.template`"

#: ../../reference/http.rst:44
msgid "Controllers"
msgstr "控制器"

#: ../../reference/http.rst:46
msgid ""
"Controllers need to provide extensibility, much like "
":class:`~openerp.models.Model`, but can't use the same mechanism as the pre-"
"requisites (a database with loaded modules) may not be available yet (e.g. "
"no database created, or no database selected)."
msgstr "控制器需要提供可扩展性，很像：类：`〜openerp.models.Model`，但不能使用相同的机制为先决条件（与加载的模块数据库）可能无法使用，但（如没有数据库创建或者没有数据库选择）。"

#: ../../reference/http.rst:51
msgid ""
"Controllers thus provide their own extension mechanism, separate from that "
"of models:"
msgstr "控制器从而提供自己的扩展机制，独立于模型："

#: ../../reference/http.rst:54
msgid ""
"Controllers are created by :ref:`inheriting <python:tut-inheritance>` from"
msgstr "来自：<啧啧继承蟒蛇>`控制器也可以创建：REF`继承"

#: ../../reference/http.rst:58
msgid "and defining methods decorated with :func:`~openerp.http.route`::"
msgstr "和定义方法装饰有：函数：`〜openerp.http.route` ::"

#: ../../reference/http.rst:65
msgid ""
"To *override* a controller, :ref:`inherit <python:tut-inheritance>` from its"
" class and override relevant methods, re-exposing them if necessary::"
msgstr "要*覆盖*控制器，：参考：`继承<巨蟒：啧啧继承>从其类'，并覆盖相关的方法，再次暴露他们，如果有必要::"

#: ../../reference/http.rst:74
msgid ""
"decorating with :func:`~openerp.http.route` is necessary to keep the method "
"(and route) visible: if the method is redefined without decorating, it will "
"be \"unpublished\""
msgstr "装潢用：函数：`〜openerp.http.route`是需要保持方法（和航线）可见：如果该方法被重新定义，而不装潢，将\“未发表\”"

#: ../../reference/http.rst:77
msgid ""
"the decorators of all methods are combined, if the overriding method's "
"decorator has no argument all previous ones will be kept, any provided "
"argument will override previously defined ones e.g.::"
msgstr "所有方法的装饰相结合，如果上位法的装饰没有参数所有以前的将被保留，任何提供的参数将替代先前定义的人，例如::"

#: ../../reference/http.rst:86
msgid ""
"will change ``/some_url`` from public authentication to user (requiring a "
"log-in)"
msgstr "将来自于公共验证更改``/ some_url``用户（需要登录）"

#: ../../reference/javascript.rst:9 ../../reference/qweb.rst:418
msgid "Javascript"
msgstr "使用Javascript"

#: ../../reference/javascript.rst:12
msgid "Widgets"
msgstr "小工具"

#: ../../reference/javascript.rst:16
msgid ""
"Exported in ``web.Widget``, the base class for all visual components. It "
"corresponds to an MVC view, and provides a number of service to simplify "
"handling of a section of a page:"
msgstr "在出口``web.Widget``，所有可视组件的基类。它对应于MVC视图，并提供了许多服务来简化一个网页的部分的处理："

#: ../../reference/javascript.rst:20
msgid "Handles parent/child relationships between widgets"
msgstr "手柄部件之间的父/子关系"

#: ../../reference/javascript.rst:21
msgid ""
"Provides extensive lifecycle management with safety features (e.g. "
"automatically destroying children widgets during the destruction of a "
"parent)"
msgstr "提供广泛的生命周期管理与安全功能（如自动摧毁孩子父母的破坏过程部件）"

#: ../../reference/javascript.rst:24
msgid "Automatic rendering with :ref:`qweb <reference/qweb>`"
msgstr "自动渲染有：参考：`qweb <参考/ qweb>`"

#: ../../reference/javascript.rst:25
msgid "Backbone-compatible shortcuts"
msgstr "骨干兼容的快捷键"

#: ../../reference/javascript.rst:28
msgid "DOM Root"
msgstr "DOM根"

#: ../../reference/javascript.rst:30
msgid ""
"A :class:`~Widget` is responsible for a section of the page materialized by "
"the DOM root of the widget."
msgstr "答：类：`〜Widget`负责物化小部件的DOM根页面的一部分。"

#: ../../reference/javascript.rst:33
msgid "A widget's DOM root is available via two attributes:"
msgstr "小部件的DOM根通过两个属性可用："

#: ../../reference/javascript.rst:37
msgid "raw DOM element set as root to the widget"
msgstr "设置为根小部件的原始DOM元素"

#: ../../reference/javascript.rst:41
msgid "jQuery wrapper around :attr:`~Widget.el`"
msgstr "jQuery的包装器：ATTR：`〜Widget.el`"

#: ../../reference/javascript.rst:43
msgid "There are two main ways to define and generate this DOM root:"
msgstr "有定义和生成此根DOM主要有两种方法："

#: ../../reference/javascript.rst:47
msgid ""
"Should be set to the name of a :ref:`QWeb template <reference/qweb>`. If "
"set, the template will be rendered after the widget has been initialized but"
" before it has been started. The root element generated by the template will"
" be set as the DOM root of the widget."
msgstr "应设置为一个名字：REF：`QWeb模板<参考/ qweb>`。如果设置，该模板将被渲染的插件已初始化之后，但它已被启动之前。由模板产生的根元素将被设置为小部件的DOM的根。"

#: ../../reference/javascript.rst:54
msgid ""
"Used if the widget has no template defined. Defaults to ``div``, will be "
"used as the tag name to create the DOM element to set as the widget's DOM "
"root. It is possible to further customize this generated DOM root with the "
"following attributes:"
msgstr "如果使用的部件没有定义的模板。默认为``div``，将被用来作为变量名称来创建DOM元素设置为小部件的DOM根。它可以进一步自主生成的DOM根具有以下属性："

#: ../../reference/javascript.rst:61
msgid "Used to generate an ``id`` attribute on the generated DOM root."
msgstr "用于生成所产生的DOM根的``id``属性。"

#: ../../reference/javascript.rst:66
msgid "Used to generate a ``class`` attribute on the generated DOM root."
msgstr "用于生成生成的DOM根``class``属性。"

#: ../../reference/javascript.rst:70
msgid ""
"Mapping (object literal) of attribute names to attribute values. Each of "
"these k:v pairs will be set as a DOM attribute on the generated DOM root."
msgstr "属性名称映射（对象文本），以属性值。每个这k个权：v对将被设置为对所生成的DOM根一个DOM属性。"

#: ../../reference/javascript.rst:74
msgid "None of these is used in case a template is specified on the widget."
msgstr "所有这些情况下使用一个模板上的插件指定。"

#: ../../reference/javascript.rst:76
msgid "The DOM root can also be defined programmatically by overridding"
msgstr "DOM的根也可以通过overridding编程定义"

#: ../../reference/javascript.rst:80
msgid ""
"Renders the widget's DOM root and sets it. The default implementation will "
"render a set template or generate an element as described above, and will "
"call :func:`~Widget.setElement` on the result."
msgstr "呈现小部件的DOM根，并设置它。默认的实现将呈现一组模板或如上所述生成的元素，并会拨打：FUNC：`〜Widget.setElement`的结果。"

#: ../../reference/javascript.rst:85
msgid ""
"Any override to :func:`~Widget.renderElement` which does not call its "
"``_super`` **must** call :func:`~Widget.setElement` with whatever it "
"generated or the widget's behavior is undefined."
msgstr "任何覆盖到：FUNC：`〜Widget.renderElement`不调用它的``_super`` **必须**电话：FUNC：有什么它产生或控件的行为是不确定的`〜Widget.setElement`。"

#: ../../reference/javascript.rst:92
msgid ""
"The default :func:`~Widget.renderElement` can be called repeatedly, it will "
"*replace* the previous DOM root (using ``replaceWith``). However, this "
"requires that the widget correctly sets and unsets its events (and children "
"widgets). Generally, :func:`~Widget.renderElement` should not be called "
"repeatedly unless the widget advertizes this feature."
msgstr "默认：FUNC：`〜Widget.renderElement`可以反复调用，它将取代* *先前的DOM根（使用``replaceWith``）。然而，这要求微件正确设置和取消设置其事件（孩子和窗口小部件）。通常情况下，：FUNC：`〜Widget.renderElement`不应该被重复调用，除非小部件advertizes此功能。"

#: ../../reference/javascript.rst:100
msgid "Using a widget"
msgstr "使用小工具"

#: ../../reference/javascript.rst:102
msgid "A widget's lifecycle has 3 main phases:"
msgstr "小部件的生命周期有3个主要阶段："

#: ../../reference/javascript.rst:104
msgid "creation and initialization of the widget instance"
msgstr "创建和小部件的实例的初始化"

#: ../../reference/javascript.rst:108
msgid ""
"initialization method of widgets, synchronous, can be overridden to take "
"more parameters from the widget's creator/parent"
msgstr "窗口小部件，同步的初始化方法，可以覆盖从窗口小部件的创建者/家长需要更多的参数"

#: ../../reference/javascript.rst:111
msgid ""
"the new widget's parent, used to handle automatic destruction and event "
"propagation. Can be ``null`` for the widget to have no parent."
msgstr "新的小部件的父，用来处理自动销毁和事件传播。可``null``以供小窗口没有父。"

#: ../../reference/javascript.rst:116
msgid "DOM injection and startup, this is done by calling one of:"
msgstr "DOM注入和启动，这样做是通过调用之一："

#: ../../reference/javascript.rst:120
msgid ""
"Renders the widget and inserts it as the last child of the target, uses "
"`.appendTo()`_"
msgstr "呈现小部件，并将其插入作为目标的最后一个孩子，使用`.appendTo（）`_"

#: ../../reference/javascript.rst:125
msgid ""
"Renders the widget and inserts it as the first child of the target, uses "
"`.prependTo()`_"
msgstr "呈现小部件，并将其插入为目标的第一个孩子，使用`.prependTo（）`_"

#: ../../reference/javascript.rst:130
msgid ""
"Renders the widget and inserts it as the preceding sibling of the target, "
"uses `.insertAfter()`_"
msgstr "呈现小部件，并将其插入作为目标的前面的兄弟，使用`.insertAfter（）`_"

#: ../../reference/javascript.rst:135
msgid ""
"Renders the widget and inserts it as the following sibling of the target, "
"uses `.insertBefore()`_"
msgstr "呈现小部件，并将其插入作为目标的后续兄弟，使用`.insertBefore（）`_"

#: ../../reference/javascript.rst:138
msgid ""
"All of these methods accept whatever the corresponding jQuery method accepts"
" (CSS selectors, DOM nodes or jQuery objects). They all return a deferred_ "
"and are charged with three tasks:"
msgstr "所有这些方法都照单全收相应的jQuery方法接受（CSS选择器，DOM节点或jQuery的对象）。他们都返回deferred_，并被控犯有三项任务："

#: ../../reference/javascript.rst:142
msgid "rendering the widget's root element via :func:`~Widget.renderElement`"
msgstr "FUNC：通过渲染窗口小部件的根元素`〜Widget.renderElement`"

#: ../../reference/javascript.rst:144
msgid ""
"inserting the widget's root element in the DOM using whichever jQuery method"
" they match"
msgstr "插入使用任何它们匹配的jQuery方法在DOM窗口小部件的根元素"

#: ../../reference/javascript.rst:146
msgid "starting the widget, and returning the result of starting it"
msgstr "开始小部件，并返回启动它的结果"

#: ../../reference/javascript.rst:150
msgid ""
"asynchronous startup of the widget once it's been injected in the DOM, "
"generally used to perform asynchronous RPC calls to fetch whatever remote "
"data is necessary for the widget to do its work."
msgstr "widget的异步启动，一旦它在DOM被注入，通常用于执行异步RPC调用获取任何远程数据所必需的部件，以完成其工作。"

#: ../../reference/javascript.rst:154
msgid "Must return a deferred_ to indicate when its work is done."
msgstr "必须返回一个deferred_以指示其工作已经完成。"

#: ../../reference/javascript.rst:156
msgid ""
"A widget is *not guaranteed* to work correctly until its "
":func:`~Widget.start` method has finished executing. The widget's "
"parent/creator must wait for a widget to be fully started before interacting"
" with it"
msgstr "小部件是*不*保证正常工作，直到其：FUNC：`〜Widget.start`方法执行结束。窗口小部件的父/创建者必须等待一个小部件与它交互之前全面打响"

#: ../../reference/javascript.rst:161 ../../reference/javascript.rst:202
msgid "deferred_ object"
msgstr "deferred_对象"

#: ../../reference/javascript.rst:163
msgid "widget destruction and cleanup"
msgstr "窗口小部件的破坏和清理"

#: ../../reference/javascript.rst:167
msgid ""
"destroys the widget's children, unbinds its events and removes its root from"
" the DOM. Automatically called when the widget's parent is destroyed, must "
"be called explicitly if the widget has no parents or if it is removed but "
"its parent remains."
msgstr "破坏了widget的儿童，解除绑定的事件，并从DOM删除其根。自动调用时，小部件的父被销毁，必须显式调用，如果该部件有没有父母，或者如果它被删除，但其父仍然存在。"

#: ../../reference/javascript.rst:172
msgid "A widget being destroyed is automatically unlinked from its parent."
msgstr "小部件被破坏是从它的父自动解除链接。"

#: ../../reference/javascript.rst:174
msgid "Related to widget destruction is an important utility method:"
msgstr "窗口小部件破坏相关的一个重要工具的方法："

#: ../../reference/javascript.rst:178
msgid ""
"A significant issue with RPC and destruction is that an RPC call may take a "
"long time to execute and return while a widget is being destroyed or after "
"it has been destroyed, trying to execute its operations on a widget in a "
"broken/invalid state."
msgstr "与RPC和销毁显著的问题是，一个RPC调用可能需要很长的时间来执行，而小部件被销毁，或者被摧毁后，试图在一个破碎/无效状态的一个小部件执行其操作返回。"

#: ../../reference/javascript.rst:183
msgid "This is a frequent source of errors or strange behaviors."
msgstr "这是错误或怪异的行为的一个常见来源。"

#: ../../reference/javascript.rst:185
msgid ""
":func:`~Widget.alive` can be used to wrap an RPC call, ensuring that "
"whatever operations should be executed when the call ends are only executed "
"if the widget is still alive::"
msgstr "：FUNC：`〜Widget.alive`可以用来包装一个RPC调用，确保一切行动应被执行时，通话结束后才会执行，如果小部件还活着::"

#: ../../reference/javascript.rst:197
msgid "a deferred_ object to wrap"
msgstr "包装一个deferred_对象"

#: ../../reference/javascript.rst:198
msgid ""
"by default, if the RPC call returns after the widget has been destroyed the "
"returned deferred_ is left in limbo (neither resolved nor rejected). If "
"``reject`` is set to ``true``, the deferred_ will be rejected instead."
msgstr "默认情况下，如果小部件后，RPC调用返回被摧毁返回deferred_留在无人过问（没有解决，也没有拒绝）。如果``reject``设置为``True``，那么该deferred_将被拒绝代替。"

#: ../../reference/javascript.rst:206
msgid ""
"``true`` if the widget is being or has been destroyed, ``false`` otherwise"
msgstr "值为``True``如果窗口小部件正在或已经被破坏了，``false``否则"

#: ../../reference/javascript.rst:210
msgid "Accessing DOM content"
msgstr "访问DOM内容"

#: ../../reference/javascript.rst:213
msgid ""
"Because a widget is only responsible for the content below its DOM root, "
"there"
msgstr "因为一个小部件只负责低于其DOM的根的内容，有"

#: ../../reference/javascript.rst:213
msgid "is a shortcut for selecting sub-sections of a widget's DOM:"
msgstr "是选择一个小部件的DOM子区的快捷方式："

#: ../../reference/javascript.rst:217
msgid ""
"Applies the CSS selector specified as parameter to the widget's DOM root::"
msgstr "适用于指定为参数widget的DOM根的CSS选择器::"

#: ../../reference/javascript.rst:222
msgid "is functionally identical to::"
msgstr "在功能上等同::"

#: ../../reference/javascript.rst:226
msgid "CSS selector"
msgstr "CSS选择器"

#: ../../reference/javascript.rst:227
msgid "jQuery object"
msgstr "jQuery对象"

#: ../../reference/javascript.rst:229
msgid "this helper method is similar to ``Backbone.View.$``"
msgstr "这个辅助方法类似于``Backbone.View。$``"

#: ../../reference/javascript.rst:232
msgid "Resetting the DOM root"
msgstr "重置DOM根"

#: ../../reference/javascript.rst:236
msgid ""
"Re-sets the widget's DOM root to the provided element, also handles re-"
"setting the various aliases of the DOM root as well as unsetting and re-"
"setting delegated events."
msgstr "重新设置窗口小部件的DOM根提供的元素，也处理重新设定的DOM根的各种别名以及解封，重新设定授权事件。"

#: ../../reference/javascript.rst:240
msgid "a DOM element or jQuery object to set as the widget's DOM root"
msgstr "DOM元素或jQuery对象设置为小部件的DOM根"

#: ../../reference/javascript.rst:243
msgid "should be mostly compatible with `Backbone's setElement`_"
msgstr "应与`骨干setElement`_基本上兼容"

#: ../../reference/javascript.rst:247
msgid "DOM events handling"
msgstr "DOM事件处理"

#: ../../reference/javascript.rst:249
msgid ""
"A widget will generally need to respond to user action within its section of"
" the page. This entails binding events to DOM elements."
msgstr "甲插件通常需要以内的页面的其部分响应用户行动。这需要结合事件的DOM元素。"

#: ../../reference/javascript.rst:252
msgid "To this end, :class:`~Widget` provides a shortcut:"
msgstr "为此，：类：`〜Widget`提供了一条捷径："

#: ../../reference/javascript.rst:256
msgid ""
"Events are a mapping of an event selector (an event name and an optional CSS"
" selector separated by a space) to a callback. The callback can be the name "
"of a widget's method or a function object. In either case, the ``this`` will"
" be set to the widget::"
msgstr "事件是一个事件选择器（事件名称和一个可选的CSS选择器由一个空格隔开）回调的映射。回调可能是一个小部件的方法的名称或函数对象。在两种情况下，``this``将被设定为小部件::"

#: ../../reference/javascript.rst:268
msgid ""
"The selector is used for jQuery's `event delegation`_, the callback will "
"only be triggered for descendants of the DOM root matching the selector\\ "
"[#eventsdelegation]_. If the selector is left out (only an event name is "
"specified), the event will be set directly on the widget's DOM root."
msgstr "用于jQuery的'事件delegation`_的选择，回调只会触发的DOM根的后代选择器匹配的\\ [#eventsdelegation] _。如果选择留出（仅事件名称指定），该事件将直接在小部件的DOM根设置。"

#: ../../reference/javascript.rst:276
msgid ""
"This method is in charge of binding :attr:`~Widget.events` to the DOM. It is"
" automatically called after setting the widget's DOM root."
msgstr "这种方法是负责绑定：ATTR：`〜Widget.events`到DOM。它是设置widget的DOM根后自动调用。"

#: ../../reference/javascript.rst:279
msgid ""
"It can be overridden to set up more complex events than the "
":attr:`~Widget.events` map allows, but the parent should always be called "
"(or :attr:`~Widget.events` won't be handled correctly)."
msgstr "它可以覆盖设置比更复杂的事件：ATTR：`〜Widget.events`映射允许的，但家长应始终调用（或：ATTR：`〜Widget.events`不会被正确处理）。"

#: ../../reference/javascript.rst:285
msgid ""
"This method is in charge of unbinding :attr:`~Widget.events` from the DOM "
"root when the widget is destroyed or the DOM root is reset, in order to "
"avoid leaving \"phantom\" events."
msgstr "这种方法是负责解除绑定：ATTR：`〜Widget.events`从DOM根当小部件被销毁或DOM根复位，以免留下\“幻影\”事件。"

#: ../../reference/javascript.rst:289
msgid ""
"It should be overridden to un-set any event set in an override of "
":func:`~Widget.delegateEvents`."
msgstr "应该覆盖到未设置的覆盖设置的任何事件：FUNC：`〜Widget.delegateEvents`。"

#: ../../reference/javascript.rst:292
msgid ""
"this behavior should be compatible with `Backbone's delegateEvents`_, apart "
"from not accepting any argument."
msgstr "这种行为应该与'骨干delegateEvents`_兼容，除了不接受任何参数。"

#: ../../reference/javascript.rst:296
msgid "Subclassing Widget"
msgstr "子类化的widget"

#: ../../reference/javascript.rst:298
msgid ""
":class:`~Widget` is subclassed in the standard manner (via the "
":func:`~Class.extend` method), and provides a number of abstract properties "
"and concrete methods (which you may or may not want to override). Creating a"
" subclass looks like this::"
msgstr "产品类别：`〜Widget`的子类以标准方式（通过：FUNC：`〜Class.extend`方法），并提供了一​​些抽象属性和具体方法（您可能会或可能不希望重写）了。创建一个子类看起来像这样::"

#: ../../reference/javascript.rst:329
msgid "The new class can then be used in the following manner::"
msgstr "新的类然后可以以下面的方式被使用::"

#: ../../reference/javascript.rst:336
msgid ""
"After these two lines have executed (and any promise returned by "
":func:`~Widget.appendTo` has been resolved if needed), the widget is ready "
"to be used."
msgstr "经过这两条线已经执行（和返回的任何承诺：FUNC：`〜Widget.appendTo`已如果需要解决），小部件就可以使用了。"

#: ../../reference/javascript.rst:340
msgid ""
"the insertion methods will start the widget themselves, and will return the "
"result of :func:`~Widget.start()`."
msgstr "插入方法将开始小部件本身，并将返回的结果：FUNC：`〜Widget.start（）`。"

#: ../../reference/javascript.rst:343
msgid ""
"If for some reason you do not want to call these methods, you will have to "
"first call :func:`~Widget.render()` on the widget, then insert it into your "
"DOM and start it."
msgstr "如果由于某种原因，你不想调用这些方法，你将不得不第一次调用：FUNC：`〜Widget.render（）`的小部件，然后将其插入到DOM并启动它。"

#: ../../reference/javascript.rst:347
msgid ""
"If the widget is not needed anymore (because it's transient), simply "
"terminate it::"
msgstr "如果小部件不再需要（因为它是短暂的），只是终止::"

#: ../../reference/javascript.rst:352
msgid ""
"will unbind all DOM events, remove the widget's content from the DOM and "
"destroy all widget data."
msgstr "将解除所有的DOM事件，从DOM中删除widget的内容并销毁所有部件的数据。"

#: ../../reference/javascript.rst:356
msgid "Development Guidelines"
msgstr "开发指南"

#: ../../reference/javascript.rst:358
msgid ""
"Identifiers (``id`` attribute) should be avoided. In generic applications "
"and modules, ``id`` limits the re-usability of components and tends to make "
"code more brittle. Most of the time, they can be replaced with nothing, "
"classes or keeping a reference to a DOM node or jQuery element."
msgstr "（``id``属性）应避免标识符。在一般的应用程序和模块，``id``限制了可重用性组件，并容易使代码更脆。大多数时候，它们可以被替换为空，类或保持参考DOM节点或jQuery的元素。"

#: ../../reference/javascript.rst:363
msgid ""
"If an ``id`` is absolutely necessary (because a third-party library requires"
" one), the id should be partially generated using ``_.uniqueId()`` e.g.::"
msgstr "如果``id``是绝对必要的（由于第三方库需要一个），ID应该是部分使用``_.uniqueId（）``例如::生成"

#: ../../reference/javascript.rst:367
msgid ""
"Avoid predictable/common CSS class names. Class names such as \"content\" or"
" \"navigation\" might match the desired meaning/semantics, but it is likely "
"an other developer will have the same need, creating a naming conflict and "
"unintended behavior. Generic class names should be prefixed with e.g. the "
"name of the component they belong to (creating \"informal\" namespaces, much"
" as in C or Objective-C)."
msgstr "避免可预见/常见CSS类名。类的名称，如\“内容\”或\“导航\”可能匹配所需的意义/语义，但它可能是一个其他的开发者也会有同样的需要，创造一个命名冲突和意外情况。通用类名称的前缀应该与他们属于（创建\“非正式\”的命名空间，就像在C或Objective-C的）的组件，例如名称。"

#: ../../reference/javascript.rst:373
msgid ""
"Global selectors should be avoided. Because a component may be used several "
"times in a single page (an example in Odoo is dashboards), queries should be"
" restricted to a given component's scope. Unfiltered selections such as "
"``$(selector)`` or ``document.querySelectorAll(selector)`` will generally "
"lead to unintended or incorrect behavior.  Odoo Web's :class:`~Widget` has "
"an attribute providing its DOM root (:attr:`~Widget.$el`), and a shortcut to"
" select nodes directly (:func:`~Widget.$`)."
msgstr "应避免全球选择器。因为一个部件可以在一个单一的页（在Odoo一个例子是仪表板）中使用几次，询问应限制在一个给定的组件的范围。未经过滤的选项比如``$（选择）``或``document.querySelectorAll（选择）``通常会导致意外或不正确的行为。 Odoo网站的产品类别：`〜Widget`有一个属性提供了DOM根（：ATTR：`〜小工具$ el`），以及一个快捷方式直接选择节点（：FUNC：`〜小工具$`）。"

#: ../../reference/javascript.rst:381
msgid ""
"More generally, never assume your components own or controls anything beyond"
" its own personal :attr:`~Widget.$el`"
msgstr "更一般地，永远不要假设你的组件拥有或控制超出了自己的个人事情：ATTR：`〜小工具$ el`。"

#: ../../reference/javascript.rst:383
msgid "html templating/rendering should use QWeb unless absolutely trivial."
msgstr "HTML模板/渲染应该使用QWeb，除非绝对微不足道。"

#: ../../reference/javascript.rst:384
msgid ""
"All interactive components (components displaying information to the screen "
"or intercepting DOM events) must inherit from :class:`~Widget` and correctly"
" implement and use its API and life cycle."
msgstr "所有交互式组件（组件的信息显示在屏幕或拦截DOM事件）都必须继承：类：`〜Widget`，正确实施和使用其API和生命周期。"

#: ../../reference/javascript.rst:412 ../../reference/javascript.rst:1142
msgid "RPC"
msgstr "RPC"

#: ../../reference/javascript.rst:414
msgid ""
"To display and interact with data, calls to the Odoo server are necessary. "
"This is performed using :abbr:`RPC <Remote Procedure Call>`."
msgstr "要显示与数据进行交互，则调用Odoo服务器是必要的。这是使用执行：简称：`RPC <远程过程调用>`。"

#: ../../reference/javascript.rst:417
msgid ""
"Odoo Web provides two primary APIs to handle this: a low-level JSON-RPC "
"based API communicating with the Python section of Odoo Web (and of your "
"module, if you have a Python part) and a high-level API above that allowing "
"your code to talk directly to high-level Odoo models."
msgstr "Odoo网站提供了两个主要的API来处理这个问题：用Odoo网站的Python的第一个低级别的JSON-RPC的API通信（和你的模块，如果你有一个Python部分）及以上的高层次的API，允许你代码直接与高层Odoo车型。"

#: ../../reference/javascript.rst:422
msgid ""
"All networking APIs are :ref:`asynchronous <reference/async>`. As a result, "
"all of them will return Deferred_ objects (whether they resolve those with "
"values or not). Understanding how those work before before moving on is "
"probably necessary."
msgstr "所有的网络API有：参考：`异步<参考/异步>`。其结果是，所有的人都将返回Deferred_对象（无论它们解决那些值或者不是）。了解如何在继续之前以前的那些工作，可能是必要的。"

#: ../../reference/javascript.rst:428
msgid "High-level API: calling into Odoo models"
msgstr "高层API：调用到Odoo车型"

#: ../../reference/javascript.rst:430
msgid ""
"Access to Odoo object methods (made available through XML-RPC from the "
"server) is done via :class:`Model` (exported in ``web.Model``). It maps onto"
" the Odoo server objects via two primary methods, :func:`~Model.call` and "
":func:`~Model.query`."
msgstr "类：`Model`（在``web.Model``出口）进入Odoo对象的方法（通过XML-RPC从服务器上可用）通过完成的。它映射到Odoo服务对象主要通过两种方法：FUNC：`〜Model.call`和：FUNC：`〜Model.query`。"

#: ../../reference/javascript.rst:435
msgid ""
":func:`~Model.call` is a direct mapping to the corresponding method of the "
"Odoo server object. Its usage is similar to that of the Odoo Model API, with"
" three differences:"
msgstr "：FUNC：`〜Model.call`是直接映射到Odoo服务器对象的相应方法。其用法是类似于Odoo模型的API，有三个不同之处："

#: ../../reference/javascript.rst:439
msgid ""
"The interface is :ref:`asynchronous <reference/async>`, so instead of "
"returning results directly RPC method calls will return Deferred_ instances,"
" which will themselves resolve to the result of the matching RPC call."
msgstr "该接口是：参考：`异步<参考/异步>`，所以不是返回结果直接RPC方法调用返回Deferred_情况下，将自己想办法解决，以匹配的RPC调用的结果。"

#: ../../reference/javascript.rst:444
msgid ""
"Because ECMAScript 3/Javascript 1.5 doesnt feature any equivalent to "
"``__getattr__`` or ``method_missing``, there needs to be an explicit method "
"to dispatch RPC methods."
msgstr "由于ECMAScript的3 / Javascript的1.5犯规特征的任何等同于``__getattr__``或``method_missing``，需要有一个明确的方法来调度RPC方法。"

#: ../../reference/javascript.rst:448
msgid ""
"No notion of pooler, the model proxy is instantiated where needed, not "
"fetched from an other (somewhat global) object::"
msgstr "普勒没有概念，模型代理实例在需要的地方，从其他（有点全局）对象::不取"

#: ../../reference/javascript.rst:458
msgid ""
":func:`~Model.query` is a shortcut for a builder-style interface to searches"
" (``search`` + ``read`` in Odoo RPC terms). It returns a "
":class:`~openerp.web.Query` object which is immutable but allows building "
"new :class:`~openerp.web.Query` instances from the first one, adding new "
"properties or modifiying the parent object's::"
msgstr "：FUNC：`〜Model.query`是一个建设者风格的界面，搜索快捷键（``在Odoo RPC方面search`` +``read``）。它返回一个：类：`〜openerp.web.Query`对象，它是不可变的，但允许建立新的产品类别：`从第一个〜openerp.web.Query`情况下，增加新的属性或modifiying父对象的::"

#: ../../reference/javascript.rst:471
msgid ""
"The query is only actually performed when calling one of the query "
"serialization methods, :func:`~openerp.web.Query.all` and "
":func:`~openerp.web.Query.first`. These methods will perform a new RPC call "
"every time they are called."
msgstr "只是实际执行的查询要求之一的查询序列化方法，当：FUNC：`〜openerp.web.Query.all`和：FUNC：`〜openerp.web.Query.first`。这些方法将执行新的RPC调用每一个他们被称为时间。"

#: ../../reference/javascript.rst:476
msgid ""
"For that reason, it's actually possible to keep \"intermediate\" queries "
"around and use them differently/add new specifications on them."
msgstr "出于这个原因，它实际上可以保持\“中间\”查询周围，并利用它们不同的/它们添加新的规格。"

#: ../../reference/javascript.rst:483
msgid "name of the model this object is bound to"
msgstr "模型的这个对象绑定到名字"

#: ../../reference/javascript.rst:487
msgid ""
"Calls the ``method`` method of the current model, with the provided "
"positional and keyword arguments."
msgstr "调用当前模型的``method``方法，与提供位置和关键字参数。"

#: ../../reference/javascript.rst:490
msgid "method to call over rpc on the :attr:`~Model.name`"
msgstr "方法来调用通过RPC的：ATTR：`〜Model.name`"

#: ../../reference/javascript.rst:492
msgid "positional arguments to pass to the method, optional"
msgstr "位置参数传递给方法，可选"

#: ../../reference/javascript.rst:494
msgid "keyword arguments to pass to the method, optional"
msgstr "关键字参数传递给方法，可选"

#: ../../reference/javascript.rst:496
msgid "Deferred<>"
msgstr "递延<>"

#: ../../reference/javascript.rst:500
msgid "list of fields to fetch during the search"
msgstr "字段列表的搜索过程中获取"

#: ../../reference/javascript.rst:502
msgid ""
"a :class:`~openerp.web.Query` object representing the search to perform"
msgstr "答：类：`〜openerp.web.Query`对象，表示搜索执行"

#: ../../reference/javascript.rst:507
msgid ""
"The first set of methods is the \"fetching\" methods. They perform RPC "
"queries using the internal data of the object they're called on."
msgstr "第一组的方法是\“抓取\”的方法。他们的表现用他们呼吁对象的内部数据RPC查询。"

#: ../../reference/javascript.rst:513
msgid ""
"Fetches the result of the current :class:`~openerp.web.Query` object's "
"search."
msgstr "获取当前的结果：类：`〜openerp.web.Query`对象的搜索。"

#: ../../reference/javascript.rst:516
msgid "Deferred<Array<>>"
msgstr "递延<阵<>>"

#: ../../reference/javascript.rst:520
msgid ""
"Fetches the **first** result of the current :class:`~openerp.web.Query`, or "
"``null`` if the current :class:`~openerp.web.Query` does have any result."
msgstr "获取当前的**第**结果：类：`〜openerp.web.Query`，或``null``如果当前的：class：`〜openerp.web.Query`不会有任何结果。"

#: ../../reference/javascript.rst:524
msgid "Deferred<Object | null>"
msgstr "递延<对象|空>"

#: ../../reference/javascript.rst:528
msgid ""
"Fetches the number of records the current :class:`~openerp.web.Query` would "
"retrieve."
msgstr "获取的记录数当前：类：`〜openerp.web.Query`将检索。"

#: ../../reference/javascript.rst:531
msgid "Deferred<Number>"
msgstr "递延<编号>"

#: ../../reference/javascript.rst:535
msgid ""
"Fetches the groups for the query, using the first specified grouping "
"parameter"
msgstr "取出的组进行查询，使用所述第一指定的分组参数"

#: ../../reference/javascript.rst:538
msgid ""
"Lists the levels of grouping asked of the server. Grouping can actually be "
"an array or varargs."
msgstr "列出的分组问的服务器的水平。分组实际上可以是一个数组或可变参数。"

#: ../../reference/javascript.rst:542
msgid "Deferred<Array<openerp.web.QueryGroup>> | null"
msgstr "递延<阵<openerp.web.QueryGroup >> |空"

#: ../../reference/javascript.rst:544
msgid ""
"The second set of methods is the \"mutator\" methods, they create a **new** "
":class:`~openerp.web.Query` object with the relevant (internal) attribute "
"either augmented or replaced."
msgstr "第二组方法是\“突变\”的方法，他们创造一个新的** **：类：`〜相关（内部）openerp.web.Query`对象的属性或者增加或更换。"

#: ../../reference/javascript.rst:550
msgid "Adds the provided ``ctx`` to the query, on top of any existing context"
msgstr "将提供的``ctx``的查询，对现有环境的顶部"

#: ../../reference/javascript.rst:555
msgid ""
"Adds the provided domain to the query, this domain is ``AND``-ed to the "
"existing query domain."
msgstr "将提供的域名查询，该域名是``AND``-ED现有的查询域。"

#: ../../reference/javascript.rst:560
msgid ""
"Sets the provided offset on the query. The new offset *replaces* the old "
"one."
msgstr "设置在查询所提供的补偿。新的偏移量* *替换旧的。"

#: ../../reference/javascript.rst:565
msgid ""
"Sets the provided limit on the query. The new limit *replaces* the old one."
msgstr "设置在查询所提供的极限。新限制* *替换旧的。"

#: ../../reference/javascript.rst:570
msgid ""
"Overrides the model's natural order with the provided field specifications. "
"Behaves much like Django's :py:meth:`QuerySet.order_by "
"<django.db.models.query.QuerySet.order_by>`:"
msgstr "覆盖模型的自然秩序与所提供的字段规范。行为很像Django的：PY：甲：`QuerySet.order_by <django.db.models.query.QuerySet.order_by>`："

#: ../../reference/javascript.rst:574
msgid ""
"Takes 1..n field names, in order of most to least importance (the first "
"field is the first sorting key). Fields are provided as strings."
msgstr "注意到1..N字段名，以最到最重要的（第一场是第一个排序键）。字段提供字符串。"

#: ../../reference/javascript.rst:578
msgid ""
"A field specifies an ascending order, unless it is prefixed with the minus "
"sign \"``-``\" in which case the field is used in the descending order"
msgstr "字段指定了一个升序排列，除非它前面加上减号\“``-`` \”在这种情况下字段用于降序排序"

#: ../../reference/javascript.rst:582
msgid ""
"Divergences from Django's sorting include a lack of random sort (``?`` "
"field) and the inability to \"drill down\" into relations for sorting."
msgstr "从Django的排序分歧包括缺乏随机排序（``？``场），并不能为\“向下钻取\”成关系进行排序。"

#: ../../reference/javascript.rst:587
msgid "Aggregation (grouping)"
msgstr "聚合（分组）"

#: ../../reference/javascript.rst:589
msgid ""
"Odoo has powerful grouping capacities, but they are kind-of strange in that "
"they're recursive, and level n+1 relies on data provided directly by the "
"grouping at level n. As a result, while "
":py:meth:`openerp.models.Model.read_group` works it's not a very intuitive "
"API."
msgstr "Odoo具有强大的分组的能力，但它们是奇怪的，因为它们是递归形式的-，和电平n + 1个依赖于通过在级n分组直接提供的数据。其结果是，虽然：PY：甲：`openerp.models.Model.read_group`作品这不是一个很直观的API。"

#: ../../reference/javascript.rst:595
msgid ""
"Odoo Web eschews direct calls to :py:meth:`~openerp.models.Model.read_group`"
" in favor of calling a method of :class:`~openerp.web.Query`, :py:meth:`much"
" in the way it is one in SQLAlchemy <sqlalchemy.orm.query.Query.group_by>` "
"[#terminal]_::"
msgstr "Odoo网络避开直接调用：赞成调用的方法的`〜openerp.models.Model.read_group`：产品类别：PY：甲基`〜openerp.web.Query`，：PY：甲：`多的方式这是一家在SQLAlchem​​y的<sqlalchem​​y.orm.query.Query.group_by>`[#terminal] _ ::"

#: ../../reference/javascript.rst:604
msgid ""
"This method is asynchronous when provided with 1..n fields (to group on) as "
"argument, but it can also be called without any field (empty fields "
"collection or nothing at all). In this case, instead of returning a Deferred"
" object it will return ``null``."
msgstr "这种方法是异步的，当有1..1领域（以组）作为参数提供的，但它也可以被称为无任何领域（空字段集合或者什么都没有）。而不是返回一个Deferred对象在这种情况下，它会返回``null``。"

#: ../../reference/javascript.rst:609
msgid ""
"When grouping criterion come from a third-party and may or may not list "
"fields (e.g. could be an empty list), this provides two ways to test the "
"presence of actual subgroups (versus the need to perform a regular query for"
" records):"
msgstr "当分组标准来自第三方并且可以或可以不列出的字段（例如，可能是一个空的列表），这提供了两种方法来测试实际子组的存在（相对于需要执行用于记录常规查询）："

#: ../../reference/javascript.rst:614
msgid ""
"A check on ``group_by``'s result and two completely separate code paths::"
msgstr "对``group_by``的结果和两个完全不同的代码路径进行检查::"

#: ../../reference/javascript.rst:625
msgid ""
"Or a more coherent code path using :func:`when`'s ability to coerce values "
"into deferreds::"
msgstr "或者更连贯的代码路径使用：FUNC：`when`的强迫值到deferreds能力::"

#: ../../reference/javascript.rst:637
msgid ""
"The result of a (successful) :func:`~openerp.web.Query.group_by` is an array"
" of :class:`~openerp.web.QueryGroup`:"
msgstr "FUNC：一个（成功）结果`〜openerp.web.Query.group_by`是一个数组：类：`〜openerp.web.QueryGroup`："

#: ../../reference/javascript.rst:644
msgid "returns the group's attribute ``key``. Known attributes are:"
msgstr "返回组的属性``key``。已知的属性有："

#: ../../reference/javascript.rst:646
msgid "``grouped_on``"
msgstr "``grouped_on``"

#: ../../reference/javascript.rst:647
msgid "which grouping field resulted from this group"
msgstr "其中分组字段是由于该组"

#: ../../reference/javascript.rst:649
msgid "``grouped_on``'s value for this group"
msgstr "这组``grouped_on``的价值"

#: ../../reference/javascript.rst:650
msgid "``length``"
msgstr "``length``"

#: ../../reference/javascript.rst:651
msgid "the number of records in the group"
msgstr "记录的组中的号"

#: ../../reference/javascript.rst:652
msgid "``aggregates``"
msgstr "``aggregates``"

#: ../../reference/javascript.rst:653
msgid "a {field: value} mapping of aggregations for the group"
msgstr "一个{字段：值}聚合为组映射"

#: ../../reference/javascript.rst:657
msgid ""
"equivalent to :func:`Model.query` but pre-filtered to only include the "
"records within this group. Returns a :class:`~openerp.web.Query` which can "
"be further manipulated as usual."
msgstr "相当于：FUNC：`Model.query`但预过滤，只包括该组中的记录。返回：类：`〜openerp.web.Query`可以进一步操纵如常。"

#: ../../reference/javascript.rst:664
msgid ""
"returns a deferred to an array of :class:`~openerp.web.QueryGroup` below "
"this one"
msgstr "返回一个推迟到数组：类：`〜下面这一个openerp.web.QueryGroup`"

#: ../../reference/javascript.rst:668
msgid "Low-level API: RPC calls to Python side"
msgstr "低级API：RPC调用到Python方"

#: ../../reference/javascript.rst:670
msgid ""
"While the previous section is great for calling core OpenERP code (models "
"code), it does not work if you want to call the Python side of Odoo Web."
msgstr "虽然上一节是伟大的调用核心的OpenERP代码（机型代码），它并不重要，如果你想打电话Odoo网络的Python端的工作。"

#: ../../reference/javascript.rst:674
msgid ""
"For this, a lower-level API exists on on :class:`~Session` objects (the "
"class is exported in ``web.Session``, but an instance isusually available "
"through ``web.session``): the ``rpc`` method."
msgstr "对于这一点，较低级别的API存在上：类：`〜Session`对象（类出口在``web.Session``，但一个实例isusually可以通过``web.session``）：在` `rpc``方法。"

#: ../../reference/javascript.rst:678
msgid ""
"This method simply takes an absolute path (the absolute URL of the JSON "
":ref:`route <reference/http/routing>` to call) and a mapping of attributes "
"to values (passed as keyword arguments to the Python method). This function "
"fetches the return value of the Python methods, converted to JSON."
msgstr "这种方法只需要一个绝对路径（JSON的绝对URL：参考：`航线<参考/ HTTP /路由>`调用）和属性的映射值（传递关键字参数到Python的方法）。该功能获取的Python的方法的返回值，转换成JSON。"

#: ../../reference/javascript.rst:683
msgid ""
"For instance, to call the ``resequence`` of the "
":class:`~web.controllers.main.DataSet` controller::"
msgstr "例如，要调用的的``resequence``：类：`〜web.controllers.main.DataSet`控制器::"

#: ../../reference/javascript.rst:699
msgid "Web Client"
msgstr "Web客户端"

#: ../../reference/javascript.rst:702
msgid "Javascript module system overview"
msgstr "Javascript的模块系统概述"

#: ../../reference/javascript.rst:704
msgid ""
"A new module system (inspired from requirejs) has now been deployed. It has "
"many advantages over the Odoo version 8 system."
msgstr "一个新的模块系统（从requirejs启发）现在已经部署。它拥有超过Odoo版本8系统的许多优点。"

#: ../../reference/javascript.rst:707
msgid ""
"loading order: dependencies are guaranteed to be loaded first, even if files"
" are not loaded in the correct order in the bundle files."
msgstr "加载顺序：依赖关系，保证先加载，即使没有按照正确的顺序在包文件加载的文件。"

#: ../../reference/javascript.rst:709
msgid "easier to split a file into smaller logical units."
msgstr "更容易文件分割成更小的逻辑单元。"

#: ../../reference/javascript.rst:710
msgid "no global variables: easier to reason."
msgstr "没有全局变量：容易理由。"

#: ../../reference/javascript.rst:711
msgid ""
"it is possible to examine every dependencies and dependants.  This makes "
"refactoring much simpler, and less risky."
msgstr "它可以检查每个依赖和家属。这使得重构简单得多，而且风险较小。"

#: ../../reference/javascript.rst:714
msgid "It has also some disadvantages:"
msgstr "它也有一些缺点："

#: ../../reference/javascript.rst:716
msgid ""
"files are required to use the module system if they want to interact with "
"odoo, since the various objects are only available in the module system, and"
" not in global variables"
msgstr "文件需要使用模块的系统，如果他们想与odoo交互，因为各种对象仅在模块系统中可用的，并没有在全局变量"

#: ../../reference/javascript.rst:719
msgid ""
"circular dependencies are not supported.  It makes sense, but it means that "
"one needs to be careful."
msgstr "不支持循环依赖。这是有道理的，但它意味着一个人需要小心。"

#: ../../reference/javascript.rst:722
msgid ""
"This is obviously a very large change and will require everyone to adopt new"
" habits.  For example, the variable openerp does not exist anymore.  The new"
" way of doing things is to import explicitely the module you need, and "
"declaring explicitely the objects you export.  Here is a simple example::"
msgstr "这显然​​是一个非常大的变化，并要求大家采用新的习惯。例如，该变量的OpenERP不存在了。做事情的新方式是明确地输入你所需要的模块，并宣布明确地导出的对象。下面是一个简单的例子::"

#: ../../reference/javascript.rst:739
msgid ""
"This snippet shows a module named ``addon_name.service``.  It is defined "
"with the ``odoo.define`` function.  ``odoo.define`` takes a name and a "
"function for arguments:"
msgstr "这片段显示了一个名为``addon_name.service``模块。它被定义的``odoo.define``功能。 ``odoo.define``需要一个名称和功能参数："

#: ../../reference/javascript.rst:743
msgid ""
"The name is the concatenation of the name of the addon it is defined in and "
"a name describing its purpose."
msgstr "名称是它是在定义的插件并描述其用途的名称的名称的串联。"

#: ../../reference/javascript.rst:745
msgid ""
"The function is the place where the javascript module is actually defined.  "
"It takes a function ``require`` as first argument, and returns something (or"
" not, depending if it needs to export something). The ``require`` function "
"is used to get a handle on the dependencies. In this case, it gives a handle"
" on two javascript modules from the ``web`` addon, namely ``web.utils`` and "
"``web.Model``."
msgstr "该功能是其中的javascript模块实际上是定义的地方。它需要一个函数``require``作为第一个参数，返回的东西（或没有，这取决于是否需要出口的东西）。该``require``功能是用来获得相关性信息的处理。在这种情况下，它提供了在两个JavaScript的模块的把手从``web``插件，即``web.utils``和``web.Model``。"

#: ../../reference/javascript.rst:752
msgid ""
"The idea is that you define what you need to import (by using the "
"``require`` function) and declare what you export (by returning something)."
"  The web client will then make sure that your code is loaded properly."
msgstr "我们的想法是，你确定你所需要导入（使用``require``功能），并声明一下你出口（通过返回的东西）。那么Web客户端将确保您的代码加载正确。"

#: ../../reference/javascript.rst:757
msgid ""
"Modules are contained in a file, but a file can define several modules "
"(however, it is better to keep them in separate files)."
msgstr "模块都包含在一个文件，而是一个文件可以定义多个模块（然而，最好将其保存在单独的文件）。"

#: ../../reference/javascript.rst:760
msgid ""
"Each module can return a deferred. In that case, the module is marked as "
"loaded only when the deferred is resolved, and its value is equal to the "
"resolved value. The module can be rejected (unloaded). This will be logged "
"in the console as info."
msgstr "每个模块都可以返回一个延迟。在这种情况下，该模块被标记为装载仅当延迟得以解决，并且其值等于解析值。该模块可被拒绝（卸载）。这将在控制台的信息被记录。"

#: ../../reference/javascript.rst:764
msgid ""
"``Missing dependencies``: These modules do not appear in the page. It is "
"possible that the JavaScript file is not in the page or that the module name"
" is wrong"
msgstr "``缺少dependencies``：这些模块没有出现在该页面。这是可能的JavaScript文件是不是在页面或模块名称是错"

#: ../../reference/javascript.rst:767
msgid "``Failed modules``: A javascript error is detected"
msgstr "``失败modules``：检测JavaScript错误"

#: ../../reference/javascript.rst:769
msgid ""
"``Rejected modules``: The module returns a rejected deferred. It (and its "
"dependent modules) is not loaded."
msgstr "``拒绝modules``：该模块返回一个被拒绝延期。它（及其相关模块）未加载。"

#: ../../reference/javascript.rst:772
msgid "``Rejected linked modules``: Modules who depend on a rejected module"
msgstr "``拒绝联modules``：模块靠谁被拒绝模块"

#: ../../reference/javascript.rst:774
msgid ""
"``Non loaded modules``: Modules who depend on a missing or a failed module"
msgstr "``不装modules``：谁的模块依赖于丢失或发生故障的模块"

#: ../../reference/javascript.rst:779
msgid "Web client structure"
msgstr "Web客户端结构"

#: ../../reference/javascript.rst:781
msgid ""
"The web client files have been refactored into smaller and simpler files. "
"Here is a description of the current file structure:"
msgstr "Web客户端文件已被重构为更小的，更简单的文件。这里是当前文件结构的描述："

#: ../../reference/javascript.rst:784
msgid ""
"the ``framework/`` folder contains all basic low level modules.  The modules"
" here are supposed to be generic.  Some of them are:"
msgstr "在``框架/``文件夹包含所有基本低水平模块。这里的模块应该是通用的。其中一些是："

#: ../../reference/javascript.rst:787
msgid "``web.ajax`` implements rpc calls"
msgstr "``web.ajax``实现RPC调用"

#: ../../reference/javascript.rst:788
msgid ""
"``web.core`` is a generic modules.  It exports various useful objects and "
"functions, such as ``qweb``, ``_t`` or the main bus."
msgstr "``web.core``是一个通用模块。它出口各种有用的对象和功能，如``qweb``，``_t``或主总线。"

#: ../../reference/javascript.rst:790
msgid "``web.Widget`` contains the widget class"
msgstr "``web.Widget``包含窗口小部件类"

#: ../../reference/javascript.rst:791
msgid ""
"``web.Model`` is an abstraction over ``web.ajax`` to make calls to the "
"server model methods"
msgstr "``web.Model``是一个抽象的概念了``web.ajax``打电话到该服务器模型的方法"

#: ../../reference/javascript.rst:793
msgid "``web.session`` is the former ``openerp.session``"
msgstr "``web.session``是前者``openerp.session``"

#: ../../reference/javascript.rst:794
msgid "``web.utils`` for useful code snippets"
msgstr "``web.utils``有用的代码片段"

#: ../../reference/javascript.rst:795
msgid "``web.time`` for every time-related generic functions"
msgstr "``web.time``每一个与时间相关的通用功能，"

#: ../../reference/javascript.rst:796
msgid "the ``views/`` folder contains all view definitions"
msgstr "在``意见/``文件夹包含所有视图定义"

#: ../../reference/javascript.rst:797
msgid "``widgets/`` is for standalone widgets"
msgstr "``部件/``是独立的部件"

#: ../../reference/javascript.rst:799
msgid "The ``js/`` folder also contains some important files:"
msgstr "该``JS /``文件夹还包含一些重要的文件："

#: ../../reference/javascript.rst:801
msgid "``action_manager.js`` is the ActionManager class"
msgstr "``action_manager.js``是ActionManager类"

#: ../../reference/javascript.rst:802
msgid "``boot.js`` is the file actually implementing the module system"
msgstr "``boot.js``是实际执行的模块系统中的文件"

#: ../../reference/javascript.rst:803
msgid "``menu.js`` is the definition of the top menu"
msgstr "``menu.js``是顶部菜单的定义"

#: ../../reference/javascript.rst:804
msgid "``web_client.js`` is for the root widget WebClient"
msgstr "``web_client.js``是根小部件的WebClient"

#: ../../reference/javascript.rst:805
msgid "``view_manager.js`` contains the ViewManager"
msgstr "``view_manager.js``包含ViewManager"

#: ../../reference/javascript.rst:807
msgid ""
"The two other files are ``tour.js`` for the tours and ``compatibility.js``. "
"The latter file is a compatibility layer bridging the old system to the new "
"module system.  This is where every module names are exported to the global "
"variable ``openerp``.  In theory, our addons should work without ever using "
"the variable ``openerp``, and the compatibility module can be disabled "
"safely."
msgstr "其他两个文件是``tour.js``的旅游和``compatibility.js``。后者文件是一个兼容层桥接旧体制到新的模块系统。这是每一个模块名称远销全局变量``openerp``。从理论上讲，我们的插件应该工作而没有使用可变``openerp``，并兼容模块，可以安全地禁用。"

#: ../../reference/javascript.rst:815
msgid "Javascript conventions"
msgstr "Javascript的约定"

#: ../../reference/javascript.rst:817
msgid "Here are some basic conventions for the javascript code:"
msgstr "下面是JavaScript代码的一些基本规则："

#: ../../reference/javascript.rst:819
msgid ""
"declare all your dependencies at the top of the module.  Also, they should "
"be sorted alphabetically by module name.  This makes it easier to understand"
" your module."
msgstr "声明你的依赖在模块的顶部。此外，他们应该按字母顺序模块名称排序。这使得它更容易理解你的模块。"

#: ../../reference/javascript.rst:822
msgid "declare all exports at the end."
msgstr "声明所有出口在年底。"

#: ../../reference/javascript.rst:823
msgid "add the ``use strict`` statement at the beginning of every module"
msgstr "加上``使用strict``声明在每个模块开始"

#: ../../reference/javascript.rst:824
msgid "always name your module properly: ``addon_name.description``."
msgstr "始终正确命名的模块：``addon_name.description``。"

#: ../../reference/javascript.rst:825
msgid ""
"use capital letters for classes (for example, ``ActionManager`` is defined "
"in the module ``web.ActionManager``), and lowercase for everything else (for"
" example, ``ajax`` is defined in ``web.ajax``)."
msgstr "使用大写字母类（例如，``ActionManager``在模块``web.ActionManager``中定义），和小写的一切（例如，``ajax``在``定义web.ajax ``）。"

#: ../../reference/javascript.rst:828
msgid "declare one module per file"
msgstr "每个申报文件的一个模块"

#: ../../reference/javascript.rst:835
msgid "Testing in Odoo Web Client"
msgstr "测试在Odoo Web客户端"

#: ../../reference/javascript.rst:838
msgid "Javascript Unit Testing"
msgstr "Javascript的单元测试"

#: ../../reference/javascript.rst:840
msgid ""
"Odoo Web includes means to unit-test both the core code of Odoo Web and your"
" own javascript modules. On the javascript side, unit-testing is based on "
"QUnit_ with a number of helpers and extensions for better integration with "
"Odoo."
msgstr "Odoo网络包括手段，单元测试既Odoo Web和自己的JavaScript模块的核心代码。在JavaScript端，单元测试是基于QUnit_与一些助手和扩展与Odoo更好的整合。"

#: ../../reference/javascript.rst:845
msgid ""
"To see what the runner looks like, find (or start) an Odoo server with the "
"web client enabled, and navigate to ``/web/tests`` This will show the runner"
" selector, which lists all modules with javascript unit tests, and allows "
"starting any of them (or all javascript tests in all modules at once)."
msgstr "要查看亚军的样子，找到（或启动）的Odoo服务器与Web客户端启用，并导航到``/网络/ tests``这将显示跑步者选择，其中列出了所有模块的JavaScript单元测试，允许启动其中的任何（或所有模块的所有的JavaScript测试一次）。"

#: ../../reference/javascript.rst:854
msgid ""
"Clicking any runner button will launch the corresponding tests in the "
"bundled QUnit_ runner:"
msgstr "点击任何按钮，亚军将推出捆绑QUnit_亚军相应的测试："

#: ../../reference/javascript.rst:861
msgid "Writing a test case"
msgstr "编写测试用例"

#: ../../reference/javascript.rst:863
msgid ""
"The first step is to list the test file(s). This is done through the "
"``test`` key of the Odoo manifest, by adding javascript files to it:"
msgstr "第一步是列出测试文件（多个）。这是通过Odoo清单的``test``键完成，通过添加JavaScript文件吧："

#: ../../reference/javascript.rst:875
msgid "and to create the corresponding test file(s)"
msgstr "并建立相应的测试文件（S）"

#: ../../reference/javascript.rst:879
msgid ""
"Test files which do not exist will be ignored, if all test files of a module"
" are ignored (can not be found), the test runner will consider that the "
"module has no javascript tests."
msgstr "其中不存在测试文件将被忽略，如果一个模块的所有测试文件被忽略（无法找到），测试运行会认为模块没有JavaScript的测试。"

#: ../../reference/javascript.rst:883
msgid ""
"After that, refreshing the runner selector will display the new module and "
"allow running all of its (0 so far) tests:"
msgstr "在此之后，刷新亚军选择器将显示新的模块，并允许运行其所有（0）测试："

#: ../../reference/javascript.rst:889
msgid "The next step is to create a test case::"
msgstr "下一步是创建一个测试用例::"

#: ../../reference/javascript.rst:897
msgid ""
"All testing helpers and structures live in the ``openerp.testing`` module. "
"Odoo tests live in a :func:`~openerp.testing.section`, which is itself part "
"of a module. The first argument to a section is the name of the section, the"
" second one is the section body."
msgstr "所有的测试助手和结构生活``openerp.testing``模块内。 Odoo测试住在：FUNC：`〜openerp.testing.section`，这本身就是一个模块的一部分。的第一个参数的截面是段的名称，所述第二个是部分身体。"

#: ../../reference/javascript.rst:902
msgid ""
":func:`test <openerp.testing.case>`, provided by the "
":func:`~openerp.testing.section` to the callback, is used to register a "
"given test case which will be run whenever the test runner actually does its"
" job. Odoo Web test case use standard `QUnit assertions`_ within them."
msgstr "：FUNC：`测试<openerp.testing.case>`，由提供：FUNC：`〜openerp.testing.section`回调，用于注册一个给定的测试用例每当测试运行实际上做这将运行它的工作。 Odoo Web测试的情况下使用标准的`QUnit assertions`_在其中。"

#: ../../reference/javascript.rst:908
msgid ""
"Launching the test runner at this point will run the test and display the "
"corresponding assertion message, with red colors indicating the test failed:"
msgstr "启动测试运行在此时将运行测试，并显示相应的断言消息，以红颜色显示测试失败："

#: ../../reference/javascript.rst:915
msgid ""
"Fixing the test (by replacing ``false`` to ``true`` in the assertion) will "
"make it pass:"
msgstr "固定测试（通过更换``false``到值为``True``的说法），将它传递："

#: ../../reference/javascript.rst:922
msgid "Assertions"
msgstr "断言"

#: ../../reference/javascript.rst:924
msgid ""
"As noted above, Odoo Web's tests use `qunit assertions`_. They are available"
" globally (so they can just be called without references to anything). The "
"following list is available:"
msgstr "如上所述，Odoo网络的测试使用`qunit assertions`_。他们可在全球范围（这样他们可以在没有引用调用任何东西）。下面的列表是可用："

#: ../../reference/javascript.rst:930
msgid "checks that ``state`` is truthy (in the javascript sense)"
msgstr "将检查``state``是truthy（在JavaScript的意义上）"

#: ../../reference/javascript.rst:934
msgid ""
"checks that the actual (produced by a method being tested) and expected "
"values are identical (roughly equivalent to ``ok(actual === expected, "
"message)``)"
msgstr "将检查的实际（通过一个方法制造所测试）和预期值是相同的（大致相当于``预期确定（实际===，消息）``）"

#: ../../reference/javascript.rst:940
msgid ""
"checks that the actual and expected values are *not* identical (roughly "
"equivalent to ``ok(actual !== expected, message)``)"
msgstr "检查实际值和预期值是*不*相同（大致相当于``OK（实际！==预期，消息）``）"

#: ../../reference/javascript.rst:945
msgid ""
"deep comparison between actual and expected: recurse into containers "
"(objects and arrays) to ensure that they have the same keys/number of "
"elements, and the values match."
msgstr "之间的实际和预期的深比较：递归到容器（对象和数组），以确保它们具有相同的键/元件的数目，以及值匹配。"

#: ../../reference/javascript.rst:951
msgid "inverse operation to :func:`deepEqual`"
msgstr "反向操作：FUNC：`deepEqual`"

#: ../../reference/javascript.rst:955
msgid ""
"checks that, when called, the ``block`` throws an error. Optionally "
"validates that error against ``expected``."
msgstr "检查，调用它时，在``block``抛出一个错误。可选验证对``expected``的错误。"

#: ../../reference/javascript.rst:959
msgid ""
"if a regexp, checks that the thrown error's message matches the regular "
"expression. If an error type, checks that the thrown error is of that type."
msgstr "如果一个正则表达式，检查，抛出的错误的信息的正则表达式匹配。如果错误类型，检查，抛出的错误是类型。"

#: ../../reference/javascript.rst:967
msgid ""
"checks that ``actual`` and ``expected`` are loosely equal, using the ``==`` "
"operator and its coercion rules."
msgstr "将检查``actual``和``expected``松散相等，使用``==``运营商和它的强制规则。"

#: ../../reference/javascript.rst:972
msgid "inverse operation to :func:`equal`"
msgstr "反向操作：FUNC：`equal`"

#: ../../reference/javascript.rst:975
msgid "Getting an Odoo instance"
msgstr "获得一个Odoo实例"

#: ../../reference/javascript.rst:977
msgid ""
"The Odoo instance is the base through which most Odoo Web modules behaviors "
"(functions, objects, …) are accessed. As a result, the test framework "
"automatically builds one, and loads the module being tested and all of its "
"dependencies inside it. This new instance is provided as the first "
"positional parameter to your test cases. Let's observe by adding javascript "
"code (not test code) to the test module:"
msgstr "该Odoo实例是通过它最Odoo Web模块的行为（函数，对象，...）进行访问的基础。其结果是，在测试的框架自动建立的，并加载被测试的模块和所有其它里面的依赖关系。这个新的实例被提供作为第一位置参数测试用例。我们观察到通过添加JavaScript代码（不是测试代码），以测试模块："

#: ../../reference/javascript.rst:1009
msgid ""
"and then adding a new test case, which simply checks that the ``instance`` "
"contains all the expected stuff we created in the module::"
msgstr "然后添加一个新的测试用例，它只是检查了``instance``包含了我们在模块中创建的所有期望的东西::"

#: ../../reference/javascript.rst:1021
msgid "DOM Scratchpad"
msgstr "DOM便签"

#: ../../reference/javascript.rst:1023
msgid ""
"As in the wider client, arbitrarily accessing document content is strongly "
"discouraged during tests. But DOM access is still needed to e.g. fully "
"initialize :class:`widgets <~openerp.Widget>` before testing them."
msgstr "由于在更广泛的客户端，任意访问文档内容强烈测试期间劝阻。但访问DOM仍然需要如完全初始化：类：`小部件<〜openerp.Widget>`测试之前。"

#: ../../reference/javascript.rst:1028
msgid ""
"Thus, a test case gets a DOM scratchpad as its second positional parameter, "
"in a jQuery instance. That scratchpad is fully cleaned up before each test, "
"and as long as it doesn't do anything outside the scratchpad your code can "
"do whatever it wants::"
msgstr "因此，一个测试用例得到一个DOM暂存器作为其第二个位置参数，在jQuery的实例。这暂存器完全清理每次测试前，只要它不暂存器外界做任何你的代码可以为所欲为::"

#: ../../reference/javascript.rst:1046
msgid ""
"The top-level element of the scratchpad is not cleaned up, test cases can "
"add text or DOM children but shoud not alter ``$scratchpad`` itself."
msgstr "暂存器的顶级元素没有清理，测试案例可以添加文字或DOM孩子，但768,16不会改变``$ scratchpad``本身。"

#: ../../reference/javascript.rst:1051
msgid "Loading templates"
msgstr "加载模板"

#: ../../reference/javascript.rst:1053
msgid ""
"To avoid the corresponding processing costs, by default templates are not "
"loaded into QWeb. If you need to render e.g. widgets making use of QWeb "
"templates, you can request their loading through the "
":attr:`~TestOptions.templates` option to the :func:`test case function "
"<openerp.testing.case>`."
msgstr "为了避免相应的处理成本，默认模板不加载到QWeb。 ATTR：如果您需要渲染，例如部件利用QWeb模板，可以通过要求其装载`〜TestOptions.templates`选项到：FUNC：`测试用例功能<openerp.testing.case>`。"

#: ../../reference/javascript.rst:1059
msgid ""
"This will automatically load all relevant templates in the instance's qweb "
"before running the test case:"
msgstr "这将自动加载该实例的qweb所有相关的模板运行测试用例之前："

#: ../../reference/javascript.rst:1097
msgid "Asynchronous cases"
msgstr "异步的情况下"

#: ../../reference/javascript.rst:1099
msgid ""
"The test case examples so far are all synchronous, they execute from the "
"first to the last line and once the last line has executed the test is done."
" But the web client is full of :ref:`asynchronous code <reference/async>`, "
"and thus test cases need to be async-aware."
msgstr "测试用例例子到目前为止都是同步的，它们从第一个到最后一个行执行一次最后一行已经执行了测试完成。但Web客户端充满了：REF：`异步代码<参考/异步>`，因而测试用例需要是异步感知。"

#: ../../reference/javascript.rst:1104
msgid ""
"This is done by returning a :class:`deferred <Deferred>` from the case "
"callback::"
msgstr "类：这是通过返回一个完成的情况下，回调`递延<递延>`::"

#: ../../reference/javascript.rst:1119
msgid ""
"This example also uses the :class:`options parameter <TestOptions>` to "
"specify the number of assertions the case should expect, if less or more "
"assertions are specified the case will count as failed."
msgstr "这个例子也使用了：类：`选项参数<TestOptions>`指定断言的情况下应该想到，如果少了以上断言规定的情况下，将算作失败的次数。"

#: ../../reference/javascript.rst:1123
msgid ""
"Asynchronous test cases *must* specify the number of assertions they will "
"run. This allows more easily catching situations where e.g. the test "
"architecture was not warned about asynchronous operations."
msgstr "异步测试例*必须*指定断言他们将运行的次数。这使得更容易捕捉的地方，例如测试架构是不会警告异步操作的情况。"

#: ../../reference/javascript.rst:1129
msgid ""
"Asynchronous test cases also have a 2 seconds timeout: if the test does not "
"finish within 2 seconds, it will be considered failed. This pretty much "
"always means the test will not resolve. This timeout *only* applies to the "
"test itself, not to the setup and teardown processes."
msgstr "异步测试例也有一个2秒超时：如果测试没有在2秒内完成，这将被认为是失败的。这几乎总是意味着该测试将无法解决。此超时* *只适用于测试本身，而不是建立和拆除过程。"

#: ../../reference/javascript.rst:1137
msgid ""
"If the returned deferred is rejected, the test will be failed unless "
":attr:`~TestOptions.fail_on_rejection` is set to ``false``."
msgstr "如果返回的延期被拒绝，测试将失败，除非：ATTR：`〜TestOptions.fail_on_rejection`设置为``false``。"

#: ../../reference/javascript.rst:1144
msgid ""
"An important subset of asynchronous test cases is test cases which need to "
"perform (and chain, to an extent) RPC calls."
msgstr "异步测试案例的一个重要子集试验案件需要执行（和链，在一定程度上）RPC调用。"

#: ../../reference/javascript.rst:1149
msgid ""
"Because they are a subset of asynchronous cases, RPC cases must also provide"
" a valid :attr:`assertions count <TestOptions.asserts>`."
msgstr "因为它们是异步的情况下的一个子集，RPC案件还必须提供有效的：ATTR：`断言计数<TestOptions.asserts>`。"

#: ../../reference/javascript.rst:1153
msgid ""
"To enable mock RPC, set the :attr:`rpc option <TestOptions.rpc>` to "
"``mock``. This will add a third parameter to the test case callback:"
msgstr "为了使模拟RPC，设置：ATTR：`RPC选项<TestOptions.rpc>`来``mock``。这将第三个参数添加到测试用例回调："

#: ../../reference/javascript.rst:1158
msgid ""
"Can be used in two different ways depending on the shape of the first "
"parameter:"
msgstr "可以在根据第一个参数的形状的两个不同的方式使用："

#: ../../reference/javascript.rst:1161
msgid ""
"If it matches the pattern ``model:method`` (if it contains a colon, "
"essentially) the call will set up the mocking of an RPC call straight to the"
" Odoo server (through XMLRPC) as performed via e.g. "
":func:`openerp.web.Model.call`."
msgstr "如果匹配模式``型号：method``（如果它包含一个冒号，本质上）的调用将建立一个RPC调用直奔Odoo服务器（通过XMLRPC）的嘲弄通过例如为执行：FUNC：`的OpenERP .web.Model.call`。"

#: ../../reference/javascript.rst:1166
msgid ""
"In that case, ``handler`` should be a function taking two arguments ``args``"
" and ``kwargs``, matching the corresponding arguments on the server side and"
" should simply return the value as if it were returned by the Python XMLRPC "
"handler::"
msgstr "在这种情况下，``handler``应该采取两个参数``args``和'功能'kwargs``，在服务器端匹配相应的参数，就好像它是由Python返回应该简单地返回值XMLRPC处理器::"

#: ../../reference/javascript.rst:1191
msgid ""
"Otherwise, if it matches an absolute path (e.g. ``/a/b/c``) it will mock a "
"JSON-RPC call to a web client controller, such as "
"``/web/webclient/translations``. In that case, the handler takes a single "
"``params`` argument holding all of the parameters provided over JSON-RPC."
msgstr "否则，如果它的绝对路径（如``/ A / B / c``）匹配，将模拟的JSON-RPC调用的Web客户端控制器，如``/网络/ Web客户端/ translations``。在这种情况下，处理器只需要一个``params``参数保存所有设置在JSON-RPC的参数。"

#: ../../reference/javascript.rst:1197
msgid ""
"As previously, the handler should simply return the result value as if "
"returned by the original JSON-RPC handler::"
msgstr "正如前面，仿佛又回到了原来的JSON-RPC处理程序的处理程序应该简单地返回结果值::"

#: ../../reference/javascript.rst:1223
msgid ""
"Mock handlers can contain assertions, these assertions should be part of the"
" assertions count (and if multiple calls are made to a handler containing "
"assertions, it multiplies the effective number of assertions)."
msgstr "模拟处理程序可以包含断言，这些断言应该是断言的一部分计数（如果通过多次调用包含断言的处理程序，它乘以断言的有效数字）。"

#: ../../reference/javascript.rst:1229
msgid "Testing API"
msgstr "测试API"

#: ../../reference/javascript.rst:1233
msgid ""
"A test section, serves as shared namespace for related tests (for constants "
"or values to only set up once). The ``body`` function should contain the "
"tests themselves."
msgstr "试验段，用作相关测试共享命名空间（常量或值只设置一次）。该``body``功能应包括测试本身。"

#: ../../reference/javascript.rst:1237
msgid ""
"Note that the order in which tests are run is essentially undefined, do "
"*not* rely on it."
msgstr "需要注意的是在测试运行的顺序是不确定的，不要*不*依赖于它。"

#: ../../reference/javascript.rst:1247
msgid ""
"Registers a test case callback in the test runner, the callback will only be"
" run once the runner is started (or maybe not at all, if the test is "
"filtered out)."
msgstr "注册在测试运行测试用例的回调，回调将只能使用一次亚军开始运行（或者根本没有，如果测试过滤掉）。"

#: ../../reference/javascript.rst:1258
msgid ""
"the various options which can be passed to :func:`~openerp.testing.section` "
"or :func:`~openerp.testing.case`. Except for :attr:`~TestOptions.setup` and "
":attr:`~TestOptions.teardown`, an option on :func:`~openerp.testing.case` "
"will overwrite the corresponding option on :func:`~openerp.testing.section` "
"so e.g. :attr:`~TestOptions.rpc` can be set for a "
":func:`~openerp.testing.section` and then differently set for some "
":func:`~openerp.testing.case` of that :func:`~openerp.testing.section`"
msgstr "FUNC：它可以传递到各个选项`〜openerp.testing.section`或：FUNC：`〜openerp.testing.case`。不测：ATTR：`〜TestOptions.setup`和：ATTR：`〜TestOptions.teardown`，上一个选项：FUNC：`〜openerp.testing.case`将覆盖在相应的选项：FUNC：`〜openerp.testing .section`因此如：ATTR：FUNC：`〜openerp.testing.section`，然后不同的一些设置：FUNC：`〜那openerp.testing.case``〜TestOptions.rpc`可以为设置： FUNC：`〜openerp.testing.section`"

#: ../../reference/javascript.rst:1272
msgid ""
"An integer, the number of assertions which should run during a normal "
"execution of the test. Mandatory for asynchronous tests."
msgstr "一个整数，这应该试验的正常执行期间运行声明的数目。强制性异步测试。"

#: ../../reference/javascript.rst:1277
msgid ""
"Test case setup, run right before each test case. A section's "
":func:`~TestOptions.setup` is run before the case's own, if both are "
"specified."
msgstr "测试案例设置，每个测试用例前正确运行。 A节的：FUNC：`〜TestOptions.setup`之前运行的情况下自己，如果两者都指定。"

#: ../../reference/javascript.rst:1283
msgid ""
"Test case teardown, a case's :func:`~TestOptions.teardown` is run before the"
" corresponding section if both are present."
msgstr "测试用例拆解，案件的：FUNC：`〜TestOptions.teardown`的相应部分之前运行，如果两者都存在。"

#: ../../reference/javascript.rst:1288
msgid ""
"If the test is asynchronous and its resulting promise is rejected, fail the "
"test. Defaults to ``true``, set to ``false`` to not fail the test in case of"
" rejection::"
msgstr "如果测试是异步的，其产生的承诺被拒绝，失败的考验。默认为``True``，那么设置为``false``不未通过测试的情况下拒绝::"

#: ../../reference/javascript.rst:1307
msgid ""
"RPC method to use during tests, one of ``\"mock\"`` or ``\"rpc\"``. Any "
"other value will disable RPC for the test (if they were enabled by the suite"
" for instance)."
msgstr "RPC方法在测试过程中使用，对``\“模拟\”``或``\“RPC \”``之一。任何其他值将禁用RPC的测试（如果他们的套件，例如启用）。"

#: ../../reference/javascript.rst:1313
msgid ""
"Whether the current module (and its dependencies)'s templates should be "
"loaded into QWeb before starting the test. A boolean, ``false`` by default."
msgstr "无论是当前模块（及其附属）的模板应该被装入QWeb开始测试之前。一个布尔值，``默认false``。"

#: ../../reference/javascript.rst:1317
msgid ""
"The test runner can also use two global configuration values set directly on"
" the ``window`` object:"
msgstr "测试运行也可以将``window``对象上直接使用设置两个全局配置值："

#: ../../reference/javascript.rst:1320
msgid ""
"``oe_all_dependencies`` is an ``Array`` of all modules with a web component,"
" ordered by dependency (for a module ``A`` with dependencies ``A'``, any "
"module of ``A'`` must come before ``A`` in the array)"
msgstr "``oe_all_dependencies``是``Array``与Web组件的所有模块，订购的相关性（对于一个模块``有依赖性A````A'``中，``A'``任何模块必须A``前``都在阵列中）"

#: ../../reference/javascript.rst:1326
msgid "Running through Python"
msgstr "通过Python的运行"

#: ../../reference/javascript.rst:1328
msgid ""
"The web client includes the means to run these tests on the command-line (or"
" in a CI system), but while actually running it is pretty simple the setup "
"of the pre-requisite parts has some complexities."
msgstr "Web客户端包括在其上运行命令行（或在CI系统）这些测试的手段，但在实际运行它是非常简单的先决条件部分的设置有一定的复杂性。"

#: ../../reference/javascript.rst:1333
msgid ""
"Install unittest2_ in your Python environment. Both can trivially be "
"installed via `pip <http://pip-installer.org>`_ or `easy_install "
"<http://packages.python.org/distribute/easy_install.html>`_."
msgstr "在你的Python环境中安装unittest2_。两者都可以平凡可以通过`PIP安装<http://pip-installer.org>`_或`的easy_install <http://packages.python.org/distribute/easy_install.html>`_。"

#: ../../reference/javascript.rst:1338
msgid ""
"Install PhantomJS_. It is a headless browser which allows automating running"
" and testing web pages. QUnitSuite_ uses it to actually run the qunit_ test "
"suite."
msgstr "安装PhantomJS_。这是它允许自动运行和测试网页的无头的浏览器。 QUnitSuite_用它来实际运行qunit_测试套件。"

#: ../../reference/javascript.rst:1342
msgid ""
"The PhantomJS_ website provides pre-built binaries for some platforms, and "
"your OS's package management probably provides it as well."
msgstr "该PhantomJS_网站提供预先生成的二进制文件，一些平台，和你的操作系统的包管理可能提供它。"

#: ../../reference/javascript.rst:1346
msgid ""
"If you're building PhantomJS_ from source, I recommend preparing for some "
"knitting time as it's not exactly fast (it needs to compile both `Qt <http"
"://qt-project.org/>`_ and `Webkit <http://www.webkit.org/>`_, both being "
"pretty big projects)."
msgstr "如果你正在构建PhantomJS_从源代码，我建议准备一些针织时间，因为它不完全快（它需要编译这两个`Qt的<http://qt-project.org/>`_和`的Webkit <HTTP：/ /www.webkit.org/>`_，无论是相当大的项目）。"

#: ../../reference/javascript.rst:1353
msgid ""
"Because PhantomJS_ is webkit-based, it will not be able to test if Firefox, "
"Opera or Internet Explorer can correctly run the test suite (and it is only "
"an approximation for Safari and Chrome). It is therefore recommended to "
"*also* run the test suites in actual browsers once in a while."
msgstr "由于PhantomJS_是基于WebKit的，它无法测试，如果火狐，歌剧或Internet Explorer可以正确运行测试套件（这只是一个近似值的Safari和Chrome）。因此，建议为*也*运行在实际的浏览器测试套件曾经在一段时间。"

#: ../../reference/javascript.rst:1361
msgid ""
"The version of PhantomJS_ this was build through is 1.7, previous versions "
"*should* work but are not actually supported (and tend to just segfault when"
" something goes wrong in PhantomJS_ itself so they're a pain to debug)."
msgstr "PhantomJS_的版本，这是通过构建是1.7，以前的版本*应*工作，但实际上并没有支持（而且往往只是段错误的时候出现错误的PhantomJS_本身，以便他们是一个痛苦的调试）。"

#: ../../reference/javascript.rst:1366
msgid ""
"Install a new database with all relevant modules (all modules with a web "
"component at least), then restart the server"
msgstr "安装与所有相关的模块，一个新的数据库（至少一个网络组件的所有模块），然后重新启动服务器"

#: ../../reference/javascript.rst:1371
msgid ""
"For some tests, a source database needs to be duplicated. This operation "
"requires that there be no connection to the database being duplicated, but "
"Odoo doesn't currently break existing/outstanding connections, so restarting"
" the server is the simplest way to ensure everything is in the right state."
msgstr "对于一些测试，源数据库需要被复制。此操作要求有与数据库连接不被复制，但Odoo目前不破坏现有/未完成的连接，所以重新启动服务器，以确保一切都在正确的状态，最简单的方法。"

#: ../../reference/javascript.rst:1377
msgid ""
"Launch ``oe run-tests -d $DATABASE -mweb`` with the correct addons-path "
"specified (and replacing ``$DATABASE`` by the source database you created "
"above)"
msgstr "启动``OE运行测试-d $ DATABASE -mweb``，使用正确的插件路径（和替换``$ DATABASE``通过上面创建的源数据库）"

#: ../../reference/javascript.rst:1383
msgid ""
"If you leave out ``-mweb``, the runner will attempt to run all the tests in "
"all the modules, which may or may not work."
msgstr "如果你离开了``-mweb``，亚军将尝试在所有的模块，这可能会或可能无法正常工作运行所有测试。"

#: ../../reference/javascript.rst:1386
msgid ""
"If everything went correctly, you should now see a list of tests with "
"(hopefully) ``ok`` next to their names, closing with a report of the number "
"of tests run and the time it took:"
msgstr "如果一切正常，你现在应该看到的测试与列表（希望）``ok``他们的名字旁边，缩小与试验次数的报告运行，并花时间："

#: ../../reference/javascript.rst:1393
msgid ""
"Congratulation, you have just performed a successful \"offline\" run of the "
"OpenERP Web test suite."
msgstr "恭喜你，你刚刚成功执行了\“离线\”的OpenERP的Web测试套件的运行。"

#: ../../reference/javascript.rst:1398
msgid ""
"Note that this runs all the Python tests for the ``web`` module, but all the"
" web tests for all of Odoo. This can be surprising."
msgstr "请注意，此运行所有的Python测试的``web``模块，但所有的Web测试所有Odoo的。这可能是令人惊讶的。"

#: ../../reference/javascript.rst:1411
msgid "not all DOM events are compatible with events delegation"
msgstr "不是所有的DOM事件与事件代表团兼容"

#: ../../reference/javascript.rst:1414
msgid ""
"with a small twist: :py:meth:`sqlalchemy.orm.query.Query.group_by` is not "
"terminal, it returns a query which can still be altered."
msgstr "与一小搓：：PY：甲：`sqlalchem​​y.orm.query.Query.group_by`不是终端，它返回它仍然可以改变的查询。"

#: ../../reference/module.rst:5
msgid "Modules"
msgstr "模块"

#: ../../reference/module.rst:12
msgid "Manifest"
msgstr "货单"

#: ../../reference/module.rst:14
msgid ""
"The manifest file serves to declare a python package as an Odoo module and "
"to specify module metadata."
msgstr "清单文件用于声明一个Python包作为Odoo模块，并指定模块的元数据。"

#: ../../reference/module.rst:17
msgid ""
"It is a file called ``__openerp__.py`` and contains a single Python "
"dictionary, where each key specifies module metadatum."
msgstr "这是一个被称为``__openerp __。py``文件，并包含一个Python字典，其中每个键指定模块metadatum。"

#: ../../reference/module.rst:41
msgid "Available manifest fields are:"
msgstr "可用清单字段有："

#: ../../reference/module.rst:43
msgid "``name`` (``str``, required)"
msgstr "``name``（``str``，必需）"

#: ../../reference/module.rst:44
msgid "the human-readable name of the module"
msgstr "模块的人类可读名称"

#: ../../reference/module.rst:45
msgid "``version`` (``str``)"
msgstr "``version``（``str``）"

#: ../../reference/module.rst:46
msgid "this module's version, should follow `semantic versioning`_ rules"
msgstr "该模块的版本，应该遵循`语义versioning`_规则"

#: ../../reference/module.rst:47
msgid "``description`` (``str``)"
msgstr "``description``（``str``）"

#: ../../reference/module.rst:48
msgid "extended description for the module, in reStructuredText"
msgstr "扩展描述为模块，在reStructuredText的"

#: ../../reference/module.rst:49
msgid "``author`` (``str``)"
msgstr "``author``（``str``）"

#: ../../reference/module.rst:50
msgid "name of the module author"
msgstr "的模块作者姓名"

#: ../../reference/module.rst:51
msgid "``website`` (``str``)"
msgstr "``website``（``str``）"

#: ../../reference/module.rst:52
msgid "website URL for the module author"
msgstr "网站的网址为模块作者"

#: ../../reference/module.rst:53
msgid "``license`` (``str``, defaults: ``AGPL-3``)"
msgstr "``license``（``str``，默认值：``AGPL-3``）"

#: ../../reference/module.rst:54
msgid "distribution license for the module"
msgstr "该模块分发许可证"

#: ../../reference/module.rst:61
msgid "``category`` (``str``, default: ``Uncategorized``)"
msgstr "``category``（``str``，默认：``Uncategorized``）"

#: ../../reference/module.rst:56
msgid ""
"classification category within Odoo, rough business domain for the module."
msgstr "在Odoo分类类别，该模块粗糙的业务领域。"

#: ../../reference/module.rst:58
msgid ""
"Although using `existing categories`_ is recommended, the field is freeform "
"and unknown categories are created on-the-fly. Category hierarchies can be "
"created using the separator ``/`` e.g. ``Foo / Bar`` will create a category "
"``Foo``, a category ``Bar`` as child category of ``Foo``, and will set "
"``Bar`` as the module's category."
msgstr "虽然使用`现有categories`_建议，该字段为自由和未知类别的即时创建。可以使用分离器``创建类别层次结构/``如``美孚/ Bar``将创建类``Foo``，一类``Bar``为``Foo``子类，并将设置``Bar``作为模块的类别。"

#: ../../reference/module.rst:68
msgid "``depends`` (``list(str)``)"
msgstr "``depends``（``名单（STR）``）"

#: ../../reference/module.rst:64
msgid ""
"Odoo modules which must be loaded before this one, either because this "
"module uses features they create or because it alters resources they define."
msgstr "必须这个之前加载，或者是因为该模块使用他们所创造的功能或者是因为它改变了资源，他们定义Odoo模块。"

#: ../../reference/module.rst:68
msgid ""
"When a module is installed, all of its dependencies are installed before it."
" Likewise dependencies are loaded before a module is loaded."
msgstr "当安装一个模块，其所有相关之前安装。同样地，一个模块被加载之前，依赖被加载。"

#: ../../reference/module.rst:71
msgid "``data`` (``list(str)``)"
msgstr "``data``（``名单（STR）``）"

#: ../../reference/module.rst:71
msgid ""
"List of data files which must always be installed or updated with the "
"module. A list of paths from the module root directory"
msgstr "的必须始终安装或更新与模块数据文件列表。路径从模块根目录清单"

#: ../../reference/module.rst:74
msgid "``demo`` (``list(str)``)"
msgstr "``demo``（``名单（STR）``）"

#: ../../reference/module.rst:74
msgid ""
"List of data files which are only installed or updated in *demonstration "
"mode*"
msgstr "哪只安装或*演示模式更新的数据文件列表*"

#: ../../reference/module.rst:86
msgid "``auto_install`` (``bool``, default: ``False``)"
msgstr "``auto_install``（``bool``，默认：``False``）"

#: ../../reference/module.rst:77
msgid ""
"If ``True``, this module will automatically be installed if all of its "
"dependencies are installed."
msgstr "如果``True``，那么这个模块将被自动如果所有的依赖也都安装安装。"

#: ../../reference/module.rst:80
msgid ""
"It is generally used for \"link modules\" implementing synergic integration "
"between two otherwise independent modules."
msgstr "它一般用于\“链接模块\”执行两个原本独立模块之间协同集成。"

#: ../../reference/module.rst:83
msgid ""
"For instance ``sale_crm`` depends on both ``sale`` and ``crm`` and is set to"
" ``auto_install``. When both ``sale`` and ``crm`` are installed, it "
"automatically adds CRM campaigns tracking to sale orders without either "
"``sale`` or ``crm`` being aware of one another"
msgstr "例如``sale_crm``取决于双方``sale``和``crm``并设置为``auto_install``。当两个``sale``和``安装crm``，它会自动将客户关系管理的运动跟踪到销售订单没有任何``sa​​le``或``crm``意识到彼此"

#: ../../reference/orm.rst:7
msgid "ORM API"
msgstr "ORM API"

#: ../../reference/orm.rst:10
msgid "Recordsets"
msgstr "记录集"

#: ../../reference/orm.rst:14
msgid ""
"This page documents the New API added in Odoo 8.0 which should be the "
"primary development API going forward. It also provides information about "
"porting from or bridging with the \"old API\" of versions 7 and earlier, but"
" does not explicitly document that API. See the old documentation for that."
msgstr "这页记录了新的API中Odoo 8.0加入这应该是主要的开发API前进。它也提供了有关从早期移植或与版本7的\“旧的API \”桥接和信息，但没有明确记载该API。看到老文档的。"

#: ../../reference/orm.rst:19
msgid ""
"Interaction with models and records is performed through recordsets, a "
"sorted set of records of the same model."
msgstr "配车型和记录交互是通过记录集执行，有序集合的同一型号的记录。"

#: ../../reference/orm.rst:22
msgid ""
"contrary to what the name implies, it is currently possible for recordsets "
"to contain duplicates. This may change in the future."
msgstr "相反的是顾名思义，它是目前可能的记录包含重复。这可能会改变未来。"

#: ../../reference/orm.rst:25
msgid ""
"Methods defined on a model are executed on a recordset, and their ``self`` "
"is a recordset::"
msgstr "在模型中定义的方法是在一个记录执行的，他们的``self``是一个记录::"

#: ../../reference/orm.rst:35
msgid ""
"Iterating on a recordset will yield new sets of *a single record* "
"(\"singletons\"), much like iterating on a Python string yields strings of a"
" single characters::"
msgstr "在迭代的记录将产生的*单个记录*新集（\“单身\”），很像迭代在Python字符串的单个字符的字符串收益率::"

#: ../../reference/orm.rst:45
msgid "Field access"
msgstr "现场访问"

#: ../../reference/orm.rst:47
msgid ""
"Recordsets provide an \"Active Record\" interface: model fields can be read "
"and written directly from the record, but only on singletons (single-record "
"recordsets). Setting a field's value triggers an update to the database::"
msgstr "记录集提供了一个\“活动记录\”界面：示范田可以读取并直接从记录写的，但仅限于单件（单记录的记录）。设置字段的值触发更新到数据库::"

#: ../../reference/orm.rst:57
msgid ""
"Trying to read or write a field on multiple records will raise an error."
msgstr "尝试在多个记录读或写一个字段将产生一个错误。"

#: ../../reference/orm.rst:59
msgid ""
"Accessing a relational field (:class:`~openerp.fields.Many2one`, "
":class:`~openerp.fields.One2many`, :class:`~openerp.fields.Many2many`) "
"*always* returns a recordset, empty if the field is not set."
msgstr "访问关系领域（类别：`〜openerp.fields.Many2one`，产品类别：`〜openerp.fields.One2many`，产品类别：`〜openerp.fields.Many2many`）*总*返回记录集，空if现场未设置。"

#: ../../reference/orm.rst:65
msgid ""
"each assignment to a field triggers a database update, when setting multiple"
" fields at the same time or setting fields on multiple records (to the same "
"value), use :meth:`~openerp.models.Model.write`::"
msgstr "每个分配到一个场触发数据库更新，设置多个字段同时时或设置在多个记录中的字段（为相同的值），使用：甲基：`〜openerp.models.Model.write` ::"

#: ../../reference/orm.rst:83
msgid "Set operations"
msgstr "设置操作"

#: ../../reference/orm.rst:85
msgid ""
"Recordsets are immutable, but sets of the same model can be combined using "
"various set operations, returning new recordsets. Set operations do *not* "
"preserve order."
msgstr "记录集是不可变的，但台同型号的可以使用各种集合运算结合起来，返回新的记录集。 Set操作*不*维持秩序。"

#: ../../reference/orm.rst:91
msgid ""
"``record in set`` returns whether ``record`` (which must be a 1-element "
"recordset) is present in ``set``. ``record not in set`` is the inverse "
"operation"
msgstr "``在set``记录返回是否``record``（必须是1元的记录）出现在``set``。 ``不set``记录是反向操作"

#: ../../reference/orm.rst:94
msgid ""
"``set1 | set2`` returns the union of the two recordsets, a new recordset "
"containing all records present in either source"
msgstr "``集1 | set2``返回两个记录的结合，包含目前在这两个源的所有记录的新记录"

#: ../../reference/orm.rst:96
msgid ""
"``set1 & set2`` returns the intersection of two recordsets, a new recordset "
"containing only records present in both sources"
msgstr "``集1＆set2``返回两个记录集的交集，包括存在于源只记录了一个新的记录"

#: ../../reference/orm.rst:98
msgid ""
"``set1 - set2`` returns a new recordset containing only records of ``set1`` "
"which are *not* in ``set2``"
msgstr "``集1  -  set2``返回包含``set1``只有那些*没有`*记录的新记录`set2``"

#: ../../reference/orm.rst:102
msgid "Other recordset operations"
msgstr "其他记录操作"

#: ../../reference/orm.rst:104
msgid ""
"Recordsets are iterable so the usual Python tools are available for "
"transformation (:func:`python:map`, :func:`python:sorted`, "
":func:`~python:itertools.ifilter`, ...) however these return either a "
":class:`python:list` or an :term:`python:iterator`, removing the ability to "
"call methods on their result, or to use set operations."
msgstr "记录集是可迭代所以平时Python的工具可用于改造（：FUNC：`蟒蛇：map`，：FUNC：`蟒蛇：sorted`，：FUNC：`〜蟒蛇：itertools.ifilter`，...），但这些收益或者是：类：`蟒蛇：list`或：期限：`蟒蛇：iterator`，除去调用他们的结果的方法，或者采用集合运算的能力。"

#: ../../reference/orm.rst:110
msgid ""
"Recordsets therefore provide these operations returning recordsets "
"themselves (when possible):"
msgstr "因此，记录集提供这些操作返回记录本身（如果可能）："

#: ../../reference/orm.rst:122
msgid ":meth:`~openerp.models.Model.filtered`"
msgstr "：甲：`〜openerp.models.Model.filtered`"

#: ../../reference/orm.rst:114
msgid ""
"returns a recordset containing only records satisfying the provided "
"predicate function. The predicate can also be a string to filter by a field "
"being true or false::"
msgstr "返回一个包含只记录满足谓词提供的功能的记录。谓词也可以是一个字符串由场筛选为真或假的::"

#: ../../reference/orm.rst:129
msgid ":meth:`~openerp.models.Model.sorted`"
msgstr "：甲：`〜openerp.models.Model.sorted`"

#: ../../reference/orm.rst:125
msgid ""
"returns a recordset sorted by the provided key function. If no key is "
"provided, use the model's default sort order::"
msgstr "返回记录集排序所提供的关键功能。如果不提供密钥，使用模型的默认排序次序::"

#: ../../reference/orm.rst:147
msgid ":meth:`~openerp.models.Model.mapped`"
msgstr "：甲：`〜openerp.models.Model.mapped`"

#: ../../reference/orm.rst:132
msgid ""
"applies the provided function to each record in the recordset, returns a "
"recordset if the results are recordsets::"
msgstr "应用所提供的功能，在记录每个记录，返回记录集，如果结果记录集::"

#: ../../reference/orm.rst:138
msgid "The provided function can be a string to get field values::"
msgstr "所提供的功能可以是一个字符串，以获取字段值::"

#: ../../reference/orm.rst:150
msgid "Environment"
msgstr "环境"

#: ../../reference/orm.rst:152
msgid ""
"The :class:`~openerp.api.Environment` stores various contextual data used by"
" the ORM: the database cursor (for database queries), the current user (for "
"access rights checking) and the current context (storing arbitrary "
"metadata). The environment also stores caches."
msgstr "的：类：`〜所使用的ORM openerp.api.Environment`存储各种上下文数据：数据库光标（数据库查询），当前用户（用于访问权限检查），当前的上下文（存储任意元数据）。环境还存储高速缓存。"

#: ../../reference/orm.rst:157
msgid ""
"All recordsets have an environment, which is immutable, can be accessed "
"using :attr:`~openerp.models.Model.env` and gives access to the current user"
" (:attr:`~openerp.api.Environment.user`), the cursor "
"(:attr:`~openerp.api.Environment.cr`) or the context "
"(:attr:`~openerp.api.Environment.context`)::"
msgstr "所有记录集有一个环境，这是不可改变的，可以使用访问：ATTR：`〜openerp.models.Model.env`并允许访问当前用户（：ATTR：`〜openerp.api.Environment.user`）光标（：ATTR：`〜openerp.api.Environment.cr`）或上下文（：ATTR：`〜openerp.api.Environment.context`）::"

#: ../../reference/orm.rst:170
msgid ""
"When creating a recordset from an other recordset, the environment is "
"inherited. The environment can be used to get an empty recordset in an other"
" model, and query that model::"
msgstr "当创建从其他记录的记录，环境被继承。环境还可以用于获取在其他模型中一个空的记录，并查询该型号::"

#: ../../reference/orm.rst:180
msgid "Altering the environment"
msgstr "改变环境"

#: ../../reference/orm.rst:182
msgid ""
"The environment can be customized from a recordset. This returns a new "
"version of the recordset using the altered environment."
msgstr "环境可以从一个记录进行定制。这将返回使用改变环境记录的新版本。"

#: ../../reference/orm.rst:196
msgid ":meth:`~openerp.models.Model.sudo`"
msgstr "：甲：`〜openerp.models.Model.sudo`"

#: ../../reference/orm.rst:186
msgid ""
"creates a new environment with the provided user set, uses the administrator"
" if none is provided (to bypass access rights/rules in safe contexts), "
"returns a copy of the recordset it is called on using the new environment::"
msgstr "创建与所提供的用户设置一个新的环境，使用系统管理员如果没有提供（旁路存取权限/在安全上下文中的规则），返回它被称为使用新的环境记录的副本::"

#: ../../reference/orm.rst:208
msgid ":meth:`~openerp.models.Model.with_context`"
msgstr "：甲：`〜openerp.models.Model.with_context`"

#: ../../reference/orm.rst:199
msgid ""
"can take a single positional parameter, which replaces the current "
"environment's context"
msgstr "可以采取一个位置参数，它取代了当前环境的上下文"

#: ../../reference/orm.rst:201
msgid ""
"can take any number of parameters by keyword, which are added to either the "
"current environment's context or the context set during step 1"
msgstr "可以采取任何数量的按关键词参数，它们被加入到任何当前环境的上下文或上下文在步骤1设置"

#: ../../reference/orm.rst:211
msgid ":meth:`~openerp.models.Model.with_env`"
msgstr "：甲：`〜openerp.models.Model.with_env`"

#: ../../reference/orm.rst:211
msgid "replaces the existing environment entirely"
msgstr "取代了现有的环境完全"

#: ../../reference/orm.rst:214
msgid "Common ORM methods"
msgstr "常见的ORM方法"

#: ../../reference/orm.rst:230
msgid ":meth:`~openerp.models.Model.search`"
msgstr "：甲：`〜openerp.models.Model.search`"

#: ../../reference/orm.rst:219
msgid ""
"Takes a :ref:`search domain <reference/orm/domains>`, returns a recordset of"
" matching records. Can return a subset of matching records (``offset`` and "
"``limit`` parameters) and be ordered (``order`` parameter)::"
msgstr "需要：参考：`搜索域<参考/ ORM /域>`，返回匹配记录的记录。可以返回匹配记录的一个子集（``offset``和``limit``参数）并责令（``order``参数）::"

#: ../../reference/orm.rst:229
msgid ""
"to just check if any record matches a domain, or count the number of records"
" which do, use :meth:`~openerp.models.Model.search_count`"
msgstr "只是检查是否有任何记录中域相匹配，或计数的记录里面做数量，用途：甲：`〜openerp.models.Model.search_count`"

#: ../../reference/orm.rst:237
msgid ":meth:`~openerp.models.Model.create`"
msgstr "：甲：`〜openerp.models.Model.create`"

#: ../../reference/orm.rst:233
msgid ""
"Takes a number of field values, and returns a recordset containing the "
"record created::"
msgstr "采用数字字段的值，然后返回一个包含创建的记录的记录集::"

#: ../../reference/orm.rst:243
msgid ":meth:`~openerp.models.Model.write`"
msgstr "：甲：`〜openerp.models.Model.write`"

#: ../../reference/orm.rst:240
msgid ""
"Takes a number of field values, writes them to all the records in its "
"recordset. Does not return anything::"
msgstr "采用数字字段的值，并将其写入到其记录的所有记录。不返回任何东西::"

#: ../../reference/orm.rst:252
msgid ":meth:`~openerp.models.Model.browse`"
msgstr "：甲：`〜openerp.models.Model.browse`"

#: ../../reference/orm.rst:246
msgid ""
"Takes a database id or a list of ids and returns a recordset, useful when "
"record ids are obtained from outside Odoo (e.g. round-trip through external "
"system) or :ref:`when calling methods in the old API "
"<reference/orm/oldapi>`::"
msgstr "采用的是数据库ID或ID的列表，并返回一个记录，用时记录ID从获得Odoo外（例如，通过外部系统往返）或：参考：`调用旧的API <方法时，参考/ ORM / oldapi >`::"

#: ../../reference/orm.rst:266
msgid ":meth:`~openerp.models.Model.exists`"
msgstr "：甲：`〜openerp.models.Model.exists`"

#: ../../reference/orm.rst:255
msgid ""
"Returns a new recordset containing only the records which exist in the "
"database. Can be used to check whether a record (e.g. obtained externally) "
"still exists::"
msgstr "返回一个只包含在数据库中存在的记录的新记录。可用于检查记录（如外部获得）是否仍然存在::"

#: ../../reference/orm.rst:262
msgid "or after calling a method which could have removed some records::"
msgstr "或者调用一个方法可能已删除了部分记录后::"

#: ../../reference/orm.rst:273
msgid ":meth:`~openerp.api.Environment.ref`"
msgstr "：甲：`〜openerp.api.Environment.ref`"

#: ../../reference/orm.rst:269
msgid ""
"Environment method returning the record matching a provided :term:`external "
"id`::"
msgstr "环境方法返回的记录匹配提供：术语：`外部ID` ::"

#: ../../reference/orm.rst:281
msgid ":meth:`~openerp.models.Model.ensure_one`"
msgstr "：甲：`〜openerp.models.Model.ensure_one`"

#: ../../reference/orm.rst:276
msgid ""
"checks that the recordset is a singleton (only contains a single record), "
"raises an error otherwise::"
msgstr "检查该记录是单（只包含一个记录），否则会引发错误::"

#: ../../reference/orm.rst:284
msgid "Creating Models"
msgstr "创建模型"

#: ../../reference/orm.rst:286
msgid "Model fields are defined as attributes on the model itself::"
msgstr "模型字段被定义为在模型本身的属性::"

#: ../../reference/orm.rst:294
msgid ""
"this means you can not define a field and a method with the same name, they "
"will conflict"
msgstr "这意味着你不能定义一个字段，并使用相同的名称的方法，他们会发生冲突"

#: ../../reference/orm.rst:297
msgid ""
"By default, the field's label (user-visible name) is a capitalized version "
"of the field name, this can be overridden with the ``string`` parameter::"
msgstr "默认情况下，该领域的标签（用户可见的名字）是字段名称的大写版本，这可以用``string``参数覆盖::"

#: ../../reference/orm.rst:302
msgid ""
"For the various field types and parameters, see :ref:`the fields reference "
"<reference/orm/fields>`."
msgstr "对于这些不同的字段类型和参数，请参阅：参考：`领域的参考<参考/ ORM /域>`。"

#: ../../reference/orm.rst:305
msgid "Default values are defined as parameters on fields, either a value::"
msgstr "缺省值被定义为在字段参数，一个值::"

#: ../../reference/orm.rst:309
msgid ""
"or a function called to compute the default value, which should return that "
"value::"
msgstr "或称为一个函数来计算的默认值，这应该返回值::"

#: ../../reference/orm.rst:317 ../../../openerp/fields.pydocstring of
#: openerp.fields.Field:42
msgid "Computed fields"
msgstr "计算领域"

#: ../../reference/orm.rst:319
msgid ""
"Fields can be computed (instead of read straight from the database) using "
"the ``compute`` parameter. **It must assign the computed value to the "
"field**. If it uses the values of other *fields*, it should specify those "
"fields using :func:`~openerp.api.depends`::"
msgstr "字段可以计算（而不是直接来自于数据库读取）使用``compute``参数。 **必须的计算值分配给现场**。如果使用其他*领域*的值，就应该使用指定的字段：FUNC：`〜openerp.api.depends` ::"

#: ../../reference/orm.rst:332
msgid "dependencies can be dotted paths when using sub-fields::"
msgstr "依赖关系可以使用子字段时加以点缀路径::"

#: ../../reference/orm.rst:339
msgid ""
"computed fields are not stored by default, they are computed and returned "
"when requested. Setting ``store=True`` will store them in the database and "
"automatically enable searching"
msgstr "计算字段不默认存储，它们计算时要求返回。设置``店= True``将它们存储在数据库中，自动启用搜索"

#: ../../reference/orm.rst:342
msgid ""
"searching on a computed field can also be enabled by setting the ``search`` "
"parameter. The value is a method name returning a "
":ref:`reference/orm/domains`::"
msgstr "搜索上一计算字段也可以通过设置``search``参数启用。该值是一个方法名返回：参考：`参考/ ORM / domains` ::"

#: ../../reference/orm.rst:353
msgid ""
"to allow *setting* values on a computed field, use the ``inverse`` "
"parameter. It is the name of a function reversing the computation and "
"setting the relevant fields::"
msgstr "让*设置*上的计算字段的值，使用``inverse``参数。它是一个函数的名称反转的计算和设定相关领域::"

#: ../../reference/orm.rst:369
msgid ""
"multiple fields can be computed at the same time by the same method, just "
"use the same method on all fields and set all of them::"
msgstr "多个字段可以在同一时间通过相同的方法来计算，只要使用相同的方法在所有的字段，设置所有这些::"

#: ../../reference/orm.rst:384 ../../../openerp/fields.pydocstring of
#: openerp.fields.Field:109
msgid "Related fields"
msgstr "相关领域"

#: ../../reference/orm.rst:386
msgid ""
"A special case of computed fields are *related* (proxy) fields, which "
"provide the value of a sub-field on the current record. They are defined by "
"setting the ``related`` parameter and like regular computed fields they can "
"be stored::"
msgstr "计算字段的特殊情况是* *相关（代理）字段，其提供的子场对当前记录的值。它们通过将``related``参数和类似的定期计算的领域中定义，它们可以存储::"

#: ../../reference/orm.rst:394
msgid "onchange: updating UI on the fly"
msgstr "的onchange：在飞行中更新UI"

#: ../../reference/orm.rst:396
msgid ""
"When a user changes a field's value in a form (but hasn't saved the form "
"yet), it can be useful to automatically update other fields based on that "
"value e.g. updating a final total when the tax is changed or a new invoice "
"line is added."
msgstr "当用户在表单中改变字段的值（但还没有保存形式还），它可能是有用的基于该值，例如更新最后总当税收被更改或新的发票行是自动更新等领域添加。"

#: ../../reference/orm.rst:401
msgid ""
"computed fields are automatically checked and recomputed, they do not need "
"an ``onchange``"
msgstr "计算字段自动检查并重新计算，他们并不需要一个``onchange``"

#: ../../reference/orm.rst:403
msgid ""
"for non-computed fields, the :func:`~openerp.api.onchange` decorator is used"
" to provide new field values::"
msgstr "对于非计算领域，：函数：`〜openerp.api.onchange`装饰器用于提供新的字段值::"

#: ../../reference/orm.rst:411
msgid ""
"the changes performed during the method are then sent to the client program "
"and become visible to the user"
msgstr "该方法的过程中进行的变化，然后发送到客户端程序，并成为对用户可见"

#: ../../reference/orm.rst:414
msgid ""
"Both computed fields and new-API onchanges are automatically called by the "
"client without having to add them in views"
msgstr "这两种计算领域和新的API onchanges是由客户端自动调用，而无需添加他们的意见"

#: ../../reference/orm.rst:416
msgid ""
"It is possible to suppress the trigger from a specific field by adding "
"``on_change=\"0\"`` in a view::"
msgstr "有可能通过在视图中加入``on_change = \“0 \”``抑制从一个特定字段触发::"

#: ../../reference/orm.rst:421
msgid ""
"will not trigger any interface update when the field is edited by the user, "
"even if there are function fields or explicit onchange depending on that "
"field."
msgstr "将不触发任何界面更新时的电场是由用户编​​辑，即使有功能字段或显式的onchange取决于该字段。"

#: ../../reference/orm.rst:427
msgid ""
"``onchange`` methods work on virtual records assignment on these records is "
"not written to the database, just used to know which value to send back to "
"the client"
msgstr "``onchange``方法对转让对这些记录不会被写入到数据库虚拟的记录工作，只用了才知道要发送的值返回给客户端"

#: ../../reference/orm.rst:432
msgid "Low-level SQL"
msgstr "低级别的SQL"

#: ../../reference/orm.rst:434
msgid ""
"The :attr:`~openerp.api.Environment.cr` attribute on environments is the "
"cursor for the current database transaction and allows executing SQL "
"directly, either for queries which are difficult to express using the ORM "
"(e.g. complex joins) or for performance reasons::"
msgstr "本：ATTR：`〜openerp.api.Environment.cr`对环境属性是光标用于当前数据库事务，并允许直接执行SQL语句，无论是查询这是很难用ORM来表达（如复杂的连接）或性能原因::"

#: ../../reference/orm.rst:441
msgid ""
"Because models use the same cursor and the :class:`~openerp.api.Environment`"
" holds various caches, these caches must be invalidated when *altering* the "
"database in raw SQL, or further uses of models may become incoherent. It is "
"necessary to clear caches when using ``CREATE``, ``UPDATE`` or ``DELETE`` in"
" SQL, but not ``SELECT`` (which simply reads the database)."
msgstr "由于车型使用相同的光标和：类：`〜openerp.api.Environment`拥有多项高速缓存，这些缓存必须失效时，*改变*原始SQL或模型进一步使用的数据库可能会变得语无伦次。它在使用``CREATE``，``UPDATE``或``DELETE``在SQL，而不是``SELECT``（只读取数据库）必须清除缓存。"

#: ../../reference/orm.rst:447
msgid ""
"Clearing caches can be performed using the "
":meth:`~openerp.api.Environment.invalidate_all` method of the "
":class:`~openerp.api.Environment` object."
msgstr "甲：类：的`〜openerp.api.Environment.invalidate_all`方法`〜openerp.api.Environment`对象清除缓存可以使用进行。"

#: ../../reference/orm.rst:455
msgid "Compatibility between new API and old API"
msgstr "新的API和旧的API之间的兼容性"

#: ../../reference/orm.rst:457
msgid ""
"Odoo is currently transitioning from an older (less regular) API, it can be "
"necessary to manually bridge from one to the other manually:"
msgstr "Odoo目前从旧（以下常）的API进行转换，也可以是需要从一个手动的其它手动桥："

#: ../../reference/orm.rst:460
msgid ""
"RPC layers (both XML-RPC and JSON-RPC) are expressed in terms of the old "
"API, methods expressed purely in the new API are not available over RPC"
msgstr "RPC层（既XML-RPC和JSON-RPC）表达于旧的API而言，方法表示纯粹在新的API不可通过RPC"

#: ../../reference/orm.rst:462
msgid ""
"overridable methods may be called from older pieces of code still written in"
" the old API style"
msgstr "重写的方法可以从旧的代码块仍然写在旧的​​API的风格被称为"

#: ../../reference/orm.rst:465
msgid "The big differences between the old and new APIs are:"
msgstr "旧的和新的API之间最大的区别是："

#: ../../reference/orm.rst:467
msgid ""
"values of the :class:`~openerp.api.Environment` (cursor, user id and "
"context) are passed explicitly to methods instead"
msgstr "类：值​​`〜openerp.api.Environment`（光标，用户ID和上下文）明确传递给方法，而不是"

#: ../../reference/orm.rst:469
msgid ""
"record data (:attr:`~openerp.models.Model.ids`) are passed explicitly to "
"methods, and possibly not passed at all"
msgstr "记录数据（：ATTR：`〜openerp.models.Model.ids`）明确地传递给方法，并有可能不通过所有"

#: ../../reference/orm.rst:471
msgid "methods tend to work on lists of ids instead of recordsets"
msgstr "方法往往工作的ID，而不是记录集列表"

#: ../../reference/orm.rst:473
msgid ""
"By default, methods are assumed to use the new API style and are not "
"callable from the old API style."
msgstr "默认情况下，方法假定使用新的API风格，并没有从旧的API风格调用。"

#: ../../reference/orm.rst:476
msgid "calls from the new API to the old API are bridged"
msgstr "从新的API将旧的API调用桥"

#: ../../reference/orm.rst:479
msgid ""
"when using the new API style, calls to methods defined using the old API are"
" automatically converted on-the-fly, there should be no need to do anything "
"special::"
msgstr "在使用新的API的风格，调用定义使用旧的API将被自动转换在即时方法，应该没有必要做什么特别的事情::"

#: ../../reference/orm.rst:496
msgid "Two decorators can expose a new-style method to the old API:"
msgstr "两个装饰可以公开一种新型的方法将旧的API："

#: ../../reference/orm.rst:506
msgid ":func:`~openerp.api.model`"
msgstr "：FUNC：`〜openerp.api.model`"

#: ../../reference/orm.rst:499
msgid ""
"the method is exposed as not using ids, its recordset will generally be "
"empty. Its \"old API\" signature is ``cr, uid, *arguments, context``::"
msgstr "该方法作为不使用的ID暴露出来，它的记录集将通常为空。它的\“旧的API \”签名是``CR，UID，*参数，context`` ::"

#: ../../reference/orm.rst:516
msgid ":func:`~openerp.api.multi`"
msgstr "：FUNC：`〜openerp.api.multi`"

#: ../../reference/orm.rst:509
msgid ""
"the method is exposed as taking a list of ids (possibly empty), its \"old "
"API\" signature is ``cr, uid, ids, *arguments, context``::"
msgstr "该方法公开采取IDS（可能为空）的列表，它的\“旧的API \”签名是``CR，UID，IDS，*参数，context`` ::"

#: ../../reference/orm.rst:518
msgid ""
"Because new-style APIs tend to return recordsets and old-style APIs tend to "
"return lists of ids, there is also a decorator managing this:"
msgstr "因为新的风格​​的API趋于返回的记录和旧式的API趋于返回id的列表，也有一个装饰管理此："

#: ../../reference/orm.rst:537
msgid ":func:`~openerp.api.returns`"
msgstr "：FUNC：`〜openerp.api.returns`"

#: ../../reference/orm.rst:522
msgid ""
"the function is assumed to return a recordset, the first parameter should be"
" the name of the recordset's model or ``self`` (for the current model)."
msgstr "该功能被假定为返回记录集，第一个参数应该是记录的模型或``self``（当前模型）的名称。"

#: ../../reference/orm.rst:525
msgid ""
"No effect if the method is called in new API style, but transforms the "
"recordset into a list of ids when called from the old API style::"
msgstr "没有，如果该方法被称为新的API的风格，但是转换记录成ID列表从旧风​​格的API调用时的效果::"

#: ../../reference/orm.rst:542
msgid "Model Reference"
msgstr "模型参考"

#: ../../../openerp/models.pydocstring of openerp.models.Model:1
msgid "Main super-class for regular database-persisted OpenERP models."
msgstr "主要超一流定期数据库持久化OpenERP的车型。"

#: ../../../openerp/models.pydocstring of openerp.models.Model:3
msgid "OpenERP models are created by inheriting from this class::"
msgstr "OpenERP的模型是由从这个类继承创建::"

#: ../../../openerp/models.pydocstring of openerp.models.Model:8
msgid ""
"The system will later instantiate the class once per database (on which the "
"class' module is installed)."
msgstr "该系统将在后面实例（安装类的模块上）每一次数据库的类。"

#: ../../reference/orm.rst:552
msgid "Structural attributes"
msgstr "结构属性"

#: ../../reference/orm.rst:555
msgid "business object name, in dot-notation (in module namespace)"
msgstr "业务对象的名称，在点标记法（模块命名空间）"

#: ../../reference/orm.rst:559
msgid ""
"Alternative field to use as name, used by osv’s name_get() (default: "
"``'name'``)"
msgstr "替代领域的名称使用，使用OSV的name_get（）（默认值：``'name'``）"

#: ../../reference/orm.rst:564
msgid ""
"If :attr:`._name` is set, names of parent models to inherit from. Can be a "
"``str`` if inheriting from a single parent"
msgstr "如果：ATTR：`._name`设置，家长型号名称要继承。可以是一个``str``如果来自一个单亲继承"

#: ../../reference/orm.rst:566
msgid "If :attr:`._name` is unset, name of a single model to extend in-place"
msgstr "如果：ATTR：`._name`没有设置，以就地扩展一个车型名称"

#: ../../reference/orm.rst:569
msgid "See :ref:`reference/orm/inheritance`."
msgstr "请参阅：参考：`参考/ ORM / inheritance`。"

#: ../../reference/orm.rst:573
msgid ""
"Ordering field when searching without an ordering specified (default: "
"``'id'``)"
msgstr "没有指定的顺序进行搜索时，订购场（默认：``'id'``）"

#: ../../reference/orm.rst:576
msgid "str"
msgstr "海峡"

#: ../../reference/orm.rst:580
msgid "Whether a database table should be created (default: ``True``)"
msgstr "无论是数据库表应该创建（默认值：值为``True``）"

#: ../../reference/orm.rst:582
msgid ""
"If set to ``False``, override :meth:`.init` to create the database table"
msgstr "如果设置为``False``，覆盖：甲：`.init`创建数据库表"

#: ../../reference/orm.rst:587
msgid ""
"Name of the table backing the model created when "
":attr:`~openerp.models.Model._auto`, automatically generated by default."
msgstr "表支持模型的名称创建时：ATTR：`〜openerp.models.Model._auto`，默认自动生成的。"

#: ../../reference/orm.rst:593
msgid ""
"dictionary mapping the _name of the parent business objects to the names of "
"the corresponding foreign key fields to use::"
msgstr "字典映射父业务对象来使用相应的外键字段的名称的_name ::"

#: ../../reference/orm.rst:601
msgid ""
"implements composition-based inheritance: the new model exposes all the "
"fields of the :attr:`~openerp.models.Model._inherits`-ed model but stores "
"none of them: the values themselves remain stored on the linked record."
msgstr "实现了基于合成继承：新模型公开的所有领域：ATTR：`〜他们openerp.models.Model._inherits`-ED模型，但店无：自己仍存储在链接的记录中的值。"

#: ../../reference/orm.rst:608
msgid ""
"if the same field is defined on multiple "
":attr:`~openerp.models.Model._inherits`-ed"
msgstr "ATTR：`〜openerp.models.Model._inherits`-ED如果同样的字段在多个定义"

#: ../../reference/orm.rst:613
msgid ""
"list of ``(constraint_function, message, fields)`` defining Python "
"constraints. The fields list is indicative"
msgstr "中``（constraint_function，消息，域）``定义Python的限制列表。该字段列表指示"

#: ../../reference/orm.rst:618
msgid "use :func:`~openerp.api.constrains`"
msgstr "使用方法：FUNC：`〜openerp.api.constrains`"

#: ../../reference/orm.rst:622
msgid ""
"list of ``(name, sql_definition, message)`` triples defining SQL constraints"
" to execute when generating the backing table"
msgstr "中``（姓名，sql_definition，消息）``名单三倍定义SQL约束生成支持表时执行"

#: ../../reference/orm.rst:627
msgid ""
"Alongside :attr:`~.parent_left` and :attr:`~.parent_right`, sets up a "
"`nested set <http://en.wikipedia.org/wiki/Nested_set_model>`_  to enable "
"fast hierarchical queries on the records of the current model (default: "
"``False``)"
msgstr "除了：ATTR：`〜.parent_left`和：ATTR：`〜.parent_right`，建立了一个`嵌套组<http://en.wikipedia.org/wiki/Nested_set_model>`_来实现快速分层查询的记录当前模式（默认：``False``）"

#: ../../reference/orm.rst:632
msgid "bool"
msgstr "布尔"

#: ../../reference/orm.rst:635
msgid "CRUD"
msgstr "CRUD"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:1
msgid "Creates a new record for the model."
msgstr "创建该模型的新纪录。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:3
msgid ""
"The new record is initialized using the values from ``vals`` and if "
"necessary those from :meth:`~.default_get`."
msgstr "新的记录使用初始化从``vals``值，如有必要，这些来自：甲：`〜.default_get`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:6
msgid ""
"values for the model's fields, as a dictionary::      {'field_name': "
"field_value, ...}  see :meth:`~.write` for details"
msgstr "该模型的字段的值，作为字典:: {'FIELD_NAME“：FIELD_VALUE，...}参见：甲：`〜.write`详细内容"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:7
msgid "values for the model's fields, as a dictionary::"
msgstr "该模型的字段的值，作为字典::"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:11
msgid "see :meth:`~.write` for details"
msgstr "看：甲：`〜.write`详细内容"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:12
msgid "new record created"
msgstr "创造新纪录"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:13
msgid ""
"* if user has no create rights on the requested object * if user tries to "
"bypass access rules for create on the requested object"
msgstr "*如果如果用户试图绕过访问规则创建请求的对象上用户没有创建所请求的对象*权利"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:13
msgid "if user has no create rights on the requested object"
msgstr "如果用户没有创建请求对象的权利"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:14
msgid ""
"if user tries to bypass access rules for create on the requested object"
msgstr "如果用户试图绕过访问规则创建请求的对象上"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:15
#: ../../../openerp/models.pydocstring of openerp.models.Model.write:12
msgid ""
"if user tries to enter invalid value for a field that is not in selection"
msgstr "如果用户尝试输入无效值的字段，是不是在选择"

#: ../../../openerp/models.pydocstring of openerp.models.Model.create:16
#: ../../../openerp/models.pydocstring of openerp.models.Model.write:13
msgid ""
"if a loop would be created in a hierarchy of objects a result of the "
"operation (such as setting an object as its own parent)"
msgstr "如果一个循环将在对象的操作的结果（例如，设置一个对象作为它自己的父）的层次结构被创建"

#: ../../../openerp/models.pydocstring of openerp.models.Model.browse:1
msgid ""
"Returns a recordset for the ids provided as parameter in the current "
"environment."
msgstr "返回记录集在当前的环境作为参数的标识。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.browse:4
msgid "Can take no ids, a single id or a sequence of ids."
msgstr "可拿不出身份证，一个ID或ID的序列。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.unlink:1
msgid "Deletes the records of the current set"
msgstr "删除当前设定的记录"

#: ../../../openerp/models.pydocstring of openerp.models.Model.unlink:3
msgid ""
"* if user has no unlink rights on the requested object * if user tries to "
"bypass access rules for unlink on the requested object"
msgstr "*如果用户对请求的对象*没有取消链接的权利，如果用户试图绕过访问规则取消链接请求的对象上"

#: ../../../openerp/models.pydocstring of openerp.models.Model.unlink:3
msgid "if user has no unlink rights on the requested object"
msgstr "如果用户所请求的对象上没有取消链接权"

#: ../../../openerp/models.pydocstring of openerp.models.Model.unlink:4
msgid ""
"if user tries to bypass access rules for unlink on the requested object"
msgstr "如果用户试图绕过访问规则取消链接请求的对象上"

#: ../../../openerp/models.pydocstring of openerp.models.Model.unlink:5
msgid "if the record is default property for other records"
msgstr "如果记录是默认属性为其他记录"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:1
msgid "Updates all records in the current set with the provided values."
msgstr "更新当前设定的规定值的所有记录。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:3
msgid ""
"fields to update and the value to set on them e.g::      {'foo': 1, 'bar': "
"\"Qux\"}  will set the field ``foo`` to ``1`` and the field ``bar`` to "
"``\"Qux\"`` if those are valid (otherwise it will trigger an error)."
msgstr "字段更新和值对它们设置，例如:: {'富'：1，'巴'：\“Qux \”}将设置字段``foo``到``1``和外地`` bar``到``\“Qux \”``如果这些都有效（否则会引发一个错误）。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:3
msgid "fields to update and the value to set on them e.g::"
msgstr "字段更新和值对它们如设置::"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:7
msgid ""
"will set the field ``foo`` to ``1`` and the field ``bar`` to ``\"Qux\"`` if "
"those are valid (otherwise it will trigger an error)."
msgstr "将设置字段``foo``到``1``和外地``bar``到``\“Qux \”``如果这些都有效（否则会引发一个错误）。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:10
msgid ""
"* if user has no write rights on the requested object * if user tries to "
"bypass access rules for write on the requested object"
msgstr "*如果用户对请求的对象*没有写权限，如果用户试图绕过访问规则写入请求的对象上"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:10
msgid "if user has no write rights on the requested object"
msgstr "如果用户所请求的对象上没有写权限"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:11
msgid "if user tries to bypass access rules for write on the requested object"
msgstr "如果用户试图绕过访问规则的写请求的对象上"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:15
msgid ""
"For numeric fields (:class:`~openerp.fields.Integer`, "
":class:`~openerp.fields.Float`) the value should be of the corresponding "
"type"
msgstr "对于数字字段（：类：`〜openerp.fields.Integer`，产品类别：`〜openerp.fields.Float`）的值应该是对应的类型"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:18
msgid ""
"For :class:`~openerp.fields.Boolean`, the value should be a "
":class:`python:bool`"
msgstr "适用于：类：`〜openerp.fields.Boolean`，该值应该是：类：`蟒蛇：bool`"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:20
msgid ""
"For :class:`~openerp.fields.Selection`, the value should match the selection"
" values (generally :class:`python:str`, sometimes :class:`python:int`)"
msgstr "适用于：类：`〜openerp.fields.Selection`，该值应符合选择值（一般为：类：`蟒蛇：str`，有时：类：`蟒蛇：int`）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:23
msgid ""
"For :class:`~openerp.fields.Many2one`, the value should be the database "
"identifier of the record to set"
msgstr "适用于：类：`〜openerp.fields.Many2one`，该值应为记录的数据库标识设置"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:25
msgid "Other non-relational fields use a string for value"
msgstr "其他非关系字段使用一个字符串值"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:29
msgid ""
"for historical and compatibility reasons, :class:`~openerp.fields.Date` and "
":class:`~openerp.fields.Datetime` fields use strings as values (written and "
"read) rather than :class:`~python:datetime.date` or "
":class:`~python:datetime.datetime`. These date strings are UTC-only and "
"formatted according to "
":const:`openerp.tools.misc.DEFAULT_SERVER_DATE_FORMAT` and "
":const:`openerp.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`"
msgstr "由于历史和兼容性的原因，类别：`〜openerp.fields.Date`和：类：`〜openerp.fields.Datetime`字段使用字符串作为值（写入和读出），而不是：类：`〜蟒蛇：日期时间。 date`或产品类别：`〜蟒蛇：datetime.datetime`。这些日期字符串是UTC的，并且其格式为：常量：`openerp.tools.misc.DEFAULT_SERVER_DATE_FORMAT`和：常量：`openerp.tools.misc.DEFAULT_SERVER_DATETIME_FORMAT`"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:39
msgid ""
":class:`~openerp.fields.One2many` and :class:`~openerp.fields.Many2many` use"
" a special \"commands\" format to manipulate the set of records stored "
"in/associated with the field."
msgstr "产品类别：`〜openerp.fields.One2many`和：类：`〜openerp.fields.Many2many`使用特殊的\“命令\”的形式来操纵一套存储在/与字段关联的记录。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:43
msgid ""
"This format is a list of triplets executed sequentially, where each triplet "
"is a command to execute on the set of records. Not all commands apply in all"
" situations. Possible commands are:"
msgstr "这种格式是顺序执行的三胞胎，其中每一三元组是上的记录集执行一个命令的列表。不是所有的命令适用于所有情况。可能的命令是："

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:47
msgid "``(0, _, values)``"
msgstr "``（0，_，值）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:48
msgid "adds a new record created from the provided ``value`` dict."
msgstr "加上从提供的``value``字典创造了一个新纪录。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:50
msgid "``(1, id, values)``"
msgstr "``（1，ID值）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:50
msgid ""
"updates an existing record of id ``id`` with the values in ``values``. Can "
"not be used in :meth:`~.create`."
msgstr "更新ID``id``在``values​​``值的现有记录。甲：可以在不使用`〜.create`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:53
msgid "``(2, id, _)``"
msgstr "``（2，身份证，_）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:53
msgid ""
"removes the record of id ``id`` from the set, then deletes it (from the "
"database). Can not be used in :meth:`~.create`."
msgstr "删除的id'记录从集合`id``，然后将其删除（从数据库）。甲：可以在不使用`〜.create`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:58
msgid "``(3, id, _)``"
msgstr "``（3，身份证，_）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:56
msgid ""
"removes the record of id ``id`` from the set, but does not delete it. Can "
"not be used on :class:`~openerp.fields.One2many`. Can not be used in "
":meth:`~.create`."
msgstr "删除ID``从集合id``的记录，但不删除它。类：不能在使用`〜openerp.fields.One2many`。甲：可以在不使用`〜.create`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:61
msgid "``(4, id, _)``"
msgstr "``（4，ID，_）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:61
msgid ""
"adds an existing record of id ``id`` to the set. Can not be used on "
":class:`~openerp.fields.One2many`."
msgstr "增加ID的现有记录``id``设定的。类：不能在使用`〜openerp.fields.One2many`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:66
msgid "``(5, _, _)``"
msgstr "``（5，_，_）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:64
msgid ""
"removes all records from the set, equivalent to using the command ``3`` on "
"every record explicitly. Can not be used on "
":class:`~openerp.fields.One2many`. Can not be used in :meth:`~.create`."
msgstr "从集合中移除所有的记录，相当于用在每个记录的命令``3``明确。类：不能在使用`〜openerp.fields.One2many`。甲：可以在不使用`〜.create`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:72
msgid "``(6, _, ids)``"
msgstr "``（6，_，IDS）``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:69
msgid ""
"replaces all existing records in the set by the ``ids`` list, equivalent to "
"using the command ``5`` followed by a command ``4`` for each ``id`` in "
"``ids``. Can not be used on :class:`~openerp.fields.One2many`."
msgstr "取代了设定的``ids``列表中的所有现有的记录，相当于使用命令``5``其次是每个``id``命令``4``在``ids``。类：不能在使用`〜openerp.fields.One2many`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.write:74
msgid ""
"Values marked as ``_`` in the list above are ignored and can be anything, "
"generally ``0`` or ``False``."
msgstr "在列表中标记为``_``值高于被忽略，并且可以是任何东西，一般``0``或``False``。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.read:1
msgid ""
"Reads the requested fields for the records in ``self``, low-level/RPC "
"method. In Python code, prefer :meth:`~.browse`."
msgstr "读为``self``，低水平/ RPC方法记录的请求领域。在Python代码，喜欢：甲：`〜.browse`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.read:4
msgid "list of field names to return (default is all fields)"
msgstr "字段名称的列表返回（默认为所有字段）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.read:5
msgid ""
"a list of dictionaries mapping field names to their values, with one "
"dictionary per record"
msgstr "的字典映射字段名称及其值的列表，每记三分词典"

#: ../../../openerp/models.pydocstring of openerp.models.Model.read:7
msgid "if user has no read rights on some of the given records"
msgstr "如果用户对某些给定的记录没有读取权限"

#: ../../reference/orm.rst:644
msgid "Research"
msgstr "科研"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:1
msgid ""
"Searches for records based on the ``args`` :ref:`search domain "
"<reference/orm/domains>`."
msgstr "搜索记录基础上，``args``：参考：`搜索域<参考/ ORM /域>`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:4
msgid ""
":ref:`A search domain <reference/orm/domains>`. Use an empty list to match "
"all records."
msgstr "：参考：`一个搜索域<参考/ ORM /域>`。使用空列表中的所有记录匹配。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:6
msgid "number of results to ignore (default: none)"
msgstr "结果数量忽略（默认值：无）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:7
msgid "maximum number of records to return (default: all)"
msgstr "最大记录数返回（默认：全部）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:8
msgid "sort string"
msgstr "排序字符串"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:9
msgid ""
"if True, only counts and returns the number of matching records (default: "
"False)"
msgstr "如果属实，只能算作并返回匹配的记录数（默认值：false）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:10
msgid "at most ``limit`` records matching the search criteria"
msgstr "在大多数``limit``匹配的记录的搜索条件"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:12
msgid ""
"* if user tries to bypass access rules for read on the requested object."
msgstr "*如果用户试图绕过访问规则的读取请求的对象上。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search:12
msgid "if user tries to bypass access rules for read on the requested object."
msgstr "如果用户试图绕过访问规则读请求的对象上。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.search_count:1
msgid ""
"Returns the number of records in the current model matching :ref:`the "
"provided domain <reference/orm/domains>`."
msgstr "返回当前模型匹配的记录数：REF：'提供的域<参考/ ORM /域>`。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:1
msgid ""
"Search for records that have a display name matching the given ``name`` "
"pattern when compared with the given ``operator``, while also matching the "
"optional search domain (``args``)."
msgstr "搜索有一个显示名称，当给定``operator``比较匹配给定``name``模式，同时还可选配可选的搜索域名记录（``args``）。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:5
msgid ""
"This is used for example to provide suggestions based on a partial value for"
" a relational field. Sometimes be seen as the inverse function of "
":meth:`~.name_get`, but it is not guaranteed to be."
msgstr "这是用于例如提供基于用于一个关系字段的局部值的建议。有时被看作是反函数：甲基：`〜.name_get`，但它不能保证。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:9
msgid ""
"This method is equivalent to calling :meth:`~.search` with a search domain "
"based on ``display_name`` and then :meth:`~.name_get` on the result of the "
"search."
msgstr "此方法等效于调用：甲：`〜.search`基于``display_name``，然后搜索域：甲：`〜.name_get`的搜索结果。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:13
msgid "the name pattern to match"
msgstr "名字模式匹配"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:14
msgid ""
"optional search domain (see :meth:`~.search` for syntax), specifying further"
" restrictions"
msgstr "可选的搜索域（参见：甲：`〜.search`语法），规定进一步的限制"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:16
msgid "domain operator for matching ``name``, such as ``'like'`` or ``'='``."
msgstr "域名运营商匹配``name``，如``'like'``或``'='``。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:18
msgid "optional max number of records to return"
msgstr "记录可选的最大数量返回"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_search:20
msgid "list of pairs ``(id, text_repr)`` for all matching records."
msgstr "对``（ID，text_repr）``对所有匹配的记录列表。"

#: ../../reference/orm.rst:650
msgid "Recordset operations"
msgstr "记录操作"

#: ../../../openerp/models.pydocstring of openerp.models.Model.ids:1
msgid ""
"List of actual record ids in this recordset (ignores placeholder ids for "
"records to create)"
msgstr "在这个记录的实际记录的ID列表（忽略占位符id的记录来创建）"

#: ../../../openerp/models.pydocstring of openerp.models.Model.ensure_one:1
msgid ""
"Verifies that the current recorset holds a single record. Raises an "
"exception otherwise."
msgstr "验证当前recorset持有单个记录。否则会引发一个异常。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.exists:1
msgid ""
"Returns the subset of records in ``self`` that exist, and marks deleted "
"records as such in cache. It can be used as a test on records::"
msgstr "返回中存在的``self``记录子集，和马克在高速缓存删除的记录本身。它可以用作上记录的测试::"

#: ../../../openerp/models.pydocstring of openerp.models.Model.exists:7
msgid "By convention, new records are returned as existing."
msgstr "按照惯例，新记录返回现有的。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.filtered:1
msgid ""
"Select the records in ``self`` such that ``func(rec)`` is true, and return "
"them as a recordset."
msgstr "在``self``选择记录，从而使``FUNC（REC）``是真实的，并把它们作为返回记录集。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.filtered:4
#: ../../../openerp/models.pydocstring of openerp.models.Model.mapped:5
msgid "a function or a dot-separated sequence of field names"
msgstr "一个函数或字段名称的点分隔的序列"

#: ../../../openerp/models.pydocstring of openerp.models.Model.sorted:1
msgid "Return the recordset ``self`` ordered by ``key``."
msgstr "返回记录集``self``下令``key``。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.sorted:3
msgid ""
"either a function of one argument that returns a comparison key for each "
"record, or ``None``, in which case records are ordered according the default"
" model's order"
msgstr "任一个参数的函数返回一个比较关键的每个记录，或``None``，在这种情况下，记录按照默认的模型的顺序排序"

#: ../../../openerp/models.pydocstring of openerp.models.Model.sorted:7
msgid "if ``True``, return the result in reverse order"
msgstr "如果``True``，那么返回的结果以相反的顺序"

#: ../../../openerp/models.pydocstring of openerp.models.Model.mapped:1
msgid ""
"Apply ``func`` on all records in ``self``, and return the result as a list "
"or a recordset (if ``func`` return recordsets). In the latter case, the "
"order of the returned recordset is arbitrary."
msgstr "应用``func``所有记录在``self``，并返回结果列表或一个记录（如果``func``返回记录集）。在后一种情况下，返回的记录集的顺序是任意的。"

#: ../../reference/orm.rst:659
msgid "Environment swapping"
msgstr "环境交换"

#: ../../../openerp/models.pydocstring of openerp.models.Model.sudo:1
msgid "Returns a new version of this recordset attached to the provided user."
msgstr "返回此记录附着到提供用户的新版本。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.with_context:1
msgid ""
"Returns a new version of this recordset attached to an extended context."
msgstr "返回此记录附连到一个扩展上下文的新版本。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.with_context:4
msgid ""
"The extended context is either the provided ``context`` in which "
"``overrides`` are merged or the *current* context in which ``overrides`` are"
" merged e.g.::"
msgstr "扩展方面或者是提供的``context``其中``overrides``合并或*电流*环境中``overrides``合并，例如::"

#: ../../../openerp/models.pydocstring of openerp.models.Model.with_env:1
msgid ""
"Returns a new version of this recordset attached to the provided environment"
msgstr "返回此记录附着到提供环境的新版本"

#: ../../reference/orm.rst:665
msgid "Fields and views querying"
msgstr "字段和视图查询"

#: ../../../openerp/models.pydocstring of openerp.models.Model.fields_get:1
msgid "Return the definition of each field."
msgstr "返回各字段的定义。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.fields_get:3
msgid ""
"The returned value is a dictionary (indiced by field name) of dictionaries. "
"The _inherits'd fields are included. The string, help, and selection (if "
"present) attributes are translated."
msgstr "返回的值是一个字典词典（按字段名indiced）。所述_inherits'd字段都包括在内。串，帮助和选择（如果存在的话）的属性被转换。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.fields_get:7
msgid "list of fields to document, all if empty or not provided"
msgstr "字段列表文件，如果全部为空或不提供"

#: ../../../openerp/models.pydocstring of openerp.models.Model.fields_get:8
msgid ""
"list of description attributes to return for each field, all if empty or not"
" provided"
msgstr "描述属性列表返回每个字段，如果全部为空或不提供"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:1
msgid ""
"Get the detailed composition of the requested view like fields, model, view "
"architecture"
msgstr "得到这样的领域请求的视图的详细构成，模型，视图架构"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:3
msgid "id of the view or None"
msgstr "视图或无的ID"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:4
msgid "type of the view to return if view_id is None ('form', 'tree', ...)"
msgstr "返回视图的类型，如果是的view_id无（'形式'，'树'，...）"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:5
msgid "true to include contextual actions"
msgstr "真到包括上下文动作"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:6
msgid "deprecated"
msgstr "弃用"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:7
msgid ""
"dictionary describing the composition of the requested view (including "
"inherited views and extensions)"
msgstr "词典描述所请求的视图的组合物（包括继承的观点和扩展）"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:8
msgid ""
"* if the inherited view has unknown position to work with other than "
"'before', 'after', 'inside', 'replace' * if some tag other than 'position' "
"is found in parent view"
msgstr "*如果继承的视图有未知的位置“后，”工作与其他不是“前”，“内”，“替换”*如果一些标签不是'位置'另一种是在父视图中找到"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:9
msgid ""
"if the inherited view has unknown position to work with other than 'before',"
" 'after', 'inside', 'replace'"
msgstr "如果继承的观点有未知的位置与工作以外的“前”，“后”，“内”，“替换”"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:10
msgid "if some tag other than 'position' is found in parent view"
msgstr "如果一些标签不是“位置”等在父视图被发现"

#: ../../../openerp/models.pydocstring of
#: openerp.models.Model.fields_view_get:11
msgid ""
"if there is view type other than form, tree, calendar, search etc defined on"
" the structure"
msgstr "如果有比形式，树，日历视图类型，搜查等的结构定义"

#: ../../reference/orm.rst:670
msgid "???"
msgstr "???"

#: ../../../openerp/models.pydocstring of openerp.models.Model.default_get:1
msgid ""
"Return default values for the fields in ``fields_list``. Default values are "
"determined by the context, user defaults, and the model itself."
msgstr "返回``fields_list``为字段的默认值。默认值由上下文，用户默认值和模型本身来确定。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.default_get:5
msgid "a list of field names"
msgstr "字段名称的列表"

#: ../../../openerp/models.pydocstring of openerp.models.Model.default_get:6
msgid ""
"a dictionary mapping each field name to its corresponding default value, if "
"it has one."
msgstr "一个字典映射每个字段名称到其相应的默认值，如果它有一个。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.copy:1
msgid "Duplicate record with given id updating it with default values"
msgstr "重复的记录与特定ID更新它的默认值"

#: ../../../openerp/models.pydocstring of openerp.models.Model.copy:3
msgid ""
"dictionary of field values to override in the original values of the copied "
"record, e.g: ``{'field_name': overridden_value, ...}``"
msgstr "字段值的字典中复制的记录，如原始值覆盖：``{'FIELD_NAME“：overridden_​​value，...}``"

#: ../../../openerp/models.pydocstring of openerp.models.Model.copy:5
msgid "new record"
msgstr "新纪录"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_get:1
msgid ""
"Returns a textual representation for the records in ``self``. By default "
"this is the value of the ``display_name`` field."
msgstr "返回``self``为记录的文字表述。默认情况下，这是``display_name``字段的值。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_get:4
msgid "list of pairs ``(id, text_repr)`` for each records"
msgstr "对``（ID，text_repr）``每个记录列表"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_create:1
msgid ""
"Create a new record by calling :meth:`~.create` with only one value "
"provided: the display name of the new record."
msgstr "通过调用创建一个新的纪录：甲：`〜.create`只有一个提供的值：新记录的显示名称。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_create:4
msgid ""
"The new record will be initialized with any default values applicable to "
"this model, or provided through the context. The usual behavior of "
":meth:`~.create` applies."
msgstr "新的记录将与可适用于本模型中的任何默认值被初始化，或通过上下文提供的。甲：通常的行为`〜.create`适用。"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_create:8
msgid "display name of the record to create"
msgstr "创造纪录的显示名称"

#: ../../../openerp/models.pydocstring of openerp.models.Model.name_create:10
msgid "the :meth:`~.name_get` pair value of the created record"
msgstr "中：甲：`〜.name_get`对已创建的记录值"

#: ../../reference/orm.rst:679
msgid "Automatic fields"
msgstr "自动场"

#: ../../reference/orm.rst:682
msgid "Identifier :class:`field <openerp.fields.Field>`"
msgstr "标识符：类：`现场<openerp.fields.Field>`"

#: ../../reference/orm.rst:686
msgid ""
"Whether log access fields (``create_date``, ``write_uid``, ...) should be "
"generated (default: ``True``)"
msgstr "无论日志的访问域（``create_date``，``write_uid``，...）应生成（默认值：值为``True``）"

#: ../../reference/orm.rst:691
msgid "Date at which the record was created"
msgstr "创建记录在该日期"

#: ../../reference/orm.rst:693 ../../reference/orm.rst:705
msgid ":class:`~openerp.field.Datetime`"
msgstr "产品类别：`〜openerp.field.Datetime`"

#: ../../reference/orm.rst:697
msgid "Relational field to the user who created the record"
msgstr "关系领域谁创造了记录的用户"

#: ../../reference/orm.rst:699 ../../reference/orm.rst:711
msgid "``res.users``"
msgstr "``res.users``"

#: ../../reference/orm.rst:703
msgid "Date at which the record was last modified"
msgstr "日期，在该记录的最后修改"

#: ../../reference/orm.rst:709
msgid "Relational field to the last user who modified the record"
msgstr "关系领域谁修改过的记录的最后一个用户"

#: ../../reference/orm.rst:714
msgid "Reserved field names"
msgstr "保留的字段名"

#: ../../reference/orm.rst:715
msgid ""
"A few field names are reserved for pre-defined behaviors beyond that of "
"automated fields. They should be defined on a model when the related "
"behavior is desired:"
msgstr "一些字段名称为超出自动化领域的预先定义的行为保留。他们应该在模型中定义时，相关的行为期望："

#: ../../reference/orm.rst:721
msgid ""
"default value for :attr:`~._rec_name`, used to display records in context "
"where a representative \"naming\" is necessary."
msgstr "ATTR：为默认值`〜._rec_name`，用于在上下文中显示的记录，其中有代表性的\“命名\”是必要的。"

#: ../../reference/orm.rst:725
msgid ":class:`~openerp.fields.Char`"
msgstr "产品类别：`〜openerp.fields.Char`"

#: ../../reference/orm.rst:729
msgid ""
"toggles the global visibility of the record, if ``active`` is set to "
"``False`` the record is invisible in most searches and listing"
msgstr "切换记录的全球知名度，如果``active``设置为``False``的记录是不可见的，在大多数搜索和上市"

#: ../../reference/orm.rst:732
msgid ":class:`~openerp.fields.Boolean`"
msgstr "产品类别：`〜openerp.fields.Boolean`"

#: ../../reference/orm.rst:736
msgid ""
"Alterable ordering criteria, allows drag-and-drop reordering of models in "
"list views"
msgstr "可变排序标准，允许机型列表视图拖放和拖放重新排序"

#: ../../reference/orm.rst:739
msgid ":class:`~openerp.fields.Integer`"
msgstr "产品类别：`〜openerp.fields.Integer`"

#: ../../reference/orm.rst:743
msgid ""
"lifecycle stages of the object, used by the ``states`` attribute on "
":class:`fields <openerp.fields.Field>`"
msgstr "对象的生命周期阶段，对所用的``states``属性：等级：`领域<openerp.fields.Field>`"

#: ../../reference/orm.rst:746
msgid ":class:`~openerp.fields.Selection`"
msgstr "产品类别：`〜openerp.fields.Selection`"

#: ../../reference/orm.rst:750
msgid ""
"used to order records in a tree structure and enables the ``child_of`` "
"operator in domains"
msgstr "用于排序以树状结构的记录，并能够在域中的``child_of``运营商"

#: ../../reference/orm.rst:753
msgid ":class:`~openerp.fields.Many2one`"
msgstr "产品类别：`〜openerp.fields.Many2one`"

#: ../../reference/orm.rst:757
msgid "used with :attr:`~._parent_store`, allows faster tree structure access"
msgstr "ATTR：与使用`〜._parent_store`，允许更快的树形结构的访问"

#: ../../reference/orm.rst:761
msgid "see :attr:`~.parent_left`"
msgstr "见：ATTR：`〜.parent_left`"

#: ../../reference/orm.rst:766
msgid "Method decorators"
msgstr "方法装饰"

#: ../../../openerp/api.pydocstring of openerp.api:1
msgid ""
"This module provides the elements for managing two different API styles, "
"namely the \"traditional\" and \"record\" styles."
msgstr "该模块提供了管理两种不同API风格，即\“传统\”和\“记录\”风格的元素。"

#: ../../../openerp/api.pydocstring of openerp.api:4
msgid ""
"In the \"traditional\" style, parameters like the database cursor, user id, "
"context dictionary and record ids (usually denoted as ``cr``, ``uid``, "
"``context``, ``ids``) are passed explicitly to all methods. In the "
"\"record\" style, those parameters are hidden into model instances, which "
"gives it a more object-oriented feel."
msgstr "在\“传统\”的风格，比如数据库光标，用户ID，上下文字典和记录ID（通常表示为``cr``，``uid``，``context``，``参数ids`` ）明确地传递给所有方法。在\“记录\”的风格，这些参数都隐入模型实例，这使得它更加面向对象的感觉。"

#: ../../../openerp/api.pydocstring of openerp.api:10
msgid "For instance, the statements::"
msgstr "例如，语句::"

#: ../../../openerp/api.pydocstring of openerp.api:18
msgid "may also be written as::"
msgstr "也可写为::"

#: ../../../openerp/api.pydocstring of openerp.api:27
msgid ""
"Methods written in the \"traditional\" style are automatically decorated, "
"following some heuristics based on parameter names."
msgstr "写在\“传统\”式的方法是自动装饰，下面根据参数名称一些启发。"

#: ../../../openerp/api.pydocstring of openerp.api.one:1
msgid ""
"Decorate a record-style method where ``self`` is expected to be a singleton "
"instance. The decorated method automatically loops on records, and makes a "
"list with the results. In case the method is decorated with :func:`returns`,"
" it concatenates the resulting instances. Such a method::"
msgstr "装饰纪录式的方法，其中``self``有望成为单一实例。经装饰的方法自动循环上的记录，并与所述结果列表。如果该方法被装饰有：函数：`returns`，它并置所产生的实例。这样的方法::"

#: ../../../openerp/api.pydocstring of openerp.api.one:11
#: ../../../openerp/api.pydocstring of openerp.api.multi:8
#: ../../../openerp/api.pydocstring of openerp.api.model:8
msgid "may be called in both record and traditional styles, like::"
msgstr "可称为两个记录和传统风格，像::"

#: ../../../openerp/api.pydocstring of openerp.api.multi:1
msgid ""
"Decorate a record-style method where ``self`` is a recordset. The method "
"typically defines an operation on records. Such a method::"
msgstr "装饰纪录式的方法，其中``self``是一个记录。该方法通常定义上记录的操作。这样的方法::"

#: ../../../openerp/api.pydocstring of openerp.api.model:1
msgid ""
"Decorate a record-style method where ``self`` is a recordset, but its "
"contents is not relevant, only the model is. Such a method::"
msgstr "装饰纪录式的方法，其中``self``是一个记录，但它的内容是不相关的，只有模型。这样的方法::"

#: ../../../openerp/api.pydocstring of openerp.api.model:15
msgid ""
"Notice that no ``ids`` are passed to the method in the traditional style."
msgstr "请注意，没有``ids``传递给传统风格的方法。"

#: ../../../openerp/api.pydocstring of openerp.api.depends:1
msgid ""
"Return a decorator that specifies the field dependencies of a \"compute\" "
"method (for new-style function fields). Each argument must be a string that "
"consists in a dot-separated sequence of field names::"
msgstr "返回一个装饰，指定一个\“计算\”法领域的依赖关系（新样式的功能域）。每个参数必须是一个字符串，由字段名称中的一个圆点分隔的序列::"

#: ../../../openerp/api.pydocstring of openerp.api.depends:15
msgid ""
"One may also pass a single function as argument. In that case, the "
"dependencies are given by calling the function with the field's model."
msgstr "你也可以传递一个函数作为参数。在这种情况下，相关性是通过调用与场的模型的函数给出。"

#: ../../../openerp/api.pydocstring of openerp.api.constrains:1
msgid ""
"Decorates a constraint checker. Each argument must be a field name used in "
"the check::"
msgstr "装饰约束检查。每个参数必须在检查中使用的字段名::"

#: ../../../openerp/api.pydocstring of openerp.api.constrains:10
msgid ""
"Invoked on the records on which one of the named fields has been modified."
msgstr "援引在其上的命名字段中的一个已经被修改的记录。"

#: ../../../openerp/api.pydocstring of openerp.api.constrains:12
msgid ""
"Should raise :class:`~openerp.exceptions.ValidationError` if the validation "
"failed."
msgstr "应提高：类：`〜openerp.exceptions.ValidationError`如果验证失败。"

#: ../../../openerp/api.pydocstring of openerp.api.onchange:1
msgid ""
"Return a decorator to decorate an onchange method for given fields. Each "
"argument must be a field name::"
msgstr "返回一个装饰装饰给定的字段一个onchange方法。每个参数必须是一个字段名::"

#: ../../../openerp/api.pydocstring of openerp.api.onchange:8
msgid ""
"In the form views where the field appears, the method will be called when "
"one of the given fields is modified. The method is invoked on a pseudo-"
"record that contains the values present in the form. Field assignments on "
"that record are automatically sent back to the client."
msgstr "在现场出现的形式的观点，当在给定字段中的一个被修改的方法将被调用。该方法被调用上的伪记录包含存在于所述表格中的值。在该记录字段分配被自动发送回客户端。"

#: ../../../openerp/api.pydocstring of openerp.api.returns:1
msgid "Return a decorator for methods that return instances of ``model``."
msgstr "返回一个装饰对返回的``model``实例的方法。"

#: ../../../openerp/api.pydocstring of openerp.api.returns:3
msgid "a model name, or ``'self'`` for the current model"
msgstr "型号名称，或``'self'``当前模型"

#: ../../../openerp/api.pydocstring of openerp.api.returns:5
msgid ""
"a function ``downgrade(value)`` to convert the record-style ``value`` to a "
"traditional-style output"
msgstr "功能``降级（值）``到创纪录式的``value``转换为传统风格的输出"

#: ../../../openerp/api.pydocstring of openerp.api.returns:8
msgid ""
"The decorator adapts the method output to the api style: ``id``, ``ids`` or "
"``False`` for the traditional style, and recordset for the record style::"
msgstr "该装饰适应方式输出到API风格：``id``，``ids``或``False``的传统风格，并记录备案风格::"

#: ../../../openerp/api.pydocstring of openerp.api.returns:22
msgid "Note that the decorated method must satisfy that convention."
msgstr "需要注意的是装饰的方法必须符合该公约。"

#: ../../../openerp/api.pydocstring of openerp.api.returns:24
msgid ""
"Those decorators are automatically *inherited*: a method that overrides a "
"decorated existing method will be decorated with the same "
"``@returns(model)``."
msgstr "这些装饰会自动继承* *：重写一个现有的装饰方法的方法将使用相同​​的``@Returns（模型）``装饰。"

#: ../../../openerp/api.pydocstring of openerp.api.v7:1
msgid ""
"Decorate a method that supports the old-style api only. A new-style api may "
"be provided by redefining a method with the same name and decorated with "
":func:`~.v8`::"
msgstr "装修支持旧式的API只是一个方法。一种新的风格的API可以通过重新定义具有相同名称的方法来提供，并装饰有：函数：`〜.v8` ::"

#: ../../../openerp/api.pydocstring of openerp.api.v7:13
#: ../../../openerp/api.pydocstring of openerp.api.v8:13
msgid "Note that the wrapper method uses the docstring of the first method."
msgstr "需要注意的是包装方法使用第一种方法的文档字符串。"

#: ../../../openerp/api.pydocstring of openerp.api.v8:1
msgid ""
"Decorate a method that supports the new-style api only. An old-style api may"
" be provided by redefining a method with the same name and decorated with "
":func:`~.v7`::"
msgstr "装修支持新型API只是一个方法。旧式的API可以通过重新定义具有相同名称的方法来提供，并装饰有：函数：`〜.v7` ::"

#: ../../reference/orm.rst:775
msgid "Fields"
msgstr "领域"

#: ../../reference/orm.rst:780
msgid "Basic fields"
msgstr "基础领域"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:1
msgid ""
"The field descriptor contains the field definition, and manages accesses and"
" assignments of the corresponding field on records. The following attributes"
" may be provided when instanciating a field:"
msgstr "现场描述包含字段的定义，并管理相应字段的访问和任务的记录。下面的属性可以instanciating场时，必须提供："

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:5
msgid ""
"the label of the field seen by users (string); if not set, the ORM takes the"
" field name in the class (capitalized)."
msgstr "用户看到（string）的域的标签;如果没有设置，则ORM需要在类中的字段名（大写）。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:8
msgid "the tooltip of the field seen by users (string)"
msgstr "该领域的用户所看到的工具提示（串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:10
msgid "whether the field is readonly (boolean, by default ``False``)"
msgstr "是否该字段为readonly（布尔值，默认为``False``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:12
msgid ""
"whether the value of the field is required (boolean, by default ``False``)"
msgstr "是否需要该字段的值（布尔，默认``False``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:15
msgid ""
"whether the field is indexed in database (boolean, by default ``False``)"
msgstr "该字段是否被索引数据库（布尔值，默认为``False``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:18
msgid ""
"the default value for the field; this is either a static value, or a "
"function taking a recordset and returning a value"
msgstr "字段的默认值;这是一个静态值，或函数取一个记录并返回一个值"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:21
msgid ""
"a dictionary mapping state values to lists of UI attribute-value pairs; "
"possible attributes are: 'readonly', 'required', 'invisible'. Note: Any "
"state-based condition requires the ``state`` field value to be available on "
"the client-side UI. This is typically done by including it in the relevant "
"views, possibly made invisible if not relevant for the end-user."
msgstr "一个字典映射状态值到UI属性 - 值对列表;可能的属性有：'只读'，'需要'，'看不见的'。注意：任何基于状态的条件要求``state``字段值可在客户端UI。这一般是通过把它包含在有关的意见完成，可能是不可见的话不相关的最终用户。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:28
msgid ""
"comma-separated list of group xml ids (string); this restricts the field "
"access to the users of the given groups only"
msgstr "逗号分隔的组XML的ID（字符串）列表;这限制了视野内访问给定组的用户只"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:31
msgid ""
"whether the field value should be copied when the record is duplicated "
"(default: ``True`` for normal fields, ``False`` for ``one2many`` and "
"computed fields, including property fields and related fields)"
msgstr "无论是当记录被复制（默认值为``True``正常领域，``False``的``one2many``和计算领域，包括房地产领域和相关领域）的字段值应该被复制"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:36
msgid ""
"the previous name of this field, so that ORM can rename it automatically at "
"migration"
msgstr "本场之前的名字，这样的ORM可以自动迁移时将其重命名"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:43
msgid ""
"One can define a field whose value is computed instead of simply being read "
"from the database. The attributes that are specific to computed fields are "
"given below. To define such a field, simply provide a value for the "
"attribute ``compute``."
msgstr "可以定义其值被计算而不是简单地从数据库中读取一个字段。被特定于计算字段的属性如下。要定义这样的字段，只需提供该属性``compute``值。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:48
msgid "name of a method that computes the field"
msgstr "该计算磁场的方法的命名"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:50
msgid "name of a method that inverses the field (optional)"
msgstr "该逆字段的方法名（可选）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:52
msgid "name of a method that implement search on the field (optional)"
msgstr "实现搜索领域的一个方法的名称（可选）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:54
msgid ""
"whether the field is stored in database (boolean, by default ``False`` on "
"computed fields)"
msgstr "该字段是否被存储在数据库（布尔，默认``False``上计算字段）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:57
msgid ""
"whether the field should be recomputed as superuser to bypass access rights "
"(boolean, by default ``False``)"
msgstr "现场是否应该重新计算为超级用户绕过访问权限（布尔值，默认为``False``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:60
msgid ""
"The methods given for ``compute``, ``inverse`` and ``search`` are model "
"methods. Their signature is shown in the following example::"
msgstr "给出了``compute``，``inverse``和``search``的方法是模型的方法。其签名示于下面的例子::"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:81
msgid ""
"The compute method has to assign the field on all records of the invoked "
"recordset. The decorator :meth:`openerp.api.depends` must be applied on the "
"compute method to specify the field dependencies; those dependencies are "
"used to determine when to recompute the field; recomputation is automatic "
"and guarantees cache/database consistency. Note that the same method can be "
"used for several fields, you simply have to assign all the given fields in "
"the method; the method will be invoked once for all those fields."
msgstr "该计算方法被调用的记录的所有记录在分配领域。装饰：甲基：`openerp.api.depends`必须在计算方法指定字段依赖性适用;这些依赖被用来确定何时重新计算字段;重新计算是自动的，并保证缓存/数据库的一致性。需要注意的是，可用于几个字段相同的方法，你只需要分配的方法中的所有给定的字段;该方法将所有这些领域被调用一次。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:90
msgid ""
"By default, a computed field is not stored to the database, and is computed "
"on-the-fly. Adding the attribute ``store=True`` will store the field's "
"values in the database. The advantage of a stored field is that searching on"
" that field is done by the database itself. The disadvantage is that it "
"requires database updates when the field must be recomputed."
msgstr "缺省情况下，计算字段不存储到数据库中，并且计算上即时。添加属性``存储= True``将存储在数据库中的字段的值。存储字段的优点是，在搜索该字段是由数据库本身完成。的缺点是，它需要数据库更新时的字段必须重新计算。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:96
msgid ""
"The inverse method, as its name says, does the inverse of the compute "
"method: the invoked records have a value for the field, and you must apply "
"the necessary changes on the field dependencies such that the computation "
"gives the expected value. Note that a computed field without an inverse "
"method is readonly by default."
msgstr "逆方法，如它的名字一样，不计算方法的逆：调用的记录有该领域的价值，你必须应用在球场上的依赖关系进行必要的修改，以使计算给出的预期值。请注意，如果没有逆向方法计算字段是只读的默认。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:102
msgid ""
"The search method is invoked when processing domains before doing an actual "
"search on the model. It must return a domain equivalent to the condition: "
"``field operator value``."
msgstr "这样的模式在实际搜索前处理领域当调用搜索方法。它必须返回等同的条件的域：``现场操作人员value``。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:110
msgid ""
"The value of a related field is given by following a sequence of relational "
"fields and reading a field on the reached model. The complete sequence of "
"fields to traverse is specified by the attribute"
msgstr "相关领域的值由下述关系字段序列和关于到达模型读取字段给出。字段遍历的完整序列由属性指定"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:114
msgid "sequence of field names"
msgstr "字段名的序列"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:116
msgid ""
"Some field attributes are automatically copied from the source field if they"
" are not redefined: ``string``, ``help``, ``readonly``, ``required`` (only "
"if all fields in the sequence are required), ``groups``, ``digits``, "
"``size``, ``translate``, ``sanitize``, ``selection``, ``comodel_name``, "
"``domain``, ``context``. All semantic-free attributes are copied from the "
"source field."
msgstr "某些字段属性是从源字段自动复制，如果他们不重新定义：``string``，``help``，``readonly``，``required``（仅当序列中的所有领域都需要） ``groups``，``digits``，``size``，``translate``，``sanitize``，``selection``，``comodel_name``，``domain``，` `context``。所有语义无属性从源字段复制。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:123
msgid ""
"By default, the values of related fields are not stored to the database. Add"
" the attribute ``store=True`` to make it stored, just like computed fields. "
"Related fields are automatically recomputed when their dependencies are "
"modified."
msgstr "缺省情况下，相关领域的值不存储到数据库中。加入使其存储，就像计算字段属性``店= True``。当它们的依赖被修改的相应字段的自动重新计算。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:131
msgid "Company-dependent fields"
msgstr "公司依赖字段"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:132
msgid ""
"Formerly known as 'property' fields, the value of those fields depends on "
"the company. In other words, users that belong to different companies may "
"see different values for the field on a given record."
msgstr "前身为“财产”的字段，这些字段的值取决于公司。换句话说，属于不同公司的用户会发现不同的值的字段上的给定的记录。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:136
msgid "whether the field is company-dependent (boolean)"
msgstr "字段是否公司依赖性（布尔值）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:141
msgid "Incremental definition"
msgstr "增量定义"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:142
msgid ""
"A field is defined as class attribute on a model class. If the model is "
"extended (see :class:`~openerp.models.Model`), one can also extend the field"
" definition by redefining a field with the same name and same type on the "
"subclass. In that case, the attributes of the field are taken from the "
"parent class and overridden by the ones given in subclasses."
msgstr "字段被定义为一个模型类类属性。如果模型扩展（参见：类：`〜openerp.models.Model`），人们还可以通过重新定义一个字段与子类相同的名称和相同类型的扩展字段定义。在这种情况下，场的属性取自父类并且由那些在子类给定的覆盖。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Field:149
msgid ""
"For instance, the second class below only adds a tooltip on the field "
"``state``::"
msgstr "例如，下面只有第二类添加场上``state``工具提示::"

#: ../../../openerp/fields.pydocstring of openerp.fields.Char:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Text:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Html:1
msgid "Bases: :class:`openerp.fields._String`"
msgstr "基地：类：`openerp.fields._String`"

#: ../../../openerp/fields.pydocstring of openerp.fields.Char:1
msgid ""
"Basic string field, can be length-limited, usually displayed as a single-"
"line string in clients."
msgstr "基本字符串字段，可以是长度有限，通常显示为客户单行串。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Char:4
msgid "the maximum size of values stored for that field"
msgstr "值的所存储的该场的最大尺寸"

#: ../../../openerp/fields.pydocstring of openerp.fields.Char:6
#: ../../../openerp/fields.pydocstring of openerp.fields.Text:4
msgid ""
"enable the translation of the field's values; use `translate=True` to "
"translate field values as a whole; `translate` may also be a callable such "
"that `translate(callback, value)` translates `value` by using "
"`callback(term)` to retrieve the translation of terms."
msgstr "启用字段的值的翻译;使用`翻译= TRUE`翻译字段值作为一个整体; `translate`也可以是可调用，使得'翻译（回调，值）``转换value`使用`回调（长期）`检索术语的翻译。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Boolean:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Integer:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Float:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Selection:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Date:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Datetime:1
msgid "Bases: :class:`openerp.fields.Field`"
msgstr "基地：类：`openerp.fields.Field`"

#: ../../../openerp/fields.pydocstring of openerp.fields.Float:1
msgid "The precision digits are given by the attribute"
msgstr "的位精度是由属性给出"

#: ../../../openerp/fields.pydocstring of openerp.fields.Float:3
msgid ""
"a pair (total, decimal), or a function taking a database cursor and "
"returning a pair (total, decimal)"
msgstr "一对（总共，小数），或采取一个数据库光标并返回一个对一个功能（总共，小数）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Text:1
msgid ""
"Very similar to :class:`~.Char` but used for longer contents, does not have "
"a size and usually displayed as a multiline text box."
msgstr "非常相似：类：`〜.Char`但用于较长内容，不具有大小，通常显示为多行文本框。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Selection:1
msgid ""
"specifies the possible values for this field. It is given as either a list "
"of pairs (``value``, ``string``), or a model method, or a method name."
msgstr "指定该字段的可能值。它被给定为对任一列表（``value``，``string``），或一模型法，或方法的名称。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Selection:4
msgid ""
"provides an extension of the selection in the case of an overridden field. "
"It is a list of pairs (``value``, ``string``)."
msgstr "提供了选择在被覆盖的区域的情况下的延伸。这是对的列表（``value``，``string``）。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Selection:7
msgid ""
"The attribute ``selection`` is mandatory except in the case of :ref:`related"
" fields <field-related>` or :ref:`field extensions <field-incremental-"
"definition>`."
msgstr "属性``selection``是强制性的，除了在案件：REF：`相关领域<字段相关>`或：参考：`领域扩展<现场增量定义>`。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Date.context_today:1
msgid ""
"Return the current date as seen in the client's timezone in a format fit for"
" date fields. This method may be used to compute default values."
msgstr "返回当前日期作为在格式适合日期字段看出，在客户机的时区。该方法可用于计算默认值。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Date.context_today:5
msgid ""
"optional datetime value to use instead of the current date and time (must be"
" a datetime, regular dates can't be converted between timezones.)"
msgstr "可选的日期时间值来使用，而不是当前日期和时间（必须是日期时间，定期日期不能时区之间进行转换。）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Date.from_string:1
msgid "Convert an ORM ``value`` into a :class:`date` value."
msgstr "转换一个ORM``value``成：类：`date`值。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Date.to_string:1
msgid "Convert a :class:`date` value into the format expected by the ORM."
msgstr "转换：类：`date`值转换成预期的ORM的格式。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Date.today:1
msgid ""
"Return the current day in the format expected by the ORM. This function may "
"be used to compute default values."
msgstr "返回当前天中预期的ORM的格式。这个函数可用于计算默认值。"

#: ../../../openerp/fields.pydocstring of
#: openerp.fields.Datetime.context_timestamp:1
msgid ""
"Returns the given timestamp converted to the client's timezone. This method "
"is *not* meant for use as a _defaults initializer, because datetime fields "
"are automatically converted upon display on client side. For _defaults you "
":meth:`fields.datetime.now` should be used instead."
msgstr "返回给定时间戳记转换为客户端的时区。这种方法是不* *意指用作_defaults初始化，因为日期时间字段在显示自动转换在客户端。对于_defaults你：甲：`fields.datetime.now`应该使用。"

#: ../../../openerp/fields.pydocstring of
#: openerp.fields.Datetime.context_timestamp:7
msgid ""
"naive datetime value (expressed in UTC) to be converted to the client "
"timezone"
msgstr "幼稚日期时间值（以UTC表示）被转换为客户端时区"

#: ../../../openerp/fields.pydocstring of
#: openerp.fields.Datetime.context_timestamp:10
msgid "timestamp converted to timezone-aware datetime in context timezone"
msgstr "时间戳转换成时区感知日期时间上下文时区"

#: ../../../openerp/fields.pydocstring of
#: openerp.fields.Datetime.from_string:1
msgid "Convert an ORM ``value`` into a :class:`datetime` value."
msgstr "转换一个ORM``value``成：类：`datetime`值。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Datetime.now:1
msgid ""
"Return the current day and time in the format expected by the ORM. This "
"function may be used to compute default values."
msgstr "返回当前日期和时间在期望的ORM的格式。这个函数可用于计算默认值。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Datetime.to_string:1
msgid "Convert a :class:`datetime` value into the format expected by the ORM."
msgstr "转换：类：`datetime`值转换成预期的ORM的格式。"

#: ../../reference/orm.rst:822
msgid "Relational fields"
msgstr "关系领域"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:1
msgid "Bases: :class:`openerp.fields._Relational`"
msgstr "基地：类：`openerp.fields._Relational`"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:1
msgid ""
"The value of such a field is a recordset of size 0 (no record) or 1 (a "
"single record)."
msgstr "这样的字段的值是大小0（无记录）或1的一个记录（单个记录）。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:4
#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:5
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:3
msgid "name of the target model (string)"
msgstr "目标模型的名称（字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:6
#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:10
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:21
msgid ""
"an optional domain to set on candidate values on the client side (domain or "
"string)"
msgstr "一个可选的域上的客户机端的候选值设定（域或字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:9
#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:13
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:24
msgid ""
"an optional context to use on the client side when handling that field "
"(dictionary)"
msgstr "一个可选的情况下，以处理该字段（字典）时，在客户端使用"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:12
msgid ""
"what to do when the referred record is deleted; possible values are: ``'set "
"null'``, ``'restrict'``, ``'cascade'``"
msgstr "该怎么办时，称为记录被删除;可能的值是：``'设置null'``，``'restrict'``，``'cascade'``"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:15
#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:16
msgid ""
"whether JOINs are generated upon search through that field (boolean, by "
"default ``False``)"
msgstr "无论是在JOIN的通过搜索领域中产生（布尔值，默认为``False``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:18
msgid ""
"set it to ``True`` to make fields of the target model accessible from the "
"current model (corresponds to ``_inherits``)"
msgstr "其设置为值为``True``，使目标模型的领域从当前模型访问（相当于``_inherits``）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2one:21
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:5
msgid ""
"The attribute ``comodel_name`` is mandatory except in the case of related "
"fields or field extensions."
msgstr "属性``comodel_name``是强制性的，除非在相关领域或领域扩展的情况。"

#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:1
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:1
msgid "Bases: :class:`openerp.fields._RelationalMulti`"
msgstr "基地：类：`openerp.fields._RelationalMulti`"

#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:1
msgid ""
"One2many field; the value of such a field is the recordset of all the "
"records in ``comodel_name`` such that the field ``inverse_name`` is equal to"
" the current record."
msgstr "One2many场;这样的字段的值是``comodel_name``等所有记录的记录，外地``inverse_name``等于当前记录。"

#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:7
msgid "name of the inverse ``Many2one`` field in ``comodel_name`` (string)"
msgstr "逆``Many2one``场的``comodel_name``名称（字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:19
#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:27
msgid "optional limit to use upon read (integer)"
msgstr "在读取使用可选的限制（整数）"

#: ../../../openerp/fields.pydocstring of openerp.fields.One2many:21
msgid ""
"The attributes ``comodel_name`` and ``inverse_name`` are mandatory except in"
" the case of related fields or field extensions."
msgstr "属性``comodel_name``和``inverse_name``是强制性的，除非在相关领域或领域扩展的情况。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:1
msgid "Many2many field; the value of such a field is the recordset."
msgstr "Many2many场;这样的字段的值记录。"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:8
msgid ""
"optional name of the table that stores the relation in the database (string)"
msgstr "存储该关系数据库中的表中的可选的名称（字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:11
msgid ""
"optional name of the column referring to \"these\" records in the table "
"``relation`` (string)"
msgstr "列指的是\“这些\”表中的``记录的relation``可选名称（字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:14
msgid ""
"optional name of the column referring to \"those\" records in the table "
"``relation`` (string)"
msgstr "列指的是\“的\”表中的``记录的relation``可选名称（字符串）"

#: ../../../openerp/fields.pydocstring of openerp.fields.Many2many:17
msgid ""
"The attributes ``relation``, ``column1`` and ``column2`` are optional. If "
"not given, names are automatically generated from model names, provided "
"``model_name`` and ``comodel_name`` are different!"
msgstr "属性``relation``，``column1``和``column2``是可选的。如果没有给出，名称会自动从模型名产生，提供了``model_name``和``comodel_name``是不同的！"

#: ../../../openerp/fields.pydocstring of openerp.fields.Reference:1
msgid "Bases: :class:`openerp.fields.Selection`"
msgstr "基地：类：`openerp.fields.Selection`"

#: ../../reference/orm.rst:839
msgid "Inheritance and extension"
msgstr "继承和延伸"

#: ../../reference/orm.rst:841
msgid ""
"Odoo provides three different mechanisms to extend models in a modular way:"
msgstr "Odoo提供了三种不同的机制来扩展模型以模块化方式："

#: ../../reference/orm.rst:843
msgid ""
"creating a new model from an existing one, adding new information to the "
"copy but leaving the original module as-is"
msgstr "创建从现有的新模式，增加新的信息的副本，但离开原来的模块，是"

#: ../../reference/orm.rst:845
msgid ""
"extending models defined in other modules in-place, replacing the previous "
"version"
msgstr "延伸在就地其它模块定义的模型，取代以前版本"

#: ../../reference/orm.rst:847
msgid "delegating some of the model's fields to records it contains"
msgstr "委托一些模型的领域，以它包含的记录"

#: ../../reference/orm.rst:853
msgid "Classical inheritance"
msgstr "经典传承"

#: ../../reference/orm.rst:855
msgid ""
"When using the :attr:`~openerp.models.Model._inherit` and "
":attr:`~openerp.models.Model._name` attributes together, Odoo creates a new "
"model using the existing one (provided via "
":attr:`~openerp.models.Model._inherit`) as a base. The new model gets all "
"the fields, methods and meta-information (defaults & al) from its base."
msgstr "当使用：ATTR：`〜openerp.models.Model._inherit`和：ATTR：`〜openerp.models.Model._name`共同属性，Odoo创建一个使用新模式的现有（通过提供：ATTR：`〜 openerp.models.Model._inherit`）的魅力。新的模式得到所有从基地字段，方法和元信息（默认与人）。"

#: ../../reference/orm.rst:865
msgid "and using them:"
msgstr "并使用它们："

#: ../../reference/orm.rst:871 ../../reference/orm.rst:898
msgid "will yield:"
msgstr "将产生："

#: ../../reference/orm.rst:877
msgid ""
"the second model has inherited from the first model's ``check`` method and "
"its ``name`` field, but overridden the ``call`` method, as when using "
"standard :ref:`Python inheritance <python:tut-inheritance>`."
msgstr "第二个模型已经从第一个模型的``check``方法及其``name``场使用标准时继承，但覆盖了``call``方法，如：参考：`Python的继承<巨蟒：啧啧继承>`。"

#: ../../reference/orm.rst:882
msgid "Extension"
msgstr "扩展"

#: ../../reference/orm.rst:884
msgid ""
"When using :attr:`~openerp.models.Model._inherit` but leaving out "
":attr:`~openerp.models.Model._name`, the new model replaces the existing "
"one, essentially extending it in-place. This is useful to add new fields or "
"methods to existing models (created in other modules), or to customize or "
"reconfigure them (e.g. to change their default sort order):"
msgstr "当使用：ATTR：`〜openerp.models.Model._inherit`但离开了：ATTR：`〜openerp.models.Model._name`，新的模式取代现有的，从根本上扩大其就地。这是有益的补充新的字段或方法，以现有的模式（在其他模块中创建），或自定义或重新配置（例如改变其默认的排序顺序）："

#: ../../reference/orm.rst:904
msgid ""
"it will also yield the various :ref:`automatic fields "
"<reference/orm/model/automatic>` unless they've been disabled"
msgstr "它也将产生不同的：REF：'自动字段<参考/ ORM /模式/自动>`，除非他们已经被禁用"

#: ../../reference/orm.rst:908
msgid "Delegation"
msgstr "委托"

#: ../../reference/orm.rst:910
msgid ""
"The third inheritance mechanism provides more flexibility (it can be altered"
" at runtime) but less power: using the "
":attr:`~openerp.models.Model._inherits` a model *delegates* the lookup of "
"any field not found on the current model to \"children\" models. The "
"delegation is performed via :class:`~openerp.fields.Reference` fields "
"automatically set up on the parent model:"
msgstr "第三继承机制提供了更多的灵活性（可以在运行时改变），但更省电：采用：ATTR：`〜openerp.models.Model._inherits`模型*代表*任何领域的当前模型没有找到查找到\“孩子\”模式。类：代表团通过执行`〜openerp.fields.Reference`领域的自动设置上父模型："

#: ../../reference/orm.rst:925
msgid "will result in:"
msgstr "将导致："

#: ../../reference/orm.rst:931
msgid "and it's possible to write directly on the delegated field:"
msgstr "并有可能在委托外地直接写："

#: ../../reference/orm.rst:937
msgid ""
"when using delegation inheritance, methods are *not* inherited, only fields"
msgstr "使用委派继承时，方法是*不*继承，只有场"

#: ../../reference/orm.rst:943
msgid "Domains"
msgstr "域"

#: ../../reference/orm.rst:945
msgid ""
"A domain is a list of criteria, each criterion being a triple (either a "
"``list`` or a ``tuple``) of ``(field_name, operator, value)`` where:"
msgstr "域是一个标准列表，每个标准是一个三元组（或者是``list``或``tuple``）``的（FIELD_NAME，运营商，值）``其中："

#: ../../reference/orm.rst:950
msgid "``field_name`` (``str``)"
msgstr "``field_name``（``str``）"

#: ../../reference/orm.rst:949
msgid ""
"a field name of the current model, or a relationship traversal through a "
":class:`~openerp.fields.Many2one` using dot-notation e.g. ``'street'`` or "
"``'partner_id.country'``"
msgstr "类：当前模型，或通过关系遍历的字段名'使用点符号，例如``'street'``或``'partner_id.country'``〜openerp.fields.Many2one`"

#: ../../reference/orm.rst:996
msgid "``operator`` (``str``)"
msgstr "``operator``（``str``）"

#: ../../reference/orm.rst:953
msgid ""
"an operator used to compare the ``field_name`` with the ``value``. Valid "
"operators are:"
msgstr "运营商用于比较``field_name``与``value``。有效的运营商："

#: ../../reference/orm.rst:956
msgid "``=``"
msgstr "``=``"

#: ../../reference/orm.rst:957
msgid "equals to"
msgstr "等于"

#: ../../reference/orm.rst:958
msgid "``!=``"
msgstr "``！=``"

#: ../../reference/orm.rst:959
msgid "not equals to"
msgstr "不等于"

#: ../../reference/orm.rst:960
msgid "``>``"
msgstr "``>``"

#: ../../reference/orm.rst:961
msgid "greater than"
msgstr "比...更棒"

#: ../../reference/orm.rst:962
msgid "``>=``"
msgstr "``> =``"

#: ../../reference/orm.rst:963
msgid "greater than or equal to"
msgstr "大于或等于"

#: ../../reference/orm.rst:964
msgid "``<``"
msgstr "``<``"

#: ../../reference/orm.rst:965
msgid "less than"
msgstr "少于"

#: ../../reference/orm.rst:966
msgid "``<=``"
msgstr "``<=``"

#: ../../reference/orm.rst:967
msgid "less than or equal to"
msgstr "小于或等于"

#: ../../reference/orm.rst:969
msgid "``=?``"
msgstr "``=？``"

#: ../../reference/orm.rst:969
msgid ""
"unset or equals to (returns true if ``value`` is either ``None`` or "
"``False``, otherwise behaves like ``=``)"
msgstr "未设置或等于（如果``value``要么是``None``或``False``返回true，否则的行为就像``=``）"

#: ../../reference/orm.rst:973
msgid "``=like``"
msgstr "``= like``"

#: ../../reference/orm.rst:972
msgid ""
"matches ``field_name`` against the ``value`` pattern. An underscore ``_`` in"
" the pattern stands for (matches) any single character; a percent sign ``%``"
" matches any string of zero or more characters."
msgstr "比赛``field_name``对``value``模式。在pattern里的下划线``_``代表（匹配）任何单个字符;百分号``％``匹配的零个或多个字符的字符串。"

#: ../../reference/orm.rst:976
msgid "``like``"
msgstr "``like``"

#: ../../reference/orm.rst:976
msgid ""
"matches ``field_name`` against the ``%value%`` pattern. Similar to ``=like``"
" but wraps ``value`` with '%' before matching"
msgstr "比赛``field_name``对``％值％``模式。匹配类似``= like``但包装``value``以'％'前"

#: ../../reference/orm.rst:978
msgid "``not like``"
msgstr "``不like``"

#: ../../reference/orm.rst:979
msgid "doesn't match against the ``%value%`` pattern"
msgstr "不反对``％值％``模式匹配"

#: ../../reference/orm.rst:980
msgid "``ilike``"
msgstr "``ilike``"

#: ../../reference/orm.rst:981
msgid "case insensitive ``like``"
msgstr "不区分大小写``like``"

#: ../../reference/orm.rst:982
msgid "``not ilike``"
msgstr "``不ilike``"

#: ../../reference/orm.rst:983
msgid "case insensitive ``not like``"
msgstr "不区分大小写``不like``"

#: ../../reference/orm.rst:984
msgid "``=ilike``"
msgstr "``= ilike``"

#: ../../reference/orm.rst:985
msgid "case insensitive ``=like``"
msgstr "不区分大小写``= like``"

#: ../../reference/orm.rst:987
msgid "``in``"
msgstr "``in``"

#: ../../reference/orm.rst:987
msgid ""
"is equal to any of the items from ``value``, ``value`` should be a list of "
"items"
msgstr "等于任何从``value``中的项目，``value``应的项目列表"

#: ../../reference/orm.rst:989
msgid "``not in``"
msgstr "``不in``"

#: ../../reference/orm.rst:990
msgid "is unequal to all of the items from ``value``"
msgstr "不等于所有的项目从``value``"

#: ../../reference/orm.rst:996
msgid "``child_of``"
msgstr "``child_of``"

#: ../../reference/orm.rst:992
msgid "is a child (descendant) of a ``value`` record."
msgstr "是``value``记录的孩子（后代）。"

#: ../../reference/orm.rst:994
msgid ""
"Takes the semantics of the model into account (i.e following the "
"relationship field named by :attr:`~openerp.models.Model._parent_name`)."
msgstr "注意到模型的语义考虑（也就是后续命名的关系字段：ATTR：`〜openerp.models.Model._parent_name`）。"

#: ../../reference/orm.rst:999
msgid ""
"variable type, must be comparable (through ``operator``) to the named field"
msgstr "变量类型，必须与（通过``operator``）到指定字段"

#: ../../reference/orm.rst:1002
msgid ""
"Domain criteria can be combined using logical operators in *prefix* form:"
msgstr "域标准，可以使用*前缀*形式逻辑运算符组合："

#: ../../reference/orm.rst:1005
msgid "``'&'``"
msgstr "``'和'``"

#: ../../reference/orm.rst:1005
msgid ""
"logical *AND*, default operation to combine criteria following one another. "
"Arity 2 (uses the next 2 criteria or combinations)."
msgstr "逻辑*和*，默认操作要结合以下另一个标准。元数2（使用未来2标准或组合）。"

#: ../../reference/orm.rst:1007
msgid "``'|'``"
msgstr "``'|'``"

#: ../../reference/orm.rst:1008
msgid "logical *OR*, arity 2."
msgstr "逻辑*或*，元数2。"

#: ../../reference/orm.rst:1016
msgid "``'!'``"
msgstr "``'！'``"

#: ../../reference/orm.rst:1010
msgid "logical *NOT*, arity 1."
msgstr "逻辑*不*，元数1。"

#: ../../reference/orm.rst:1012
msgid "Mostly to negate combinations of criteria"
msgstr "主要是否定的标准组合"

#: ../../reference/orm.rst:1015
msgid ""
"Individual criterion generally have a negative form (e.g. ``=`` -> ``!=``, "
"``<`` -> ``>=``) which is simpler than negating the positive."
msgstr "个别的标准一般有否定形式（如``=`` - >``=````<`` - >``> =``）比否定了积极的简单。"

#: ../../reference/orm.rst:1018
msgid "Example"
msgstr "示例"

#: ../../reference/orm.rst:1020
msgid ""
"To search for partners named *ABC*, from belgium or germany, whose language "
"is not english::"
msgstr "要搜索名为* ABC *合作伙伴，来自比利时和德国，他们的母语不是英语::"

#: ../../reference/orm.rst:1028
msgid "This domain is interpreted as:"
msgstr "此域名被解释为："

#: ../../reference/orm.rst:1037
msgid "Porting from the old API to the new API"
msgstr "从旧的API移植到新的API"

#: ../../reference/orm.rst:1039
msgid ""
"bare lists of ids are to be avoided in the new API, use recordsets instead"
msgstr "id的裸列表是要避免在新的API中，使用记录集代替"

#: ../../reference/orm.rst:1040
msgid ""
"methods still written in the old API should be automatically bridged by the "
"ORM, no need to switch to the old API, just call them as if they were a new "
"API method. See :ref:`reference/orm/oldapi/bridging` for more details."
msgstr "仍然写在旧的​​API方法应该由ORM自动桥接，无需切换到旧的API，就打电话给他们，好像他们是一个新的API方法。请参阅：参考：`参考/ ORM / oldapi / bridging`了解更多详情。"

#: ../../reference/orm.rst:1043
msgid ""
":meth:`~openerp.models.Model.search` returns a recordset, no point in e.g. "
"browsing its result"
msgstr "：甲：`〜openerp.models.Model.search`返回记录集，在如不点浏览其结果"

#: ../../reference/orm.rst:1045
msgid ""
"``fields.related`` and ``fields.function`` are replaced by using a normal "
"field type with either a ``related=`` or a ``compute=`` parameter"
msgstr "``fields.related``和``fields.function``通过使用普通的字段类型与任何一个``相关=``或``计算取代=``参数"

#: ../../reference/orm.rst:1047
msgid ""
":func:`~openerp.api.depends` on ``compute=`` methods **must be complete**, "
"it must list **all** the fields and sub-fields which the compute method "
"uses. It is better to have too many dependencies (will recompute the field "
"in cases where that is not needed) than not enough (will forget to recompute"
" the field and then values will be incorrect)"
msgstr "：FUNC：`〜openerp.api.depends`上``计算=``方法**必须是完整的**，就必须列出所有** **领域和子领域该计算方法使用。最好是有太多的依赖（将重新计算在这不需要情况下，场）比没有足够的（会忘记重新计算字段，然后值将是不正确的）"

#: ../../reference/orm.rst:1052
msgid ""
"**remove** all ``onchange`` methods on computed fields. Computed fields are "
"automatically re-computed when one of their dependencies is changed, and "
"that is used to auto-generate ``onchange`` by the client"
msgstr "** **删除所有``onchange``在计算领域的方法。计算字段自动重新计算时，他们的相关性中的一个被改变，并且用于自动产生``由客户端onchange``"

#: ../../reference/orm.rst:1055
msgid ""
"the decorators :func:`~openerp.api.model` and :func:`~openerp.api.multi` are"
" for bridging *when calling from the old API context*, for internal or pure "
"new-api (e.g. compute) they are useless"
msgstr "在装饰：FUNC：`〜openerp.api.model`和：FUNC：`〜openerp.api.multi`是桥接*从旧的API中*打电话时，内部或纯粹的新API（如计算），他们也没用"

#: ../../reference/orm.rst:1058
msgid ""
"remove :attr:`~openerp.models.Model._default`, replace by ``default=`` "
"parameter on corresponding fields"
msgstr "删除：ATTR：`〜openerp.models.Model._default`，通过``默认值=``参数替换相应字段"

#: ../../reference/orm.rst:1060
msgid "if a field's ``string=`` is the titlecased version of the field name::"
msgstr "如果一个字段的``字符串=``是字段名的titlecased版本::"

#: ../../reference/orm.rst:1064
msgid "it is useless and should be removed"
msgstr "它是无用的，应被删除"

#: ../../reference/orm.rst:1065
msgid ""
"the ``multi=`` parameter does not do anything on new API fields use the same"
" ``compute=`` methods on all relevant fields for the same result"
msgstr "在``多=``参数并不做新的API领域使用相同的``计算=``在所有相关领域的方法相同的结果什么"

#: ../../reference/orm.rst:1067
msgid ""
"provide ``compute=``, ``inverse=`` and ``search=`` methods by name (as a "
"string), this makes them overridable (removes the need for an intermediate "
"\"trampoline\" function)"
msgstr "提供``计算=````逆=``和``搜索=``按名称方法（字符串），这使得它们覆盖的（不再需要中间\“蹦床\”功能）"

#: ../../reference/orm.rst:1070
msgid ""
"double check that all fields and methods have different names, there is no "
"warning in case of collision (because Python handles it before Odoo sees "
"anything)"
msgstr "仔细检查所有字段和方法有不同的名称，但在碰撞的情况下没有警告（因为Python处理它Odoo看到任何东西之前）"

#: ../../reference/orm.rst:1073
msgid ""
"the normal new-api import is ``from openerp import fields, models``. If "
"compatibility decorators are necessary, use ``from openerp import api, "
"fields, models``"
msgstr "正常的新API导入``从OpenERP的进口领域，models``。如果兼容性装饰是必要的，使用``从OpenERP的进口API，领域，models``"

#: ../../reference/orm.rst:1076
msgid ""
"avoid the :func:`~openerp.api.one` decorator, it probably does not do what "
"you expect"
msgstr "避免：FUNC：`〜openerp.api.one`装饰，它可能不会做你所期望的"

#: ../../reference/orm.rst:1078
msgid ""
"remove explicit definition of :attr:`~openerp.models.Model.create_uid`, "
":attr:`~openerp.models.Model.create_date`, "
":attr:`~openerp.models.Model.write_uid` and "
":attr:`~openerp.models.Model.write_date` fields: they are now created as "
"regular \"legitimate\" fields, and can be read and written like any other "
"field out-of-the-box"
msgstr "除去明确的定义：ATTR：`〜openerp.models.Model.create_uid`，：ATTR：`〜openerp.models.Model.create_date`，：ATTR：`〜openerp.models.Model.write_uid`和：attr：属性` 〜openerp.models.Model.write_date`领域：他们现在创建为常规\“合法\”领域，可以读取和写入像任何其他领域外的开箱"

#: ../../reference/orm.rst:1084
msgid ""
"when straight conversion is impossible (semantics can not be bridged) or the"
" \"old API\" version is not desirable and could be improved for the new API,"
" it is possible to use completely different \"old API\" and \"new API\" "
"implementations for the same method name using :func:`~openerp.api.v7` and "
":func:`~openerp.api.v8`. The method should first be defined using the old-"
"API style and decorated with :func:`~openerp.api.v7`, it should then be re-"
"defined using the exact same name but the new-API style and decorated with "
":func:`~openerp.api.v8`. Calls from an old-API context will be dispatched to"
" the first implementation and calls from a new-API context will be "
"dispatched to the second implementation. One implementation can call (and "
"frequently does) call the other by switching context."
msgstr "当直的转换是不可能的（语义不能桥接）或\“旧的API \”版本是不理想的，并为新的API可以改进，有可能使用完全不同的\“旧的API \”和\“新API \“的实现用同样的方法名称：FUNC：`〜openerp.api.v7`和：FUNC：`〜openerp.api.v8`。该方法首先应使用旧的API样式定义，并装饰有：函数：`〜openerp.api.v7`，它应该被重新定义使用完全相同的名称，但新的API的风格和装饰着：FUNC ：`〜openerp.api.v8`。从旧的API方面的电话将被分派到第一次执行，并从一个新的API调用方面将派出第二个执行。一个实现可以调用（并且经常确实）拨打对方通过切换上下文。"

#: ../../reference/orm.rst:1096
msgid ""
"using these decorators makes methods extremely difficult to override and "
"harder to understand and document"
msgstr "使用这些装饰使得方法极难覆盖，更难理解和文档"

#: ../../reference/orm.rst:1098
msgid ""
"uses of :attr:`~openerp.models.Model._columns` or "
":attr:`~openerp.models.Model._all_columns` should be replaced by "
":attr:`~openerp.models.Model._fields`, which provides access to instances of"
" new-style :class:`openerp.fields.Field` instances (rather than old-style "
":class:`openerp.osv.fields._column`)."
msgstr "使用的：ATTR：`〜openerp.models.Model._columns`或：attr：属性：`〜openerp.models.Model._all_columns`应改为`〜openerp.models.Model._fields`，它提供了访问对新风格的实例：类：`openerp.fields.Field`实例（而不是旧式的：类：`openerp.osv.fields._column`）。"

#: ../../reference/orm.rst:1104
msgid ""
"Non-stored computed fields created using the new API style are *not* "
"available in :attr:`~openerp.models.Model._columns` and can only be "
"inspected through :attr:`~openerp.models.Model._fields`"
msgstr "ATTR：`〜openerp.models.Model._columns`，只能通过检查：ATTR：使用新的API的风格是*不*可用在非存储计算领域的`〜openerp.models.Model._fields`"

#: ../../reference/orm.rst:1107
msgid ""
"reassigning ``self`` in a method is probably unnecessary and may break "
"translation introspection"
msgstr "重新分配``的方法self``可能是不必要的，可能会破坏翻译内省"

#: ../../reference/orm.rst:1109
msgid ""
":class:`~openerp.api.Environment` objects rely on some threadlocal state, "
"which has to be set up before using them. It is necessary to do so using the"
" :meth:`openerp.api.Environment.manage` context manager when trying to use "
"the new API in contexts where it hasn't been set up yet, such as new threads"
" or a Python interactive environment::"
msgstr "产品类别：`〜openerp.api.Environment`对象依靠一些ThreadLocal的状态，已被设置为使用它们之前。有必要做这样使用：尝试使用在上下文中它没有被建立，而且，如新的线程或Python交互环境，新的API时`openerp.api.Environment.manage`上下文管理者：甲基::"

#: ../../reference/orm.rst:1131
msgid "Automatic bridging of old API methods"
msgstr "旧的API方法自动桥接"

#: ../../reference/orm.rst:1133
msgid ""
"When models are initialized, all methods are automatically scanned and "
"bridged if they look like models declared in the old API style. This "
"bridging makes them transparently callable from new-API-style methods."
msgstr "当模型被初始化，所有的方法都自动扫描，如果他们看起来像旧风格的API声明车型桥接。这桥接使他们从透明的新API风格的方法调用。"

#: ../../reference/orm.rst:1137
msgid ""
"Methods are matched as \"old-API style\" if their second positional "
"parameter (after ``self``) is called either ``cr`` or ``cursor``. The system"
" also recognizes the third positional parameter being called ``uid`` or "
"``user`` and the fourth being called ``id`` or ``ids``. It also recognizes "
"the presence of any parameter called ``context``."
msgstr "方法进行匹配\“老风格的API \”，如果他们的第二个位置参数（后``self``）被称为是``cr``或``cursor``。该系统还可以识别第三个位置参数被称为``uid``或``user``和第四被称为``id``或``ids``。它还承认所谓的``context``任何参数的存在。"

#: ../../reference/orm.rst:1143
msgid ""
"When calling such methods from a new API context, the system will "
"automatically fill matched parameters from the current "
":class:`~openerp.api.Environment` (for :attr:`~openerp.api.Environment.cr`, "
":attr:`~openerp.api.Environment.user` and "
":attr:`~openerp.api.Environment.context`) or the current recordset (for "
"``id`` and ``ids``)."
msgstr "类：当调用从一个新的API环境这样的方法，系统将自动从目前填补匹配的参数`〜openerp.api.Environment`（适用于：ATTR：`〜openerp.api.Environment.cr`，：ATTR： `〜openerp.api.Environment.user`和：ATTR：`〜openerp.api.Environment.context`）或当前记录（用于``id``和``ids``）。"

#: ../../reference/orm.rst:1150
msgid ""
"In the rare cases where it is necessary, the bridging can be customized by "
"decorating the old-style method:"
msgstr "在极少数情况下，这是必要的，桥接，都可以通过装修旧式方法："

#: ../../reference/orm.rst:1153
msgid ""
"disabling it entirely, by decorating a method with "
":func:`~openerp.api.noguess` there will be no bridging and methods will be "
"called the exact same way from the new and old API styles"
msgstr "禁用它完全由装饰方法：FUNC：`〜openerp.api.noguess`不会有桥接和方法将被调用的新老API风格完全相同的方式"

#: ../../reference/orm.rst:1156
msgid ""
"defining the bridge explicitly, this is mostly for methods which are matched"
" incorrectly (because parameters are named in unexpected ways):"
msgstr "明确界定的桥梁，这主要是为这是正确匹配（因为参数以意想不到的方式命名）方法："

#: ../../reference/orm.rst:1160
msgid ":func:`~openerp.api.cr`"
msgstr "：FUNC：`〜openerp.api.cr`"

#: ../../reference/orm.rst:1160
msgid ""
"will automatically prepend the current cursor to explicitly provided "
"parameters, positionally"
msgstr "会自动在前面加上当前光标有明确规定的参数，在位置"

#: ../../reference/orm.rst:1163
msgid ":func:`~openerp.api.cr_uid`"
msgstr "：FUNC：`〜openerp.api.cr_uid`"

#: ../../reference/orm.rst:1163
msgid ""
"will automatically prepend the current cursor and user's id to explictly "
"provided parameters"
msgstr "会自动在前面加上显式地提供当前光标和用户ID参数"

#: ../../reference/orm.rst:1166
msgid ":func:`~openerp.api.cr_uid_ids`"
msgstr "：FUNC：`〜openerp.api.cr_uid_ids`"

#: ../../reference/orm.rst:1166
msgid ""
"will automatically prepend the current cursor, user's id and recordset's ids"
" to explicitly provided parameters"
msgstr "会自动预先设置当前光标，用户的ID和记录的ID，以明确规定的参数"

#: ../../reference/orm.rst:1174
msgid ":func:`~openerp.api.cr_uid_id`"
msgstr "：FUNC：`〜openerp.api.cr_uid_id`"

#: ../../reference/orm.rst:1169
msgid ""
"will loop over the current recordset and call the method once for each "
"record, prepending the current cursor, user's id and record's id to "
"explicitly provided parameters."
msgstr "会遍历当前记录并调用该方法一次每个记录，在前面加上当前光标，用户的ID和记录的ID明确提供的参数。"

#: ../../reference/orm.rst:1173
msgid ""
"the result of this wrapper is *always a list* when calling from a new-API "
"context"
msgstr "此包装的结果是*总是一个列表*从一个新的API调用的上下文时，"

#: ../../reference/orm.rst:1176
msgid ""
"All of these methods have a ``_context``-suffixed version (e.g. "
":func:`~openerp.api.cr_uid_context`) which also passes the current context "
"*by keyword*."
msgstr "所有这些方法都有一个``_context``-后缀版本（例如：FUNC：`〜openerp.api.cr_uid_context`），这也传递了当前上下文*按关键字*。"

#: ../../reference/orm.rst:1179
msgid ""
"dual implementations using :func:`~openerp.api.v7` and "
":func:`~openerp.api.v8` will be ignored as they provide their own "
"\"bridging\""
msgstr "使用双实现：FUNC：`〜openerp.api.v7`和：FUNC：`〜openerp.api.v8`将被忽略，因为它们提供自己的\“架桥\”"

#: ../../reference/qweb.rst:9 ../../reference/views.rst:1220
msgid "QWeb"
msgstr "QWeb"

#: ../../reference/qweb.rst:11
msgid ""
"QWeb is the primary templating_ engine used by Odoo\\ [#othertemplates]_. It"
" is an XML templating engine\\ [#genshif]_ and used mostly to generate HTML_"
" fragments and pages."
msgstr "QWeb是由Odoo \\ [#othertemplates]主templating_引擎_。这是一个XML模板引擎\\ [#genshif] _和使用主要是为了产生HTML_片段和页面。"

#: ../../reference/qweb.rst:15
msgid ""
"Template directives are specified as XML attributes prefixed with ``t-``, "
"for instance ``t-if`` for :ref:`reference/qweb/conditionals`, with elements "
"and other attributes being rendered directly."
msgstr "模板指令指定为前缀``T-``，例如``T-if``的XML属性：ref：`参考/ qweb / conditionals`，包含元素和其他属性被直接呈现。"

#: ../../reference/qweb.rst:19
msgid ""
"To avoid element rendering, a placeholder element ``<t>`` is also available,"
" which executes its directive but doesn't generate any output in and of "
"itself::"
msgstr "为了避免元素的渲染，一个占位符元素``<T>``也可以，它执行的指令，但不产生任何输出本身并::"

#: ../../reference/qweb.rst:27 ../../reference/qweb.rst:37
#: ../../reference/qweb.rst:311
msgid "will result in::"
msgstr "将导致::"

#: ../../reference/qweb.rst:31
msgid "if ``condition`` is true, but::"
msgstr "如果``condition``是真实的，但::"

#: ../../reference/qweb.rst:46
msgid "data output"
msgstr "数据输出"

#: ../../reference/qweb.rst:48
msgid ""
"QWeb has a primary output directive which automatically HTML-escape its "
"content limiting XSS_ risks when displaying user-provided content: ``esc``."
msgstr "QWeb有一个主输出指令，自动HTML转义其内容限制XSS_显示用户提供的内容时，风险：``esc``。"

#: ../../reference/qweb.rst:51
msgid "``esc`` takes an expression, evaluates it and prints the content::"
msgstr "``esc``需要一个表达式，计算它，并打印内容::"

#: ../../reference/qweb.rst:55
msgid "rendered with the value ``value`` set to ``42`` yields::"
msgstr "与值``呈现value``设置为``42``产量::"

#: ../../reference/qweb.rst:59
msgid ""
"There is one other output directive ``raw`` which behaves the same as "
"respectively ``esc`` but *does not HTML-escape its output*. It can be useful"
" to display separately constructed markup (e.g. from functions) or already "
"sanitized user-provided markup."
msgstr "还有另外一个输出指令``raw``其行为同样分别``esc``但*不HTML-逃脱它的输出*。它可以是有用的，以显示单独构造的标记（例如，从功能）或已消毒用户提供的标记。"

#: ../../reference/qweb.rst:67
msgid "conditionals"
msgstr "条件语句"

#: ../../reference/qweb.rst:69
msgid ""
"QWeb has a conditional directive ``if``, which evaluates an expression given"
" as attribute value::"
msgstr "QWeb有一个条件指令``if``，它计算给定的属性值表达式::"

#: ../../reference/qweb.rst:78
msgid "The element is rendered if the condition is true::"
msgstr "如果条件为真元素呈现::"

#: ../../reference/qweb.rst:84
msgid "but if the condition is false it is removed from the result::"
msgstr "但如果条件为假它从结果中删除::"

#: ../../reference/qweb.rst:89
msgid ""
"The conditional rendering applies to the bearer of the directive, which does"
" not have to be ``<t>``::"
msgstr "有条件的渲染适用于该指令的旗手，这并不一定是``<T>``::"

#: ../../reference/qweb.rst:96
msgid "will give the same results as the previous example."
msgstr "将给出相同的结果的前面的例子。"

#: ../../reference/qweb.rst:101
msgid "loops"
msgstr "环"

#: ../../reference/qweb.rst:103
msgid ""
"QWeb has an iteration directive ``foreach`` which take an expression "
"returning the collection to iterate on, and a second parameter ``t-as`` "
"providing the name to use for the \"current item\" of the iteration::"
msgstr "QWeb有一个迭代指令``foreach``这需要一个表达式返回集合迭代上，而第二个参数``T-as``提供迭代的名称，用于在\“当前项目\”::"

#: ../../reference/qweb.rst:111 ../../reference/qweb.rst:198
#: ../../reference/qweb.rst:210 ../../reference/qweb.rst:221
#: ../../reference/qweb.rst:231
msgid "will be rendered as::"
msgstr "将呈现为::"

#: ../../reference/qweb.rst:117
msgid ""
"Like conditions, ``foreach`` applies to the element bearing the directive's "
"attribute, and"
msgstr "像条件，``foreach``适用于承载指令的属性的元素，和"

#: ../../reference/qweb.rst:126
msgid "is equivalent to the previous example."
msgstr "等同于前面的例子。"

#: ../../reference/qweb.rst:128
msgid ""
"``foreach`` can iterate on an array (the current item will be the current "
"value), a mapping (the current item will be the current key) or an integer "
"(equivalent to iterating on an array between 0 inclusive and the provided "
"integer exclusive)."
msgstr "``foreach``可以在阵列上迭代（当前项目将是当前值），映射（当前项目将是当前键）或一个整数（相当于遍历数组0包容性和所提供的整数值之间独家）。"

#: ../../reference/qweb.rst:133
msgid ""
"In addition to the name passed via ``t-as``, ``foreach`` provides a few "
"other variables for various data points:"
msgstr "除了经由``叔as``通过名称，``foreach``提供了一些其他变量关于各种数据点："

#: ../../reference/qweb.rst:136
msgid "``$as`` will be replaced by the name passed to ``t-as``"
msgstr "``$ as``将被传递给``T-as``的名字被替换"

#: ../../reference/qweb.rst:138
msgid ":samp:`{$as}_all`"
msgstr "：SAMP：`{$为} _all`"

#: ../../reference/qweb.rst:139
msgid "the object being iterated over"
msgstr "该对象被迭代"

#: ../../reference/qweb.rst:141
msgid ":samp:`{$as}_value`"
msgstr "：SAMP：`{$为} _value`"

#: ../../reference/qweb.rst:141
msgid ""
"the current iteration value, identical to ``$as`` for lists and integers, "
"but for mappings it provides the value (where ``$as`` provides the key)"
msgstr "当前迭代值，等同于``$ as``列表和整数，但映射它提供的价值（其中``$ as``提供了关键）"

#: ../../reference/qweb.rst:143
msgid ":samp:`{$as}_index`"
msgstr "：SAMP：`{$为} _index`"

#: ../../reference/qweb.rst:144
msgid ""
"the current iteration index (the first item of the iteration has index 0)"
msgstr "当前迭代指数（迭代的第一个项目的索引0）"

#: ../../reference/qweb.rst:145
msgid ":samp:`{$as}_size`"
msgstr "：SAMP：`{$为} _size`"

#: ../../reference/qweb.rst:146
msgid "the size of the collection if it is available"
msgstr "集合的大小，如果它是可用的"

#: ../../reference/qweb.rst:148
msgid ":samp:`{$as}_first`"
msgstr "：SAMP：`{$为} _first`"

#: ../../reference/qweb.rst:148
msgid ""
"whether the current item is the first of the iteration (equivalent to "
":samp:`{$as}_index == 0`)"
msgstr "无论是目前的项目是第一次迭代（相当于：SAMP：`{$为} _index == 0`）"

#: ../../reference/qweb.rst:152
msgid ":samp:`{$as}_last`"
msgstr "：SAMP：`{$为} _last`"

#: ../../reference/qweb.rst:151
msgid ""
"whether the current item is the last of the iteration (equivalent to "
":samp:`{$as}_index + 1 == {$as}_size`), requires the iteratee's size be "
"available"
msgstr "无论是目前的项目是最后一个迭代（相当于：SAMP：`{$为} _index + 1 == {$为} _size`），要求iteratee的大小可"

#: ../../reference/qweb.rst:154
msgid ":samp:`{$as}_parity`"
msgstr "：SAMP：`{$为} _parity`"

#: ../../reference/qweb.rst:155
msgid "either ``\"even\"`` or ``\"odd\"``, the parity of the current iteration round"
msgstr "无论是``\“即使\”``或``\“奇\”``，当前迭代的奇偶轮"

#: ../../reference/qweb.rst:157
msgid ":samp:`{$as}_even`"
msgstr "：SAMP：`{$为} _even`"

#: ../../reference/qweb.rst:157
msgid ""
"a boolean flag indicating that the current iteration round is on an even "
"index"
msgstr "一个布尔标志，指示当前迭代轮是偶数指数"

#: ../../reference/qweb.rst:162
msgid ":samp:`{$as}_odd`"
msgstr "：SAMP：`{$为} _odd`"

#: ../../reference/qweb.rst:160
msgid ""
"a boolean flag indicating that the current iteration round is on an odd "
"index"
msgstr "一个布尔标志，指示当前迭代轮是奇数指数"

#: ../../reference/qweb.rst:164
msgid ""
"These extra variables provided and all new variables created into the "
"``foreach`` are only available in the scope of the``foreach``. If the "
"variable exists outside the context of the ``foreach``, the value is copied "
"at the end of the foreach into the global context."
msgstr "仅在the``foreach``范围可提供这些额外的变量，并创建成``foreach``所有新的变数。如果变量存在的范围之外的``foreach``，该值被复制在foreach年底到全球范围内。"

#: ../../reference/qweb.rst:186
msgid "attributes"
msgstr "属性"

#: ../../reference/qweb.rst:188
msgid ""
"QWeb can compute attributes on-the-fly and set the result of the computation"
" on the output node. This is done via the ``t-att`` (attribute) directive "
"which exists in 3 different forms:"
msgstr "QWeb可以计算上即时属性和设置在输出节点上的计算的结果。这是通过``叔att``（属性）指示存在于3个不同形式进行："

#: ../../reference/qweb.rst:199
msgid ":samp:`t-att-{$name}`"
msgstr "：SAMP：`T-ATT  -  {$名}`"

#: ../../reference/qweb.rst:193
msgid ""
"an attribute called ``$name`` is created, the attribute value is evaluated "
"and the result is set as the attribute's value::"
msgstr "所谓``创建$ name``的属性，该属性值，并将结果设置为属性的值::"

#: ../../reference/qweb.rst:213
msgid ":samp:`t-attf-{$name}`"
msgstr "：SAMP：`T-AttF设定 -  {$名}`"

#: ../../reference/qweb.rst:202
msgid ""
"same as previous, but the parameter is a :term:`format string` instead of "
"just an expression, often useful to mix literal and non-literal string (e.g."
" classes)::"
msgstr "同以前的，但参数是：期限：`格式string`而不只是一种表达，通常是有用的混合文字和非文字字符串（如类）::"

#: ../../reference/qweb.rst:222
msgid ":samp:`t-att=mapping`"
msgstr "：SAMP：`T-ATT = mapping`"

#: ../../reference/qweb.rst:216
msgid ""
"if the parameter is a mapping, each (key, value) pair generates a new "
"attribute and its value::"
msgstr "如果该参数是一个映射，每一个（键，值）对生成一个新的属性和它的值::"

#: ../../reference/qweb.rst:233
msgid ":samp:`t-att=pair`"
msgstr "：SAMP：`T-ATT = pair`"

#: ../../reference/qweb.rst:225
msgid ""
"if the parameter is a pair (tuple or array of 2 element), the first item of "
"the pair is the name of the attribute and the second item is the value::"
msgstr "如果该参数是一对（元组或2元件的阵列），该对中的第一项是该属性的名称，第二项是值::"

#: ../../reference/qweb.rst:236
msgid "setting variables"
msgstr "设置变量"

#: ../../reference/qweb.rst:238
msgid ""
"QWeb allows creating variables from within the template, to memoize a "
"computation (to use it multiple times), give a piece of data a clearer name,"
" ..."
msgstr "QWeb允许从模板中创建变量，以memoize的运算（使用它多次），得到一块数据更清晰名称，..."

#: ../../reference/qweb.rst:242
msgid ""
"This is done via the ``set`` directive, which takes the name of the variable"
" to create. The value to set can be provided in two ways:"
msgstr "这是通过``set``指令，这需要创建变量的名称做了。设置该值可以通过两种方式提供："

#: ../../reference/qweb.rst:245
msgid ""
"a ``t-value`` attribute containing an expression, and the result of its "
"evaluation will be set::"
msgstr "一个``T-value``属性包含一个表达式，其评价结果将被设置::"

#: ../../reference/qweb.rst:251
msgid "will print ``3``"
msgstr "将打印``3``"

#: ../../reference/qweb.rst:252
msgid ""
"if there is no ``t-value`` attribute, the node's body is rendered and set as"
" the variable's value::"
msgstr "如果没有``叔value``属性，节点的体渲染，并设置作为变量的值::"

#: ../../reference/qweb.rst:260
msgid ""
"will generate ``&lt;li&gt;ok&lt;/li&gt;`` (the content is escaped as we used"
" the ``esc`` directive)"
msgstr "会产生``＆LT;李＆GT;确定＆LT; /李＆GT;``（内容为我们所用的``esc``指令转义）"

#: ../../reference/qweb.rst:263
msgid ""
"using the result of this operation is a significant use-case for the ``raw``"
" directive."
msgstr "使用此操作的结果是一个显著用例为``raw``指令。"

#: ../../reference/qweb.rst:267
msgid "calling sub-templates"
msgstr "调用子模板"

#: ../../reference/qweb.rst:269
msgid ""
"QWeb templates can be used for top-level rendering, but they can also be "
"used from within another template (to avoid duplication or give names to "
"parts of templates) using the ``t-call`` directive::"
msgstr "QWeb模板可用于顶层的渲染，但它们也可以从另一个模板用于使用``叔call``指令（以避免重复或模板零件给名称）::"

#: ../../reference/qweb.rst:275
msgid ""
"This calls the named template with the execution context of the parent, if "
"``other_template`` is defined as::"
msgstr "这需要与母公司的执行上下文的命名模板，如果``other_template``被定义为::"

#: ../../reference/qweb.rst:280
msgid "the call above will be rendered as ``<p/>`` (no content), but::"
msgstr "通话以上将呈现为``<P />``（没有内容），但::"

#: ../../reference/qweb.rst:285
msgid "will be rendered as ``<p>1</p>``."
msgstr "将呈现为``<P> 1 </ P>``。"

#: ../../reference/qweb.rst:287
msgid ""
"However this has the problem of being visible from outside the ``t-call``. "
"Alternatively, content set in the body of the ``call`` directive will be "
"evaluated *before* calling the sub-template, and can alter a local context::"
msgstr "然而，这有被从``T-call``外面看到的问题。可替代地，在``call``指令的主体设定内容将被评估* *前调用子模板，并且可以改变本地上下文::"

#: ../../reference/qweb.rst:296
msgid ""
"The body of the ``call`` directive can be arbitrarily complex (not just "
"``set`` directives), and its rendered form will be available within the "
"called template as a magical ``0`` variable::"
msgstr "在``call``指令的主体可以是任意复杂的（不只是``set``指令），其呈现形式会被调用模板，一个神奇的``内可0``可变::"

#: ../../reference/qweb.rst:305
msgid "being called thus::"
msgstr "因此被称为::"

#: ../../reference/qweb.rst:322 ../../reference/qweb.rst:421
msgid "Exclusive directives"
msgstr "独家指令"

#: ../../reference/qweb.rst:325
msgid "asset bundles"
msgstr "资产包"

#: ../../reference/qweb.rst:330
msgid "\"smart records\" fields formatting"
msgstr "\“智能记载\”的字段格式"

#: ../../reference/qweb.rst:332
msgid ""
"The ``t-field`` directive can only be used when performing field access "
"(``a.b``) on a \"smart\" record (result of the ``browse`` method). It is "
"able to automatically format based on field type, and is integrated in the "
"website's rich text edition."
msgstr "进行现场访问（``ab``）在\“智能\”记录（``browse``方法的结果）时，``T-field``指令只能用。它能够根据字段类型，自动格式化，并集成在网站的富文本编辑。"

#: ../../reference/qweb.rst:337
msgid ""
"``t-field-options`` can be used to customize fields, the most common option "
"is ``widget``, other options are field- or widget-dependent."
msgstr "``叔场options``可以用来定制字段，最常见的方法是``widget``，其他选项是现场或插件依赖性。"

#: ../../reference/qweb.rst:341 ../../reference/qweb.rst:487
msgid "debugging"
msgstr "调试"

#: ../../reference/qweb.rst:349 ../../reference/qweb.rst:506
msgid "``t-debug``"
msgstr "``T-debug``"

#: ../../reference/qweb.rst:344
msgid ""
"invokes a debugger using PDB's ``set_trace`` API. The parameter should be "
"the name of a module, on which a ``set_trace`` method is called::"
msgstr "调用使用PDB的``set_trace`` API调试器。参数应该是一个模块，在其上``set_trace``方法被调用的名字::"

#: ../../reference/qweb.rst:349
msgid "is equivalent to ``importlib.import_module(\"pdb\").set_trace()``"
msgstr "相当于``importlib.import_module（\“PDB \”）。set_trace（）``"

#: ../../reference/qweb.rst:352 ../../reference/qweb.rst:519
msgid "Helpers"
msgstr "助手"

#: ../../reference/qweb.rst:355
msgid "Request-based"
msgstr "基于请求"

#: ../../reference/qweb.rst:357
msgid ""
"Most Python-side uses of QWeb are in controllers (and during HTTP requests),"
" in which case templates stored in the database (as :ref:`views "
"<reference/views/qweb>`) can be trivially rendered by calling "
":meth:`openerp.http.HttpRequest.render`:"
msgstr "QWeb大多数的Python端的用途是在控制器（并在HTTP请求），在这种情况下模板存储在数据库中（如：参考：`观点<参考/视图/ qweb>`）可以平凡致电呈现：甲： `openerp.http.HttpRequest.render`："

#: ../../reference/qweb.rst:368
msgid ""
"This automatically creates a :class:`~openerp.http.Response` object which "
"can be returned from the controller (or further customized to suit)."
msgstr "这会自动创建一个：类：可从控制器返回（或进一步定制，以适应）`〜openerp.http.Response`对象。"

#: ../../reference/qweb.rst:372
msgid "View-based"
msgstr "基于视图的"

#: ../../reference/qweb.rst:374
msgid ""
"At a deeper level than the previous helper is the ``render`` method on "
"``ir.ui.view``:"
msgstr "在更深的层次比前助手是``ir.ui.view``的``render``方法："

#: ../../reference/qweb.rst:379
msgid ""
"Renders a QWeb view/template by database id or :term:`external id`. "
"Templates are automatically loaded from ``ir.ui.view`` records."
msgstr "渲染一个QWeb视图/模板，数据库ID或者：期限：`外部ID`。模板是从``ir.ui.view``记录自动加载。"

#: ../../reference/qweb.rst:382
msgid "Sets up a number of default values in the rendering context:"
msgstr "设置若干在呈现上下文的默认值："

#: ../../reference/qweb.rst:384
msgid "``request``"
msgstr "``request``"

#: ../../reference/qweb.rst:385
msgid "the current :class:`~openerp.http.WebRequest` object, if any"
msgstr "当前：类：`〜openerp.http.WebRequest`对象，如果有的话"

#: ../../reference/qweb.rst:386
msgid "``debug``"
msgstr "``debug``"

#: ../../reference/qweb.rst:387
msgid "whether the current request (if any) is in ``debug`` mode"
msgstr "当前请求（如果有的话）是否在``debug``模式"

#: ../../reference/qweb.rst:388
msgid ":func:`quote_plus <werkzeug.urls.url_quote_plus>`"
msgstr "：FUNC：`quote_plus <werkzeug.urls.url_quote_plus>`"

#: ../../reference/qweb.rst:389
msgid "url-encoding utility function"
msgstr "URL编码的效用函数"

#: ../../reference/qweb.rst:390
msgid ":mod:`json`"
msgstr "：MOD：`json`"

#: ../../reference/qweb.rst:391 ../../reference/qweb.rst:393
#: ../../reference/qweb.rst:395
msgid "the corresponding standard library module"
msgstr "相应的标准库模块"

#: ../../reference/qweb.rst:392
msgid ":mod:`time`"
msgstr "：MOD：`time`"

#: ../../reference/qweb.rst:394
msgid ":mod:`datetime`"
msgstr "：MOD：`datetime`"

#: ../../reference/qweb.rst:396
msgid ""
"`relativedelta <https://labix.org/python-dateutil#head-"
"ba5ffd4df8111d1b83fc194b97ebecf837add454>`_"
msgstr "`relativedelta <https://labix.org/python-dateutil#head-ba5ffd4df8111d1b83fc194b97ebecf837add454>`_"

#: ../../reference/qweb.rst:397
msgid "see module"
msgstr "见模块"

#: ../../reference/qweb.rst:399
msgid "``keep_query``"
msgstr "``keep_query``"

#: ../../reference/qweb.rst:399
msgid "the ``keep_query`` helper function"
msgstr "在``keep_query``辅助函数"

#: ../../reference/qweb.rst:401
msgid "context values to pass to QWeb for rendering"
msgstr "上下文值传递给QWeb渲染"

#: ../../reference/qweb.rst:402
msgid ""
"name of the Odoo model to use for rendering, can be used to expand or "
"customize QWeb locally (by creating a \"new\" qweb based on ``ir.qweb`` with"
" alterations)"
msgstr "用于渲染的Odoo模型的名称，可以用来扩展或局部地定制QWeb（通过创建\“新\”qweb根据``ir.qweb``与改建）"

#: ../../reference/qweb.rst:409 ../../reference/qweb.rst:531
msgid "API"
msgstr "API"

#: ../../reference/qweb.rst:411
msgid ""
"It is also possible to use the ``ir.qweb`` model directly (and extend it, "
"and inherit from it):"
msgstr "另外，也可以使用``ir.qweb``直接模型（和扩展它，并从它继承）："

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb:1
msgid "Base QWeb rendering engine"
msgstr "基地QWeb渲染引擎"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb:3
msgid ""
"to customize ``t-field`` rendering, subclass ``ir.qweb.field`` and create "
"new models called :samp:`ir.qweb.field.{widget}`"
msgstr "定制``T-field``渲染，子``ir.qweb.field``，创造新的模式叫做：SAMP：`ir.qweb.field {小部件}`"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb:5
msgid ""
"alternatively, override :meth:`~.get_converter_for` and return an arbitrary "
"model to use as field converter"
msgstr "另外，覆盖：甲：`〜.get_converter_for`并返回一个任意模型场变换使用"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb:8
msgid ""
"Beware that if you need extensions or alterations which could be "
"incompatible with other subsystems, you should create a local object "
"inheriting from ``ir.qweb`` and customize that."
msgstr "要注意的是，如果你需要扩展或改变这可能是与其他子系统兼容，您应该创建``ir.qweb``继承一个本地对象和自定义。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.get_converter_for:1
msgid "returns a :class:`~openerp.models.Model` used to render a ``t-field``."
msgstr "返回：类：`〜openerp.models.Model`用于渲染``T-field``。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.get_converter_for:4
msgid ""
"By default, tries to get the model named :samp:`ir.qweb.field.{field_type}`,"
" falling back on ``ir.qweb.field``."
msgstr "默认情况下，试图获得命名的模型：SAMP：`ir.qweb.field {field_type}`上``ir.qweb.field``回落。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.get_converter_for:7
msgid "type or widget of field to render"
msgstr "类型或场的小窗口来呈现"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.get_widget_for:1
msgid "returns a :class:`~openerp.models.Model` used to render a ``t-esc``"
msgstr "返回：类：`〜openerp.models.Model`用于渲染``T-esc``"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.get_widget_for:4
msgid "name of the widget to use, or ``None``"
msgstr "使用该部件的名称，或``None``"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.prefixed_methods:1
msgid ""
"Extracts all methods prefixed by ``prefix``, and returns a mapping of "
"(t-name, method) where the t-name is the method name with prefix removed and"
" underscore converted to dashes"
msgstr "提取由``prefix``前缀的所有方法，并返回（T-名，方法）的映射，其中T-名称与前缀的方法名称中删除，并强调转化为破折号"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.prefixed_methods:6
msgid "dict"
msgstr "快译通"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.render:1
msgid "Renders the template specified by the provided template name"
msgstr "呈现在提供的模板名称指定的模板"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.render:3
msgid "context for rendering the template"
msgstr "上下文将所述模板呈现"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.render:5
msgid ""
"if ``qwebcontext`` is a dict, loader set into the context instantiated for "
"rendering"
msgstr "如果``qwebcontext``是一个字典，装载机设置成实例化渲染上下文"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.render_tag_call_assets:1
msgid ""
"This special 't-call' tag can be used in order to aggregate/minify "
"javascript and css assets"
msgstr "这种特殊的“T-通话”标签可以以聚合中使用/缩小JavaScript和CSS的资产"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.QWeb.render_tag_field:1
msgid ""
"eg: <span t-record=\"browse_record(res.partner, 1)\" t-field=\"phone\">+1 "
"555 555 8069</span>"
msgstr "例如：<跨度T-纪录= \“browse_record（res.partner，1）\”T-场= \“电话\”> + 1 555 555 8069 </ SPAN>"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter:1
msgid "Used to convert a t-field specification into an output HTML field."
msgstr "用于转换叔字段规范成输出HTML字段。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter:3
msgid ":meth:`~.to_html` is the entry point of this conversion from QWeb, it:"
msgstr "：甲基：`〜.to_html`距离QWeb这种转换的进入点，它："

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter:5
msgid "converts the record value to html using :meth:`~.record_to_html`"
msgstr "转换记录值的HTML使用：甲：`〜.record_to_html`"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter:6
msgid ""
"generates the metadata attributes (``data-oe-``) to set on the root result "
"node"
msgstr "生成的元数据属性（``数据-OE-``）到根的结果节点上设置"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter:8
msgid "generates the root result node itself through :meth:`~.render_element`"
msgstr "产生的根源结果节点本身通过：甲：`〜.render_element`"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:1
msgid ""
"Generates the metadata attributes (prefixed by ``data-oe-`` for the root "
"node of the field conversion. Attribute values are escaped by the parent."
msgstr "生成的元数据属性（由前缀``数据-OE-``的字段转换的根节点。属性值由父逃过一劫。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:5
msgid "The default attributes are:"
msgstr "默认属性是："

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:7
msgid "``model``, the name of the record's model"
msgstr "``model``，记录的型号名称"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:8
msgid "``id`` the id of the record to which the field belongs"
msgstr "``id``到外地所属的记录的ID"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:9
msgid "``field`` the name of the converted field"
msgstr "``field``转换的字段的名称"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:10
msgid ""
"``type`` the logical field type (widget, may not match the field's ``type``,"
" may not be any Field subclass name)"
msgstr "``type``逻辑字段类型（窗口小部件，可能不会匹配字段的``type``，可能没有任何字段子类名）"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:12
msgid ""
"``translate``, a boolean flag (``0`` or ``1``) denoting whether the field is"
" translatable"
msgstr "``translate``，一个布尔标志（``0``或``1``）表示字段是翻译"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:14
msgid "``readonly``, has this attribute if the field is readonly"
msgstr "``readonly``，有这个属性，如果该字段为readonly"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:15
msgid "``expression``, the original expression"
msgstr "``expression``，原始表达式"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.attributes:17
msgid "iterable of (attribute name, attribute value) pairs."
msgstr "的迭代（属性名，属性值）对。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.record_to_html:1
msgid "Converts the specified field of the browse_record ``record`` to HTML"
msgstr "在browse_record``record`` HTML的特定字段转换"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.render_element:1
msgid ""
"Final rendering hook, by default just calls ir.qweb's ``render_element``"
msgstr "最终渲染挂钩，在默认情况下只是调用ir.qweb的``render_element``"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.to_html:1
msgid ""
"Converts a ``t-field`` to its HTML output. A ``t-field`` may be extended by "
"a ``t-field-options``, which is a JSON-serialized mapping of configuration "
"values."
msgstr "一个``T-field``到它的HTML输出转换。一个``T-field``可以通过``T-现场options``，这是配置值的JSON序列化映射进行扩展。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.to_html:5
msgid ""
"A default configuration key is ``widget`` which can override the field's own"
" ``_type``."
msgstr "默认配置关键是``widget``可以覆盖领域自身的``_type``。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.user_lang:1
msgid ""
"Fetches the res.lang object corresponding to the language code stored in the"
" user's context. Fallbacks to en_US if no lang is present in the context *or"
" the language code is not valid*."
msgstr "取对应于存储在用户的上下文的语言码的res.lang对象。回退为en_US如果没有lang是存在于上下文*或语言代码无效*。"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.user_lang:5
msgid "res.lang browse_record"
msgstr "res.lang browse_record"

#: ../../../openerp/addons/base/ir/ir_qweb.pydocstring of
#: openerp.addons.base.ir.ir_qweb.FieldConverter.value_to_html:1
msgid "Converts a single value to its HTML version/output"
msgstr "一个单一的值转换为其HTML版本/输出"

#: ../../reference/qweb.rst:424
msgid "defining templates"
msgstr "定义模板"

#: ../../reference/qweb.rst:426
msgid ""
"The ``t-name`` directive can only be placed at the top-level of a template "
"file (direct children to the document root)::"
msgstr "该``T-name``指令只能放置在一个模板文件（直接子文档根目录）的顶级::"

#: ../../reference/qweb.rst:435
msgid ""
"It takes no other parameter, but can be used with a ``<t>`` element or any "
"other. With a ``<t>`` element, the ``<t>`` should have a single child."
msgstr "它不带任何其他参数，但可以用``<T>``元素或任何其他使用。有了``<T>``元素，在``<T>``应该有一个孩子。"

#: ../../reference/qweb.rst:438
msgid ""
"The template name is an arbitrary string, although when multiple templates "
"are related (e.g. called sub-templates) it is customary to use dot-separated"
" names to indicate hierarchical relationships."
msgstr "模板名称是任意的字符串，虽然当多个模板相关（例如被称为子模板），这是习惯用点分隔的名字来表示层次关系。"

#: ../../reference/qweb.rst:443
msgid "template inheritance"
msgstr "模板继承"

#: ../../reference/qweb.rst:445
msgid ""
"Template inheritance is used to alter existing templates in-place, e.g. to "
"add information to templates created by an other modules."
msgstr "模板继承用于改变就地现有模板，如将信息添加到由其他模块创建的模板。"

#: ../../reference/qweb.rst:448
msgid ""
"Template inheritance is performed via the ``t-extend`` directive which takes"
" the name of the template to alter as parameter."
msgstr "模板继承是通过``T-extend``指令，它采用了模板的名称更改为参数进行。"

#: ../../reference/qweb.rst:451
msgid ""
"The alteration is then performed with any number of ``t-jquery`` sub-"
"directives::"
msgstr "然后用任何数量的``叔jquery``子指令进行变更::"

#: ../../reference/qweb.rst:460
msgid ""
"The ``t-jquery`` directives takes a `CSS selector`_. This selector is used "
"on the extended template to select *context nodes* to which the specified "
"``t-operation`` is applied:"
msgstr "该``T-jquery``指令需要一个`CSS selector`_。这个选择是用在扩展模板选择*上下文节点*它指定``T-operation``适用于："

#: ../../reference/qweb.rst:465
msgid "``append``"
msgstr "``append``"

#: ../../reference/qweb.rst:465
msgid ""
"the node's body is appended at the end of the context node (after the "
"context node's last child)"
msgstr "该节点的尸体是在上下文节点的末尾附加（上下文节点的最后一个孩子后）"

#: ../../reference/qweb.rst:468
msgid "``prepend``"
msgstr "``prepend``"

#: ../../reference/qweb.rst:468
msgid ""
"the node's body is prepended to the context node (inserted before the "
"context node's first child)"
msgstr "该节点的身体被前置到上下文节点（上下文节点的第一个孩子之前插入）"

#: ../../reference/qweb.rst:470 ../../reference/views.rst:100
msgid "``before``"
msgstr "``before``"

#: ../../reference/qweb.rst:471
msgid "the node's body is inserted right before the context node"
msgstr "节点的体插入上下文节点之前右"

#: ../../reference/qweb.rst:472 ../../reference/views.rst:97
msgid "``after``"
msgstr "``after``"

#: ../../reference/qweb.rst:473
msgid "the node's body is inserted right after the context node"
msgstr "节点的体插入上下文节点之后"

#: ../../reference/qweb.rst:474
msgid "``inner``"
msgstr "``inner``"

#: ../../reference/qweb.rst:475
msgid "the node's body replaces the context node's children"
msgstr "该节点的身体替换上下文节点的孩子"

#: ../../reference/qweb.rst:476 ../../reference/views.rst:94
msgid "``replace``"
msgstr "``replace``"

#: ../../reference/qweb.rst:477
msgid "the node's body is used to replace the context node itself"
msgstr "节点的主体是用来取代上下文节点本身"

#: ../../reference/qweb.rst:484
msgid "No operation"
msgstr "无操作"

#: ../../reference/qweb.rst:479
msgid ""
"if no ``t-operation`` is specified, the template body is interpreted as "
"javascript code and executed with the context node as ``this``"
msgstr "如果没有指定``T-operation``时，模板身体被解释为JavaScript代码，并与上下文节点为``this``执行"

#: ../../reference/qweb.rst:482
msgid ""
"while much more powerful than other operations, this mode is also much "
"harder to debug and maintain, it is recommended to avoid it"
msgstr "而多比其他操作更有力，这种模式也更难调试和维护时，建议避免它"

#: ../../reference/qweb.rst:489
msgid "The javascript QWeb implementation provides a few debugging hooks:"
msgstr "JavaScript的QWeb实施提供了一些调试钩："

#: ../../reference/qweb.rst:497
msgid "``t-log``"
msgstr "``T-log``"

#: ../../reference/qweb.rst:492
msgid ""
"takes an expression parameter, evaluates the expression during rendering and"
" logs its result with ``console.log``::"
msgstr "接受一个表达式的参数，在渲染过程中计算表达式并记录其结果与``console.log`` ::"

#: ../../reference/qweb.rst:498
msgid "will print ``42`` to the console"
msgstr "将打印``42``到控制台"

#: ../../reference/qweb.rst:500
msgid "triggers a debugger breakpoint during template rendering::"
msgstr "在触发模板呈现一个调试器断点::"

#: ../../reference/qweb.rst:506
msgid ""
"will stop execution if debugging is active (exact condition depend on the "
"browser and its development tools)"
msgstr "将停止执行，如果调试有效（具体情况取决于浏览器及其开发工具）"

#: ../../reference/qweb.rst:516
msgid "``t-js``"
msgstr "``T-js``"

#: ../../reference/qweb.rst:509
msgid ""
"the node's body is javascript code executed during template rendering. Takes"
" a ``context`` parameter, which is the name under which the rendering "
"context will be available in the ``t-js``'s body::"
msgstr "该节点的身体是在模板渲染执行JavaScript代码。需要``context``参数，这是根据该渲染上下文将在``T-js``的体内可用的名字::"

#: ../../reference/qweb.rst:523
msgid ""
"(core is the ``web.core`` module) An instance of :js:class:`QWeb2.Engine` "
"with all module-defined template files loaded, and references to standard "
"helper objects ``_`` (underscore), ``_t`` (translation function) and JSON_."
msgstr "（核心是``web.core``模块）的实例：JS：类：`QWeb2.Engine`与加载的所有模块定义的模板文件，并引用标准辅助对象``_``（下划线）， ``_t``（转换功能）和JSON_。"

#: ../../reference/qweb.rst:527
msgid ""
":js:func:`core.qweb.render <QWeb2.Engine.render>` can be used to easily "
"render basic module templates"
msgstr "：JS：FUNC：`core.qweb.render <QWeb2.Engine.render>`可以用来方便地呈现基本模块模板"

#: ../../reference/qweb.rst:535
msgid ""
"The QWeb \"renderer\", handles most of QWeb's logic (loading, parsing, "
"compiling and rendering templates)."
msgstr "该QWeb \“呈现\”，处理大部分QWeb的逻辑（加载，解析，编译和执行模板）。"

#: ../../reference/qweb.rst:538
msgid ""
"OpenERP Web instantiates one for the user in the core module, and exports it"
" to ``core.qweb``. It also loads all the template files of the various "
"modules into that QWeb instance."
msgstr "OpenERP的网站实例化一个是核心模块中的用户，并出口到``core.qweb``。它还加载了各种模块的所有模板文件到该QWeb实例。"

#: ../../reference/qweb.rst:542
msgid "A :js:class:`QWeb2.Engine` also serves as a \"template namespace\"."
msgstr "答：JS：类：`QWeb2.Engine`也作为一个\“模板命名空间\”。"

#: ../../reference/qweb.rst:546
msgid ""
"Renders a previously loaded template to a String, using ``context`` (if "
"provided) to find the variables accessed during template rendering (e.g. "
"strings to display)."
msgstr "渲染以前加载的模板，一个字符串，使用``context``（如果有的话），以找到在模板渲染访问（如字符串显示）的变量。"

#: ../../reference/qweb.rst:550
msgid "the name of the template to render"
msgstr "呈现模板的名称"

#: ../../reference/qweb.rst:551
msgid "the basic namespace to use for template rendering"
msgstr "的基本名字空间要用于模板渲染"

#: ../../reference/qweb.rst:553
msgid "String"
msgstr "弦"

#: ../../reference/qweb.rst:555
msgid ""
"The engine exposes an other method which may be useful in some cases (e.g. "
"if you need a separate template namespace with, in OpenERP Web, Kanban views"
" get their own :js:class:`QWeb2.Engine` instance so their templates don't "
"collide with more general \"module\" templates):"
msgstr "该引擎公开这可能是在某些情况下非常有用（例如，如果你需要一个单独的模板命名空间，在OpenERP的网页，看板的观点得到自己的另一种方法：JS：类：`QWeb2.Engine`实例，以便他们的模板不碰撞更一般的\“模块\”模板）："

#: ../../reference/qweb.rst:563
msgid ""
"Loads a template file (a collection of templates) in the QWeb instance. The "
"templates can be specified as:"
msgstr "加载中QWeb实例的模板文件（模板的集合）。模板可以指定为："

#: ../../reference/qweb.rst:568
msgid "An XML string"
msgstr "XML字符串"

#: ../../reference/qweb.rst:567
msgid "QWeb will attempt to parse it to an XML document then load it."
msgstr "QWeb会尝试将其解析为一个XML文档然后将其加载。"

#: ../../reference/qweb.rst:572
msgid "A URL"
msgstr "一个URL"

#: ../../reference/qweb.rst:571
msgid ""
"QWeb will attempt to download the URL content, then load the resulting XML "
"string."
msgstr "QWeb会尝试下载的URL的内容，然后加载生成的XML字符串。"

#: ../../reference/qweb.rst:577
msgid "A ``Document`` or ``Node``"
msgstr "一个``Document``或``Node``"

#: ../../reference/qweb.rst:575
msgid ""
"QWeb will traverse the first level of the document (the child nodes of the "
"provided root) and load any named template or template override."
msgstr "QWeb将遍历文档（所提供的根的子节点）的第一级和装载任何命名模板或模板覆盖。"

#: ../../reference/qweb.rst:581
msgid ""
"A :js:class:`QWeb2.Engine` also exposes various attributes for behavior "
"customization:"
msgstr "答：JS：类：`QWeb2.Engine`也暴露了行为定制各种属性："

#: ../../reference/qweb.rst:586
msgid ""
"Prefix used to recognize directives during parsing. A string. By default, "
"``t``."
msgstr "前缀用于在分析过程中识别的指令。一个字符串。默认情况下，``t``。"

#: ../../reference/qweb.rst:591
msgid ""
"Boolean flag putting the engine in \"debug mode\". Normally, QWeb intercepts"
" any error raised during template execution. In debug mode, it leaves all "
"exceptions go through without intercepting them."
msgstr "布尔标志，把发动机\“调试模式\”。通常情况下，QWeb拦截模板执行过程中提出的任何错误。在调试模式下，它使所有的异常经历，而不拦截它们。"

#: ../../reference/qweb.rst:598
msgid ""
"The jQuery instance used during template inheritance processing. Defaults to"
" ``window.jQuery``."
msgstr "模板继承处理期间使用了jQuery实例。默认为``window.jQuery``。"

#: ../../reference/qweb.rst:603
msgid ""
"A ``Function``. If present, called before compiling each DOM node to "
"template code. In OpenERP Web, this is used to automatically translate text "
"content and some attributes in templates. Defaults to ``null``."
msgstr "一个``Function``。如果存在，被称为编译每个DOM节点模板代码之前。在的OpenERP网络，这是用来自动翻译文字内容和在模板一些属性。默认为``null``。"

#: ../../reference/qweb.rst:608
msgid ""
"it is similar in that to Genshi_, although it does not use (and has no "
"support for) `XML namespaces`_"
msgstr "这是在给​​Genshi_类似，虽然它没有使用（而且没有支持）`XML namespaces`_"

#: ../../reference/qweb.rst:611
msgid ""
"although it uses a few others, either for historical reasons or because they"
" remain better fits for the use case. Odoo 8.0 still depends on Jinja_ and "
"Mako_."
msgstr "虽然它采用的是少数人，无论是对历史的原因，或者是因为他们仍然在用例更适合。 Odoo 8.0仍取决于Jinja_和Mako_。"

#: ../../reference/reports.rst:7
msgid "QWeb Reports"
msgstr "QWeb报告"

#: ../../reference/reports.rst:9
msgid ""
"Reports are written in HTML/QWeb, like all regular views in Odoo. You can "
"use the usual :ref:`QWeb control flow tools <reference/qweb>`. The PDF "
"rendering itself is performed by wkhtmltopdf_."
msgstr "报告将写入HTML / QWeb，就像Odoo所有常规视图。你可以用通常的：REF：`QWeb控制流工具<参考/ qweb>`。 PDF呈现本身由wkhtmltopdf_执行。"

#: ../../reference/reports.rst:13
msgid ""
"If you want to create a report on a certain model, you will need to define "
"this :ref:`reference/reports/report` and the "
":ref:`reference/reports/templates` it will use. If you wish, you can also "
"specify a specific :ref:`reference/reports/paper_formats` for this report. "
"Finally, if you need access to more than your model, you can define a "
":ref:`reference/reports/custom_reports` class that gives you access to more "
"models and records in the template."
msgstr "如果你想创建一个特定的模式的报告，您需要定义是：参考：`参考/报告/ report`和：REF：`参考/报告/ templates`它将使用。如果你愿意，你也可以指定一个特定的：参考：`参考/报告/ paper_formats`此报告。最后，如​​果你需要获得超过你的模型，你可以定义：参考：`参考/报告/ custom_reports`类，让你获得更多的车型和记录在模板中。"

#: ../../reference/reports.rst:24
msgid "Report"
msgstr "报道"

#: ../../reference/reports.rst:26
msgid ""
"Every report must be declared by a :ref:`report action "
"<reference/actions/report>`."
msgstr "参考：`报告采取行动<参考/动作/报告>`每个报告必须由一个声明。"

#: ../../reference/reports.rst:29
msgid ""
"For simplicity, a shortcut ``<report>`` element is available to define a "
"report, rather than have to set up :ref:`the action "
"<reference/actions/report>` and its surroundings manually. That ``<report>``"
" can take the following attributes:"
msgstr "为了简单，快捷``<报告>``元素可用于定义报表，而不是必须设置：参考：`动作手动<参考/动作/报告>`及其周边地区。这``<报告>``可以采取以下属性："

#: ../../reference/reports.rst:35
msgid "the generated record's :term:`external id`"
msgstr "生成记录的：期限：`外部ID`"

#: ../../reference/reports.rst:49
msgid ""
"if set to True, the report will be stored as an attachment of the record "
"using the name generated by the ``attachment`` expression; you can use this "
"if you need your report to be generated only once (for legal reasons, for "
"example)"
msgstr "如果设置为True，则报告将被存储为使用由``attachment``表达式生成的名称记录的附件;你可以使用这个，如果你需要你的报告中只生成一次（由于法律原因，例如）"

#: ../../reference/reports.rst:54
msgid ""
"python expression that defines the name of the report; the record is "
"acessible as the variable ``object``"
msgstr "定义报表的名称蟒蛇表达;记录是acessible作为变量``object``"

#: ../../reference/reports.rst:59
msgid ""
"The paper format cannot currently be declared via the ``<report>`` shortcut,"
" it must be added afterwards using a ``<record>`` extension on the report "
"action itself::"
msgstr "纸张格式目前不能通过声明的``<报告>``快捷方式，则必须在事后用``<记录>``扩展的报告采取行动本身添加::"

#: ../../reference/reports.rst:67 ../../reference/reports.rst:263
msgid "Example::"
msgstr "例如::"

#: ../../reference/reports.rst:84
msgid "Report template"
msgstr "报告模板"

#: ../../reference/reports.rst:88
msgid "Minimal viable template"
msgstr "最小可行模板"

#: ../../reference/reports.rst:90
msgid "A minimal template would look like::"
msgstr "一个最小的模板会是什么样子::"

#: ../../reference/reports.rst:105
msgid ""
"Calling ``external_layout`` will add the default header and footer on your "
"report. The PDF body will be the content inside the ``<div "
"class=\"page\">``. The template's ``id`` must be the name specified in the "
"report declaration; for example ``account.report_invoice`` for the above "
"report. Since this is a QWeb template, you can access all the fields of the "
"``docs`` objects received by the template."
msgstr "调用``external_layout``将添加默认的页眉和页脚在报表上。 PDF格式的身体会里面的``<DIV CLASS = \“页\”>``内容。模板的``id``必须在报告中声明指定的名称;例如``account.report_invoice``对上述报告。由于这是一个QWeb模板，您可以访问由模板收到的``docs``对象的所有领域。"

#: ../../reference/reports.rst:112
msgid "There are some specific variables accessible in reports, mainly:"
msgstr "有报告中访问一些特定的变量，主要是："

#: ../../reference/reports.rst:114
msgid "``docs``"
msgstr "``docs``"

#: ../../reference/reports.rst:115
msgid "records for the current report"
msgstr "因为目前的报告记录"

#: ../../reference/reports.rst:116
msgid "``doc_ids``"
msgstr "``doc_ids``"

#: ../../reference/reports.rst:117
msgid "list of ids for the ``docs`` records"
msgstr "IDS为``docs``记录列表"

#: ../../reference/reports.rst:118
msgid "``doc_model``"
msgstr "``doc_model``"

#: ../../reference/reports.rst:119
msgid "model for the ``docs`` records"
msgstr "型号为``docs``记录"

#: ../../reference/reports.rst:120
msgid "``time``"
msgstr "``time``"

#: ../../reference/reports.rst:121
msgid "a reference to :mod:`python:time` from the Python standard library"
msgstr "从Python标准库time`：引用：MOD：`蟒蛇"

#: ../../reference/reports.rst:123
msgid "``res.user`` record for the user printing the report"
msgstr "``res.user``记录用户打印报表"

#: ../../reference/reports.rst:125
msgid "``res_company``"
msgstr "``res_company``"

#: ../../reference/reports.rst:125
msgid "record for the current ``user``'s company"
msgstr "当前``user``的公司纪录"

#: ../../reference/reports.rst:127
msgid ""
"If you wish to access other records/models in the template, you will need "
":ref:`a custom report <reference/reports/custom_reports>`."
msgstr "如果要访问其他记录/模型模板中，你将需要：参考：`自定义报告<参考/报告/ custom_reports>`。"

#: ../../reference/reports.rst:131
msgid "Translatable Templates"
msgstr "可翻译模板"

#: ../../reference/reports.rst:133
msgid ""
"If you wish to translate reports (to the language of a partner, for "
"example), you need to define two templates:"
msgstr "如果你要翻译报告（给合作伙伴的语言，例如），您需要定义两个模板："

#: ../../reference/reports.rst:136
msgid "The main report template"
msgstr "主报告模板"

#: ../../reference/reports.rst:137
msgid "The translatable document"
msgstr "在翻译的文件"

#: ../../reference/reports.rst:139
msgid ""
"You can then call the translatable document from your main template with the"
" attribute ``t-lang`` set to a language code (for example ``fr`` or "
"``en_US``) or to a record field. You will also need to re-browse the related"
" records with the proper context if you use fields that are translatable "
"(like country names, sales conditions, etc.)"
msgstr "然后，您可以从您的属性``T-lang``设置为语言代码（例如``fr``或``en_US``），或至创纪录的场主模板调用翻译的文档。您还需要重新浏览相关记录与适当的范围内，如果你使用的是翻译领域（如国名，销售条件等）"

#: ../../reference/reports.rst:146
msgid ""
"If your report template does not use translatable record fields, re-browsing"
" the record in another language is *not* necessary and will impact "
"performances."
msgstr "如果您的报告模板不使用翻译记录字段，再浏览记录在另一种语言是*不*必要的，会影响演出。"

#: ../../reference/reports.rst:149
msgid ""
"For example, let's look at the Sale Order report from the Sale module::"
msgstr "例如，让我们来看看从销售模块销售订单报告::"

#: ../../reference/reports.rst:179
msgid ""
"The main template calls the translatable template with "
"``doc.partner_id.lang`` as a ``t-lang`` parameter, so it will be rendered in"
" the language of the partner. This way, each Sale Order will be printed in "
"the language of the corresponding customer. If you wish to translate only "
"the body of the document, but keep the header and footer in a default "
"language, you could call the report's external layout this way::"
msgstr "主模板调用翻译模板``doc.partner_id.lang``作为一个``T-lang``参数，所以它会在合作伙伴的语言来呈现。这样，每个销售订单将被打印在相应客户的语言。如果你想翻译的文档的只是身体，而是保持在一个默认语言的页眉和页脚，你可以调用报表的外部布局这样::"

#: ../../reference/reports.rst:189
msgid ""
"Please take note that this works only when calling external templates, you "
"will not be able to translate part of a document by setting a ``t-lang`` "
"attribute on an xml node other than ``t-call``. If you wish to translate "
"part of a template, you can create an external template with this partial "
"template and call it from the main one with the ``t-lang`` attribute."
msgstr "请大家注意，这只能调用外部模板时，您将无法通过比``T-call``其他的XML节点上设置一个``T-lang``属性上传文档的一部分。如果你想翻译一个模板的一部分，你可以创建一个外部模板，这部分的模板，并从主一个具有``T-lang``属性调用它。"

#: ../../reference/reports.rst:197
msgid "Barcodes"
msgstr "条码"

#: ../../reference/reports.rst:199
msgid ""
"Barcodes are images returned by a controller and can easily be embedded in "
"reports thanks to the QWeb syntax:"
msgstr "条形码是由控制器返回的图像，可以很容易地嵌入到报告要归功于QWeb语法："

#: ../../reference/reports.rst:206
msgid "More parameters can be passed as a query string"
msgstr "更多参数可以通过作为查询字符串"

#: ../../reference/reports.rst:215
msgid "Useful Remarks"
msgstr "有用的备注"

#: ../../reference/reports.rst:216
msgid ""
"Twitter Bootstrap and FontAwesome classes can be used in your report "
"template"
msgstr "Twitter的引导和FontAwesome类可以在报告模板中使用"

#: ../../reference/reports.rst:218
msgid "Local CSS can be put directly in the template"
msgstr "本地的CSS可以直接在模板中放"

#: ../../reference/reports.rst:220
msgid ""
"Global CSS can be inserted in the main report layout by inheriting its "
"template and inserting your CSS::"
msgstr "全局CSS可以插入主报表布局在继承其模板并插入你的CSS ::"

#: ../../reference/reports.rst:236
msgid "Paper Format"
msgstr "论文格式"

#: ../../reference/reports.rst:238
msgid ""
"Paper formats are records of ``report.paperformat`` and can contain the "
"following attributes:"
msgstr "论文的格式是``report.paperformat``记录，可以包含下列属性："

#: ../../reference/reports.rst:244
msgid "``description``"
msgstr "``description``"

#: ../../reference/reports.rst:245
msgid "a small description of your format"
msgstr "您格式的简短描述"

#: ../../reference/reports.rst:248
msgid "``format``"
msgstr "``format``"

#: ../../reference/reports.rst:247
msgid ""
"either a predefined format (A0 to A9, B0 to B10, Legal, Letter, Tabloid,...)"
" or ``custom``; A4 by default. You cannot use a non-custom format if you "
"define the page dimensions."
msgstr "无论是预定义的格式（A0到A9，B0到B10，法律，信，小报，...）或``custom``; A4在默认情况下。不能使用非自定义格式，如果你定义页面的尺寸。"

#: ../../reference/reports.rst:250
msgid "``dpi``"
msgstr "``dpi``"

#: ../../reference/reports.rst:251
msgid "output DPI; 90 by default"
msgstr "输出DPI; 90默认"

#: ../../reference/reports.rst:252
msgid "``margin_top``, ``margin_bottom``, ``margin_left``, ``margin_right``"
msgstr "``margin_top``，``margin_bottom``，``margin_left``，``margin_right``"

#: ../../reference/reports.rst:253
msgid "margin sizes in mm"
msgstr "保证金规模在毫米"

#: ../../reference/reports.rst:254
msgid "``page_height``, ``page_width``"
msgstr "``page_height``，``page_width``"

#: ../../reference/reports.rst:255
msgid "page dimensions in mm"
msgstr "在毫米页面尺寸"

#: ../../reference/reports.rst:256
msgid "``orientation``"
msgstr "``orientation``"

#: ../../reference/reports.rst:257
msgid "Landscape or Portrait"
msgstr "横向或纵向"

#: ../../reference/reports.rst:258
msgid "``header_line``"
msgstr "``header_line``"

#: ../../reference/reports.rst:259
msgid "boolean to display a header line"
msgstr "布尔显示的标题行"

#: ../../reference/reports.rst:261
msgid "``header_spacing``"
msgstr "``header_spacing``"

#: ../../reference/reports.rst:261
msgid "header spacing in mm"
msgstr "在毫米头间距"

#: ../../reference/reports.rst:284
msgid "Custom Reports"
msgstr "自定义报告"

#: ../../reference/reports.rst:286
msgid ""
"The report model has a default ``get_html`` function that looks for a model "
"named :samp:`report.{module.report_name}`. If it exists, it will use it to "
"call the QWeb engine; otherwise a generic function will be used. If you wish"
" to customize your reports by including more things in the template (like "
"records of others models, for example), you can define this model, overwrite"
" the function ``render_html`` and pass objects in the ``docargs`` "
"dictionnary:"
msgstr "该报表模型有一个默认的``get_html``功能查找名为型号：SAMP：`报告{module.report_name}`。如果它存在，它会用它来调用QWeb引擎;否则一个通用的功能将被使用。如果你想通过包括更多的东西在模板中（像其他车型记录，例如）自定义您的报告，您可以定义这种模式，覆盖功能``render_html``和``docargs`` dictionnary传递对象："

#: ../../reference/reports.rst:311
msgid "Reports are web pages"
msgstr "报告是网页"

#: ../../reference/reports.rst:313
msgid ""
"Reports are dynamically generated by the report module and can be accessed "
"directly via URL:"
msgstr "报告是由动态报表模块生成，并可以通过URL直接访问："

#: ../../reference/reports.rst:316
msgid ""
"For example, you can access a Sale Order report in html mode by going to "
"\\http://<server-address>/report/html/sale.report_saleorder/38"
msgstr "例如，您可以进入到\\ HTTP访问HTML模式下的销售订单报告：// <服务器地址> /report/html/sale.report_saleorder/38"

#: ../../reference/reports.rst:319
msgid ""
"Or you can access the pdf version at \\http://<server-"
"address>/report/pdf/sale.report_saleorder/38"
msgstr "// <服务器地址> /report/pdf/sale.report_saleorder/38：或者你也可以在\\ HTTP访问的PDF版本"

#: ../../reference/security.rst:7
msgid "Security in Odoo"
msgstr "在Odoo安全"

#: ../../reference/security.rst:9
msgid ""
"Aside from manually managing access using custom code, Odoo provides two "
"main data-driven mechanisms to manage or restrict access to data."
msgstr "除了使用自定义代码手动管理访问，Odoo提供管理或限制访问数据的两个主要数据驱动的机制。"

#: ../../reference/security.rst:12
msgid ""
"Both mechanisms are linked to specific users through *groups*: a user "
"belongs to any number of groups, and security mechanisms are associated to "
"groups, thus applying security mechamisms to users."
msgstr "这两种机制都与通过*基团特定的用户*：用户属于任意数量的组，和安全机制关联到组，从而应用安全mechamisms给用户。"

#: ../../reference/security.rst:19
msgid "Access Control"
msgstr "访问控制"

#: ../../reference/security.rst:21
msgid ""
"Managed by the ``ir.model.access`` records, defines access to a whole model."
msgstr "由``ir.model.access``记录管理，定义了访问整个模型。"

#: ../../reference/security.rst:23
msgid ""
"Each access control has a model to which it grants permissions, the "
"permissions it grants and optionally a group."
msgstr "每个访问控制有一个模型，它授予的权限，它授予的权限和任选一组。"

#: ../../reference/security.rst:26
msgid ""
"Access controls are additive, for a given model a user has access all "
"permissions granted to any of its groups: if the user belongs to one group "
"which allows writing and another which allows deleting, they can both write "
"and delete."
msgstr "访问控制是附加的，对于一个给定的模型，用户可以访问其任何团体授予的所有权限：如果用户属于一个组，让写作和另一个则允许删除，它们可以同时写入和删除。"

#: ../../reference/security.rst:31
msgid ""
"If no group is specified, the access control applies to all users, otherwise"
" it only applies to the members of the given group."
msgstr "如果没有指定组，则访问控制适用于所有用户，否则它仅适用于给定组的成员。"

#: ../../reference/security.rst:34
msgid ""
"Available permissions are creation (``perm_create``), searching and reading "
"(``perm_read``), updating existing records (``perm_write``) and deleting "
"existing records (``perm_unlink``)"
msgstr "可用的权限是创建（``perm_create``），搜索和阅读（``perm_read``），更新现有记录（``perm_write``）和删除现有记录（``perm_unlink``）"

#: ../../reference/security.rst:41
msgid "Record Rules"
msgstr "记录规则"

#: ../../reference/security.rst:43
msgid ""
"Record rules are conditions that records must satisfy for an operation "
"(create, read, update or delete) to be allowed. It is applied record-by-"
"record after access control has been applied."
msgstr "记录规则条件的记录必须满足的操作（创建，读取，更新或删除）就可以了。该应用之后的访问控制已应用于记录被记录。"

#: ../../reference/security.rst:47
msgid "A record rule has:"
msgstr "A记录规则有："

#: ../../reference/security.rst:49
msgid "a model on which it applies"
msgstr "就其所适用的典范"

#: ../../reference/security.rst:50
msgid ""
"a set of permissions to which it applies (e.g. if ``perm_read`` is set, the "
"rule will only be checked when reading a record)"
msgstr "一组权限其所适用（例如，如果``perm_read``设置，该规则将只读取记录时选中）"

#: ../../reference/security.rst:52
msgid ""
"a set of user groups to which the rule applies, if no group is specified the"
" rule is *global*"
msgstr "一组用户群体以应用该规则，如果没有组指定的规则是*全球*"

#: ../../reference/security.rst:54
msgid ""
"a :ref:`domain <reference/orm/domains>` used to check whether a given record"
" matches the rule (and is accessible) or does not (and is not accessible). "
"The domain is evaluated with two variables in context: ``user`` is the "
"current user's record and ``time`` is the `time module`_"
msgstr "答：参考：'域<参考/ ORM /域>`用来检查是否给定的记录相匹配的规则（和访问）或没有（无法访问）。域名评估与环境两个变量：``user``是当前用户的记录和``time``是'时间module`_"

#: ../../reference/security.rst:59
msgid ""
"Global rules and group rules (rules restricted to specific groups versus "
"groups applying to all users) are used quite differently:"
msgstr "全球规则和分组规则（仅限于特定群体对适用于所有用户组的规则）中使用完全不同："

#: ../../reference/security.rst:62
msgid ""
"Global rules are subtractive, they *must all* be matched for a record to be "
"accessible"
msgstr "全球规则是减法，他们*必须全部*匹配的记录可访问"

#: ../../reference/security.rst:64
msgid ""
"Group rules are additive, if *any* of them matches (and all global rules "
"match) then the record is accessible"
msgstr "集团的规则是累加的，如果*其中任何*匹配（和所有的全球规则匹配），则记录访问"

#: ../../reference/security.rst:67
msgid ""
"This means the first *group rule* restricts access, but any further *group "
"rule* expands it, while *global rules* can only ever restrict access (or "
"have no effect)."
msgstr "这意味着第一个*组规则*限制访问，但任何进一步的*组规则*对其进行了扩展，而*全球规则*永远只能限制访问（或没有影响）。"

#: ../../reference/security.rst:71
msgid "record rules do not apply to the Administrator user"
msgstr "创纪录的规则并不适用于管理员用户"

#: ../../reference/security.rst:74
msgid "although access rules do"
msgstr "虽然访问规则做"

#: ../../reference/security.rst:79
msgid "Field Access"
msgstr "字段访问"

#: ../../reference/security.rst:83
msgid ""
"An ORM :class:`~openerp.fields.Field` can have a ``groups`` attribute "
"providing a list of groups (as a comma-separated string of :term:`external "
"identifiers`)."
msgstr "一个ORM：类：`〜openerp.fields.Field`可以有一个``groups``属性提供组的列表（以逗号分隔的字符串：期限：`外部identifiers`）。"

#: ../../reference/security.rst:87
msgid ""
"If the current user is not in one of the listed groups, he will not have "
"access to the field:"
msgstr "如果当前用户不处于所列基团之一，他将不能访问的字段："

#: ../../reference/security.rst:90
msgid "restricted fields are automatically removed from requested views"
msgstr "受限制的领域，从要求的观点自动删除"

#: ../../reference/security.rst:91
msgid ""
"restricted fields are removed from :meth:`~openerp.models.Model.fields_get` "
"responses"
msgstr "甲：`〜openerp.models.Model.fields_get`反应限制字段被调离"

#: ../../reference/security.rst:93
msgid ""
"attempts to (explicitly) read from or write to restricted fields results in "
"an access error"
msgstr "尝试（明确地）读取或写入受限字段导致访问错误"

#: ../../reference/security.rst:102
msgid "Workflow transition rules"
msgstr "工作流程转换规则"

#: ../../reference/security.rst:104
msgid ""
"Workflow transitions can be restricted to a specific group. Users outside "
"the group can not trigger the transition."
msgstr "工作流程的转换可以被限制到特定的组。组外的用户无法触发的过渡。"

#: ../../reference/testing.rst:8
msgid "Testing Modules"
msgstr "测试模块"

#: ../../reference/testing.rst:10
msgid "Odoo provides support for testing modules using unittest2_."
msgstr "Odoo使用unittest2_提供的测试模块的支持。"

#: ../../reference/testing.rst:12
msgid ""
"To write tests, simply define a ``tests`` sub-package in your module, it "
"will be automatically inspected for test modules. Test modules should have a"
" name starting with ``test_`` and should be imported from "
"``tests/__init__.py``, e.g."
msgstr "编写测试，简单地定义一个``tests``子包在你的模块，它会自动检查是否有测试模块。测试模块应该有一个名字开头``test_``，应该从``测试/ __ __初始化。py``，如进口"

#: ../../reference/testing.rst:26
msgid "and ``__init__.py`` contains::"
msgstr "和``__init __。py``包含::"

#: ../../reference/testing.rst:32
msgid ""
"test modules which are not imported from ``tests/__init__.py`` will not be "
"run"
msgstr "而不是从``测试导入测试模块/ __ __初始化。py``将不会运行"

#: ../../reference/testing.rst:37
msgid ""
"previously, the test runner would only run modules added to two lists "
"``fast_suite`` and ``checks`` in ``tests/__init__.py``. In 8.0 it will run "
"all imported modules"
msgstr "以前，测试运行将只运行模块添加到两个列表``fast_suite``和``checks``在``测试/ __ __初始化。py``。在8.0它将运行所有导入模块"

#: ../../reference/testing.rst:41
msgid ""
"The test runner will simply run any test case, as described in the official "
"`unittest documentation`_, but Odoo provides a number of utilities and "
"helpers related to testing Odoo content (modules, mainly):"
msgstr "测试运行会简单地运行任何测试情况下，如在正式`单元测试documentation`_说明，但Odoo提供了许多实用程序和相关检测Odoo内容（模块，主要）助手："

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase:1
msgid ""
"TestCase in which each test method is run in its own transaction, and with "
"its own cursor. The transaction is rolled back and the cursor is closed "
"after each test."
msgstr "测试用例其中每个测试方法运行在其自己的事务，并有自己的光标。该交易被回退，每次测试后，将关闭游标。"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.browse_ref:1
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.browse_ref:1
msgid "Returns a record object for the provided :term:`external identifier`"
msgstr "返回所提供的记录对象：短期：`外部identifier`"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.browse_ref:4
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.ref:4
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.browse_ref:4
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.ref:4
msgid ""
"fully-qualified :term:`external identifier`, in the form "
":samp:`{module}.{identifier}`"
msgstr "完全合格的：短期：`外部identifier`，形式为：SAMP：`{模块} {标识符}`"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.browse_ref:6
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.ref:6
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.browse_ref:6
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.ref:6
msgid "ValueError if not found"
msgstr "ValueError错误，如果未找到"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.browse_ref:7
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.browse_ref:7
msgid ":class:`~openerp.models.BaseModel`"
msgstr "产品类别：`〜openerp.models.BaseModel`"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.ref:1
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.ref:1
msgid ""
"Returns database ID for the provided :term:`external identifier`, shortcut "
"for ``get_object_reference``"
msgstr "返回数据库ID为提供：期限：`外部identifier`，快捷``get_object_reference``"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.TransactionCase.ref:7
#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase.ref:7
msgid "registered id"
msgstr "注册ID"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.SingleTransactionCase:1
msgid ""
"TestCase in which all test methods are run in the same transaction, the "
"transaction is started with the first test method and rolled back at the end"
" of the last."
msgstr "测试用例，其中所有的测试方法是在同一事务中运行，该交易开始与第一测试方法和回退在最后的末端。"

#: ../../reference/testing.rst:51
msgid ""
"By default, tests are run once right after the corresponding module has been"
" installed. Test cases can also be configured to run after all modules have "
"been installed, and not run right after the module installation:"
msgstr "默认情况下，测试相应的模块安装后，一旦正确运行。测试情况下也可配置为运行已安装的所有模块后，而不是在模块安装后右运行："

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.at_install:1
msgid ""
"Sets the at-install state of a test, the flag is a boolean specifying "
"whether the test should (``True``) or should not (``False``) run during "
"module installation."
msgstr "设置一个测试，在安装状态下，该标志是一个布尔值指定是否测试应该（值为``True``）或不应该（``False``）模块安装过程中运行。"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.at_install:5
msgid ""
"By default, tests are run right after installing the module, before starting"
" the installation of the next module."
msgstr "默认情况下，测试安装的模块，开始下一个模块的安装之前之后运行。"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.post_install:1
msgid ""
"Sets the post-install state of a test. The flag is a boolean specifying "
"whether the test should or should not run after a set of module "
"installations."
msgstr "设置一个测试安装后的状态。该标志是一个布尔值，指定是否测试应该或不应该一组模块的安装后运行。"

#: ../../../openerp/tests/common.pydocstring of
#: openerp.tests.common.post_install:5
msgid ""
"By default, tests are *not* run after installation of all modules in the "
"current installation set."
msgstr "默认情况下，测试是*不*安装在当前安装集的所有模块后运行。"

#: ../../reference/testing.rst:59
msgid ""
"The most common situation is to use "
":class:`~openerp.tests.common.TransactionCase` and test a property of a "
"model in each method::"
msgstr "最常见的情况是使用：类：`〜openerp.tests.common.TransactionCase`并在每个方法测试模型的属性::"

#: ../../reference/testing.rst:74
msgid "Running tests"
msgstr "运行测试"

#: ../../reference/testing.rst:76
msgid ""
"Tests are automatically run when installing or updating modules if :option"
":`--test-enable <odoo.py --test-enable>` was enabled when starting the Odoo "
"server."
msgstr "启动Odoo服务器时'--test启用<odoo.py --test启用>`已启用：选项：安装或更新模块，如果测试时自动运行。"

#: ../../reference/testing.rst:80
msgid ""
"As of Odoo 8, running tests outside of the install/update cycle is not "
"supported."
msgstr "由于Odoo 8，运行安装/更新周期之外的测试不支持。"

#: ../../reference/translations.rst:8
msgid "Translating Modules"
msgstr "翻译模块"

#: ../../reference/translations.rst:11
msgid "Exporting translatable term"
msgstr "导出翻译术语"

#: ../../reference/translations.rst:13
msgid ""
"A number of terms in your modules are \"implicitly translatable\" as a "
"result, even if you haven't done any specific work towards translation you "
"can export your module's translatable terms and may find content to work "
"with."
msgstr "许多术语在你的模块是\“含蓄翻译\”这样一来，即使你没有做对翻译的具体工作，你可以导出你的模块的翻译术语和可能会发现内容的工作。"

#: ../../reference/translations.rst:19
msgid ""
"Translations export is performed via the administration interface by logging"
" into the backend interface and opening :menuselection:`Settings --> "
"Translations --> Import / Export --> Export Translations`"
msgstr "menuselection： - >翻译 - >导入/导出 - >导出Translations``设置出口的翻译是通过登录到后端接口开放，通过管理界面进行"

#: ../../reference/translations.rst:23
msgid "leave the language to the default (new language/empty template)"
msgstr "离开语言为默认（新的语言/空模板）"

#: ../../reference/translations.rst:24
msgid "select the `PO File`_ format"
msgstr "选择`PO File`_格式"

#: ../../reference/translations.rst:25
msgid "select your module"
msgstr "选择你的模块"

#: ../../reference/translations.rst:26
msgid "click :guilabel:`Export` and download the file"
msgstr "点击：guilabel：`Export`和下载文件"

#: ../../reference/translations.rst:32
msgid ""
"This gives you a file called :file:`{yourmodule}.pot` which should be moved "
"to the :file:`{yourmodule}/i18n/` directory. The file is a *PO Template* "
"which simply lists translatable strings and from which actual translations "
"(PO files) can be created. PO files can be created using msginit_, with a "
"dedicated translation tool like POEdit_ or by simply copying the template to"
" a new file called :file:`{language}.po`. Translation files should be put in"
" :file:`{yourmodule}/i18n/`, next to :file:`{yourmodule}.pot`, and will be "
"automatically loaded by Odoo when the corresponding language is installed "
"(via :menuselection:`Settings --> Translations --> Load a Translation`)"
msgstr "这给你一个文件名为：文件：`{} yourmodule其中.pot`应该被移到：文件：`{} yourmodule /国际化/`目录。该文件是一个* PO模板*它只是列出了翻译字符串，并从实际的翻译（PO文件）可以被创建。可以用msginit_创建PO文件的，有专门的翻译工具如POEdit_或者简单地复制模板到一个名为新文件：文件：`{}语言.po`。翻译文件应放在：文件：`{} yourmodule /国际化/`，旁边即：file：`{} yourmodule .pot`，并将于Odoo安装了相应的语言时，通过自动加载（：menuselection：`设置 - >翻译 - >加载Translation`）"

#: ../../reference/translations.rst:42
msgid ""
"translations for all loaded languages are also installed or updated when "
"installing or updating a module"
msgstr "安装或更新一个模块时，还安装或更新翻译所有装载语言"

#: ../../reference/translations.rst:46
msgid "Implicit exports"
msgstr "隐出口"

#: ../../reference/translations.rst:48
msgid ""
"Odoo automatically exports translatable strings from \"data\"-type content:"
msgstr "Odoo自动导出翻译字符串从\“数据\” - 类型的内容："

#: ../../reference/translations.rst:50
msgid ""
"in non-QWeb views, all text nodes are exported as well as the content of the"
" ``string``, ``help``, ``sum``, ``confirm`` and ``placeholder`` attributes"
msgstr "非QWeb的观点，所有的文本节点远销还有``string``的内容，``help``，``sum``，``confirm``和``placeholder``属性"

#: ../../reference/translations.rst:53
msgid ""
"QWeb templates (both server-side and client-side), all text nodes are "
"exported except inside ``t-translation=\"off\"`` blocks, the content of the "
"``title``, ``alt``, ``label`` and ``placeholder`` attributes are also "
"exported"
msgstr "QWeb模板（包括服务器端和客户端），所有的文本节点远销除了内部``​​T-翻译= \“关\”``块时，``title``的内容，``alt`` ``label``和``placeholder``属性还出口"

#: ../../reference/translations.rst:57
msgid ""
"for :class:`~openerp.fields.Field`, unless their model is marked with "
"``_translate = False``:"
msgstr "为：类：`〜openerp.fields.Field`，除非他们的模型上标有``_translate = False``："

#: ../../reference/translations.rst:60
msgid "their ``string`` and ``help`` attributes are exported"
msgstr "他们``string``和``help``属性出口"

#: ../../reference/translations.rst:61
msgid "if ``selection`` is present and a list (or tuple), it's exported"
msgstr "如果``selection``存在和一个列表（或元组），它的出口"

#: ../../reference/translations.rst:62
msgid ""
"if their ``translate`` attribute is set to ``True``, all of their existing "
"values (across all records) are exported"
msgstr "如果他们的``translate``属性设置为``True``，那么所有的现有价值（所有记录）出口"

#: ../../reference/translations.rst:64
msgid ""
"help/error messages of :attr:`~openerp.models.Model._constraints` and "
":attr:`~openerp.models.Model._sql_constraints` are exported"
msgstr "ATTR：〜openerp.models.Model._sql_constraints`出口`：帮助/错误信息`〜openerp.models.Model._constraints`和：ATTR"

#: ../../reference/translations.rst:68
msgid "Explicit exports"
msgstr "明确出口"

#: ../../reference/translations.rst:70
msgid ""
"When it comes to more \"imperative\" situations in Python code or Javascript"
" code, Odoo cannot automatically export translatable terms so they must be "
"marked explicitly for export. This is done by wrapping a literal string in a"
" function call."
msgstr "当谈到在Python代码或JavaScript代码更\“势在必行\”的情况下，Odoo不能自动导出翻译方面，使他们必须明确标明用于出口。这是由包裹在一个函数调用一个字符串进行。"

#: ../../reference/translations.rst:75
msgid "In Python, the wrapping function is :func:`openerp._`::"
msgstr "在Python中，包装的功能是：函数：`openerp._` ::"

#: ../../reference/translations.rst:79
msgid ""
"In JavaScript, the wrapping function is generally :js:func:`openerp.web._t`:"
msgstr "在JavaScript中，包装功能一般为：JS：FUNC：`openerp.web._t`："

#: ../../reference/translations.rst:87
msgid ""
"Only literal strings can be marked for exports, not expressions or "
"variables. For situations where strings are formatted, this means the format"
" string must be marked, not the formatted string::"
msgstr "只有文字字符串可以被标记为出口，而不是表达式或变量。对于在字符串格式化的情况下，这意味着格式字符串必须标注，而不是格式化字符串::"

#: ../../reference/views.rst:8
msgid "Views"
msgstr "浏览"

#: ../../reference/views.rst:13
msgid "Common Structure"
msgstr "公共结构"

#: ../../reference/views.rst:15
msgid ""
"View objects expose a number of fields, they are optional unless specified "
"otherwise."
msgstr "查看对象公开若干领域，它们是可选的，除非另有说明。"

#: ../../reference/views.rst:19
msgid ""
"only useful as a mnemonic/description of the view when looking for one in a "
"list of some sort"
msgstr "只有在某种类型的列表作为视图的记忆/描述有用找一当"

#: ../../reference/views.rst:21
msgid "``model``"
msgstr "``model``"

#: ../../reference/views.rst:22
msgid ""
"the model linked to the view, if applicable (it doesn't for QWeb views)"
msgstr "链接到视图模型，如果适用（它不QWeb观点）"

#: ../../reference/views.rst:29
msgid "``priority``"
msgstr "``priority``"

#: ../../reference/views.rst:24
msgid ""
"client programs can request views by ``id``, or by ``(model, type)``. For "
"the latter, all the views for the right type and model will be searched, and"
" the one with the lowest ``priority`` number will be returned (it is the "
"\"default view\")."
msgstr "客户端程序可以通过``id``，或``（型号，类型）``要求的意见。对于后者，对于正确的类型和型号所有的意见都会被搜索，并具有最低``priority``号将返回（这是\“默认视图\”）。"

#: ../../reference/views.rst:29
msgid ""
"``priority`` also defines the order of application during :ref:`view "
"inheritance <reference/views/inheritance>`"
msgstr "``priority``还定义了应用程序的顺序时：参考：`观的继承<参考/视图/继承>`"

#: ../../reference/views.rst:31
msgid "``arch``"
msgstr "``arch``"

#: ../../reference/views.rst:32
msgid "the description of the view's layout"
msgstr "视图布局的说明"

#: ../../reference/views.rst:34
msgid ""
":class:`~openerp.fields.Many2many` field to the groups allowed to view/use "
"the current view"
msgstr "产品类别：`〜openerp.fields.Many2many`领域允许查看组/用当前视图"

#: ../../reference/views.rst:37
msgid "``inherit_id``"
msgstr "``inherit_id``"

#: ../../reference/views.rst:37
msgid ""
"the current view's parent view, see :ref:`reference/views/inheritance`, "
"unset by default"
msgstr "当前视图的父视图，请参阅：参考：`参考/视图/ inheritance`，未设置默认"

#: ../../reference/views.rst:42 ../../reference/views.rst:416
msgid "``mode``"
msgstr "``mode``"

#: ../../reference/views.rst:40
msgid ""
"inheritance mode, see :ref:`reference/views/inheritance`. If ``inherit_id`` "
"is unset the ``mode`` can only be ``primary``. If ``inherit_id`` is set, "
"``extension`` by default but can be explicitly set to ``primary``"
msgstr "遗传方式，请参阅：参考：`参考/视图/ inheritance`。如果``inherit_id``没有设置的``mode``只能是``primary``。如果``inherit_id``设置，``默认extension``但可以明确设置为``primary``"

#: ../../reference/views.rst:46
msgid "``application``"
msgstr "``application``"

#: ../../reference/views.rst:45
msgid ""
"website feature defining togglable views. By default, views are always "
"applied"
msgstr "网站功能定义togglable意见。默认情况下，意见始终应用"

#: ../../reference/views.rst:51
msgid "Inheritance"
msgstr "遗产"

#: ../../reference/views.rst:54
msgid "View matching"
msgstr "查看匹配"

#: ../../reference/views.rst:56
msgid ""
"if a view is requested by ``(model, type)``, the view with the right model "
"and type, ``mode=primary`` and the lowest priority is matched"
msgstr "如果一个视图要求``（型号，类型）``，用正确的型号和类型，``模式= primary``和最低优先级视图匹配"

#: ../../reference/views.rst:58
msgid ""
"when a view is requested by ``id``, if its mode is not ``primary`` its "
"*closest* parent with mode ``primary`` is matched"
msgstr "当一个视图被要求``id``，如果它的模式是不``primary``其*最接近的*父与模式``primary``匹配"

#: ../../reference/views.rst:62
msgid "View resolution"
msgstr "查看分辨率"

#: ../../reference/views.rst:64
msgid ""
"Resolution generates the final ``arch`` for a requested/matched ``primary`` "
"view:"
msgstr "解决方法生成最终的``arch``的请求/匹配``primary``观点："

#: ../../reference/views.rst:67
msgid ""
"if the view has a parent, the parent is fully resolved then the current "
"view's inheritance specs are applied"
msgstr "如果认为有父，父完全解决，那么当前视图的继承规范应用"

#: ../../reference/views.rst:69
msgid "if the view has no parent, its ``arch`` is used as-is"
msgstr "如果视图没有父，它的``arch``作为，是"

#: ../../reference/views.rst:70
msgid ""
"the current view's children with mode ``extension`` are looked up  and their"
" inheritance specs are applied depth-first (a child view is applied, then "
"its children, then its siblings)"
msgstr "当前视图的儿童模式``extension``正在抬头一看，他们的产业规格的应用深度优先（子视图应用，那么它的孩子，那么它的兄弟姐妹）"

#: ../../reference/views.rst:74
msgid "The result of applying children views yields the final ``arch``"
msgstr "将儿童的意见的结果得到最终的``arch``"

#: ../../reference/views.rst:77
msgid "Inheritance specs"
msgstr "继承规范"

#: ../../reference/views.rst:79
msgid "There are three types of inheritance specs:"
msgstr "有三种类型的继承规格的："

#: ../../reference/views.rst:81
msgid ""
"An ``xpath`` element with an ``expr`` attribute. ``expr`` is an XPath_ "
"expression\\ [#hasclass]_ applied to the current ``arch``, the first node it"
" finds is the match"
msgstr "一个``xpath``与``expr``属性的元素。 ``expr``是XPath_表达\\ [#hasclass] _应用到当前的``arch``，它找到的第一个节点是匹配"

#: ../../reference/views.rst:84
msgid ""
"a ``field`` element with a ``name`` attribute, matches the first ``field`` "
"with the same ``name``"
msgstr "用``name``属性的``field``元素，匹配的第一个``field``用相同的``name``"

#: ../../reference/views.rst:86
msgid ""
"any other element, the first element with the same name and identical "
"attributes (ignoring ``position``) is matched"
msgstr "任何其他元件，具有相同的名称和相同属性的所述第一元件（忽略``position``）匹配"

#: ../../reference/views.rst:89
msgid ""
"The inheritance spec may have an optional ``position`` attribute specifying "
"how the matched node should be altered:"
msgstr "继承规范有一个可选的``position``属性指定如何匹配的节点应该被改变："

#: ../../reference/views.rst:92
msgid "``inside`` (default)"
msgstr "``inside``（默认）"

#: ../../reference/views.rst:93
msgid "the content of the inheritance spec is appended to the matched node"
msgstr "继承规范的内容被附加给匹配节点"

#: ../../reference/views.rst:95
msgid "the content of the inheritance spec replaces the matched node"
msgstr "继承规范的内容替换匹配的节点"

#: ../../reference/views.rst:97
msgid ""
"the content of the inheritance spec is added to the matched node's parent, "
"after the matched node"
msgstr "继承规范的内容被添加到匹配节点的父，匹配节点之后"

#: ../../reference/views.rst:100
msgid ""
"the content of the inheritance spec is added to the matched node's parent, "
"before the matched node"
msgstr "继承规范的内容被添加到匹配节点的父，匹配节点之前"

#: ../../reference/views.rst:111
msgid "``attributes``"
msgstr "``attributes``"

#: ../../reference/views.rst:103
msgid ""
"the content of the inheritance spec should be ``attribute`` elements with a "
"``name`` attribute and an optional body:"
msgstr "继承规范的内容应该是``用``name``属性和一个可选的机身attribute``要素："

#: ../../reference/views.rst:106
msgid ""
"if the ``attribute`` element has a body, a new attributed named after its "
"``name`` is created on the matched node with the ``attribute`` element's "
"text as value"
msgstr "如果``attribute``元素有一个机构，一个新的归因评出了``name``是匹配的节点上的``attribute``元素的文本作为价值创造之后"

#: ../../reference/views.rst:109
msgid ""
"if the ``attribute`` element has no body, the attribute named after its "
"``name`` is removed from the matched node. If no such attribute exists, an "
"error is raised"
msgstr "如果``attribute``元素没有主体，它的``name``命名的属性从匹配节点删除。如果没有这样的属性存在，将引发错误"

#: ../../reference/views.rst:113
msgid "A view's specs are applied sequentially."
msgstr "视图的功能依次应用。"

#: ../../reference/views.rst:118
msgid "Lists"
msgstr "名单"

#: ../../reference/views.rst:120
msgid ""
"The root element of list views is ``<tree>``\\ [#treehistory]_. The list "
"view's root can have the following attributes:"
msgstr "列表视图的根元素是``<树>``\\ [#treehistory] ​​_。列表视图的根可以有以下属性："

#: ../../reference/views.rst:134
msgid "``editable``"
msgstr "``editable``"

#: ../../reference/views.rst:124
msgid ""
"by default, selecting a list view's row opens the corresponding :ref:`form "
"view <reference/views/form>`. The ``editable`` attributes makes the list "
"view itself editable in-place."
msgstr "默认情况下，选择一个列表视图的行会打开相应：REF：`表单视图<参考/视图/表>`。该``editable``属性使得列表视图本身可编辑的就地。"

#: ../../reference/views.rst:128
msgid ""
"Valid values are ``top`` and ``bottom``, making *new* records appear "
"respectively at the top or bottom of the list."
msgstr "有效值为``top``和``bottom``，使得*新*记录分别出现在列表的顶部或底部。"

#: ../../reference/views.rst:131
msgid ""
"The architecture for the inline :ref:`form view <reference/views/form>` is "
"derived from the list view. Most attributes valid on a :ref:`form view "
"<reference/views/form>`'s fields and buttons are thus accepted by list views"
" although they may not have any meaning if the list view is non-editable"
msgstr "该架构内联：REF：`表单视图<参考/视图/表>`从列表视图中获得。参考：`表单视图<参考/视图/ form>中这样`的字段和按钮都接受列表视图，尽管他们可能没有任何意义，如果列表视图是不可编辑上的大多数属性有效"

#: ../../reference/views.rst:142 ../../reference/views.rst:817
msgid "``default_order``"
msgstr "``default_order``"

#: ../../reference/views.rst:137
msgid ""
"overrides the ordering of the view, replacing the model's default order. The"
" value is a comma-separated list of fields, postfixed by ``desc`` to sort in"
" reverse order:"
msgstr "覆盖视图的顺序，取代模型的默认顺序。该值是用逗号分隔的字段列表，用``desc``后缀以相反的顺序进行排序："

#: ../../reference/views.rst:145
msgid "``colors``"
msgstr "``colors``"

#: ../../reference/views.rst:145 ../../reference/views.rst:148
msgid "replaced by ``decoration-{$name}``"
msgstr "{$名}`` - 用``装修替换"

#: ../../reference/views.rst:148
msgid "``fonts``"
msgstr "``fonts``"

#: ../../reference/views.rst:161
msgid "``decoration-{$name}``"
msgstr "``装饰 -  {$名}``"

#: ../../reference/views.rst:151
msgid ""
"allow changing the style of a row's text based on the corresponding record's"
" attributes."
msgstr "允许更改行的文本的基础上，相应的记录的属性的风格。"

#: ../../reference/views.rst:154
msgid ""
"Values are Python expressions. For each record, the expression is evaluated "
"with the record's attributes as context values and if ``true``, the "
"corresponding style is applied to the row. Other context values are ``uid`` "
"(the id of the current user) and ``current_date`` (the current date as a "
"string of the form ``yyyy-MM-dd``)."
msgstr "价值观是Python表达式。对于每一个记录，该表达式的值与记录的属性为背景值，如果``True``，那么相应的样式应用到该行。其他情况下的值是``uid``（当前用户的ID）和``current_date``（当前日期的形式``YYYY-MM-dd``的字符串）。"

#: ../../reference/views.rst:160
msgid ""
"``{$name}`` can be ``bf`` (``font-weight: bold``), ``it`` (``font-style: "
"italic``), or any bootstrap contextual color (``danger``, ``info``, "
"``muted``, ``primary``, ``success`` or ``warning``)."
msgstr "``{$名}``可以``bf``（``字体重量：bold``），``it``（``字体样式：italic``），或引导上下文颜色（ ``danger``，``info``，``muted``，``primary``，``success``或``warning``）。"

#: ../../reference/views.rst:164
msgid "``create``, ``edit``, ``delete``"
msgstr "``create``，``edit``，``delete``"

#: ../../reference/views.rst:164
msgid ""
"allows *dis*\\ abling the corresponding action in the view by setting the "
"corresponding attribute to ``false``"
msgstr "允许* DIS * \\ abling视图由相应的属性设置为'相应的动作`false``"

#: ../../reference/views.rst:170
msgid "``on_write``"
msgstr "``on_write``"

#: ../../reference/views.rst:167
msgid ""
"only makes sense on an ``editable`` list. Should be the name of a method on "
"the list's model. The method will be called with the ``id`` of a record "
"after having created or edited that record (in database)."
msgstr "不仅使一个``editable``名单上的意义。应该对名单的模型方法的名称。已经创建或编辑该记录（数据库）后，该方法将被称为一个记录的``id``。"

#: ../../reference/views.rst:171
msgid ""
"The method should return a list of ids of other records to load or update."
msgstr "该方法应返回的其他记录ID的列表，以装载或更新。"

#: ../../reference/views.rst:177 ../../reference/views.rst:191
#: ../../reference/views.rst:252 ../../reference/views.rst:1100
msgid "``string``"
msgstr "``string``"

#: ../../reference/views.rst:173
msgid "alternative translatable label for the view"
msgstr "另一种翻译标签视图"

#: ../../reference/views.rst:177
msgid "not displayed anymore"
msgstr "了不显示"

#: ../../reference/views.rst:181
msgid "Possible children elements of the list view are:"
msgstr "列表视图中可能的子元素有："

#: ../../reference/views.rst:242 ../../reference/views.rst:348
msgid "``button``"
msgstr "``button``"

#: ../../reference/views.rst:186
msgid "displays a button in a list cell"
msgstr "列表中的单元格中显示一个按钮"

#: ../../reference/views.rst:188
msgid "``icon``"
msgstr "``icon``"

#: ../../reference/views.rst:189
msgid "icon to use to display the button"
msgstr "要使用的图标来显示按钮"

#: ../../reference/views.rst:191
msgid "if there is no ``icon``, the button's text"
msgstr "如果没有``icon``，按钮的文本"

#: ../../reference/views.rst:192
msgid "if there is an ``icon``, ``alt`` text for the icon"
msgstr "如果有一个``icon``，``alt``文本图标"

#: ../../reference/views.rst:194
msgid "type of button, indicates how it clicking it affects Odoo:"
msgstr "按钮类型，表明它如何影响点击Odoo："

#: ../../reference/views.rst:198
msgid "``workflow`` (default)"
msgstr "``workflow``（默认）"

#: ../../reference/views.rst:197
msgid ""
"sends a signal to a workflow. The button's ``name`` is the workflow signal, "
"the row's record is passed as argument to the signal"
msgstr "将信号发送到一个工作流程。按钮的``name``是工作流信号，该行的记录被作为参数传递给信号"

#: ../../reference/views.rst:207 ../../reference/views.rst:1043
msgid "``object``"
msgstr "``object``"

#: ../../reference/views.rst:201
msgid ""
"call a method on the list's model. The button's ``name`` is the method, "
"which is called with the current row's record id and the current context."
msgstr "调用列表模型的方法。按钮的``name``是方法，这就是所谓的当前行的记录ID和当前上下文。"

#: ../../reference/views.rst:210
msgid ""
"load an execute an ``ir.actions``, the button's ``name`` is the database id "
"of the action. The context is expanded with the list's model (as "
"``active_model``), the current row's record (``active_id``) and all the "
"records currently loaded in the list (``active_ids``, may be just a subset "
"of the database records matching the current search)"
msgstr "加载执行``ir.actions``，按钮的``name``是行动的数据库ID。上下文与列表中的模型扩展（如``active_model``），当前行的纪录（``active_id``），目前在列表中加载的所有记录（``active_ids``，可能是一个子集数据库记录相匹配的当前搜索）"

#: ../../reference/views.rst:217 ../../reference/views.rst:219
msgid "see ``type``"
msgstr "见``type``"

#: ../../reference/views.rst:218
msgid "``args``"
msgstr "``args``"

#: ../../reference/views.rst:227 ../../reference/views.rst:280
#: ../../reference/views.rst:310 ../../reference/views.rst:394
msgid "``attrs``"
msgstr "``attrs``"

#: ../../reference/views.rst:221
msgid "dynamic attributes based on record values."
msgstr "根据记录值动态属性。"

#: ../../reference/views.rst:223
msgid ""
"A mapping of attributes to domains, domains are evaluated in the context of "
"the current row's record, if ``True`` the corresponding attribute is set on "
"the cell."
msgstr "属性域的映射域在当前行的记录的上下文中计算，如果值为``True``相应的属性设置单元格。"

#: ../../reference/views.rst:227
msgid ""
"Possible attributes are ``invisible`` (hides the button) and ``readonly`` "
"(disables the button but still shows it)"
msgstr "可能的属性``invisible``（隐藏的按钮）和``readonly``（禁用按钮，但仍显示它）"

#: ../../reference/views.rst:234
msgid "``states``"
msgstr "``states``"

#: ../../reference/views.rst:230
msgid ""
"shorthand for ``invisible`` ``attrs``: a list of states, comma separated, "
"requires that the model has a ``state`` field and that it is used in the "
"view."
msgstr "简写``invisible````attrs``：状态列表，逗号分隔，要求该模型有一个``state``字段，并且它是用在图。"

#: ../../reference/views.rst:234
msgid ""
"Makes the button ``invisible`` if the record is *not* in one of the listed "
"states"
msgstr "使得按钮``invisible``如果记录*没有列出的状态之一*"

#: ../../reference/views.rst:237
msgid "merged into the view's context when performing the button's Odoo call"
msgstr "执行按钮的Odoo电话时，合并到视图的上下文"

#: ../../reference/views.rst:240
msgid "``confirm``"
msgstr "``confirm``"

#: ../../reference/views.rst:239
msgid ""
"confirmation message to display (and for the user to accept) before "
"performing the button's Odoo call"
msgstr "执行按钮的Odoo呼叫之前显示确认消息（以及用户接受）"

#: ../../reference/views.rst:245
msgid ""
"defines a column where the corresponding field should be displayed for each "
"record. Can use the following attributes:"
msgstr "定义了相应的字段应显示每个记录的列。可以用下面的属性："

#: ../../reference/views.rst:249
msgid ""
"the name of the field to display in the current model. A given name can only"
" be used once per view"
msgstr "在当前的模型，以显示场的名称。给定的名称只能按次使用一次"

#: ../../reference/views.rst:252
msgid ""
"the title of the field's column (by default, uses the ``string`` of the "
"model's field)"
msgstr "该字段的列标题（默认情况下，使用模型的领域的``string``）"

#: ../../reference/views.rst:256
msgid "``invisible``"
msgstr "``invisible``"

#: ../../reference/views.rst:255
msgid ""
"fetches and stores the field, but doesn't display the column in the table. "
"Necessary for fields which shouldn't be displayed but are used by e.g. "
"``@colors``"
msgstr "取和存储该字段，但是不显示在表中的列。必要的量不应该被显示，但所使用的如``@ colors``字段"

#: ../../reference/views.rst:259
msgid "lists the groups which should be able to see the field"
msgstr "列出的应能看到领域的组"

#: ../../reference/views.rst:270 ../../reference/views.rst:364
#: ../../reference/views.rst:856 ../../reference/views.rst:1133
msgid "``widget``"
msgstr "``widget``"

#: ../../reference/views.rst:261
msgid ""
"alternate representations for a field's display. Possible list view values "
"are:"
msgstr "备用表示为字段的显示。可能的列表视图中的值有："

#: ../../reference/views.rst:264
msgid "``progressbar``"
msgstr "``progressbar``"

#: ../../reference/views.rst:265
msgid "displays ``float`` fields as a progress bar."
msgstr "显示``float``进度条的字段。"

#: ../../reference/views.rst:267
msgid "``many2onebutton``"
msgstr "``many2onebutton``"

#: ../../reference/views.rst:267
msgid ""
"replaces the m2o field's value by a checkmark if the field is filled, and a "
"cross if it is not"
msgstr "替换被勾选的M2O字段的值，如果该字段被填满，和横，如果它不是"

#: ../../reference/views.rst:270
msgid "``handle``"
msgstr "``handle``"

#: ../../reference/views.rst:270
msgid ""
"for ``sequence`` fields, instead of displaying the field's value just "
"displays a dra&drop icon"
msgstr "对于``sequence``领域，而不是显示的字段的值，只显示一个DRA和下降图标"

#: ../../reference/views.rst:275
msgid "``sum``, ``avg``"
msgstr "``sum``，``avg``"

#: ../../reference/views.rst:273
msgid ""
"displays the corresponding aggregate at the bottom of the column. The "
"aggregation is only computed on *currently displayed* records. The "
"aggregation operation must match the corresponding field's "
"``group_operator``"
msgstr "显示在塔底部的对应的集合体。聚集仅计算在*当前显示*记录。聚合操作必须在相应领域的``group_operator``匹配"

#: ../../reference/views.rst:278
msgid ""
"dynamic attributes based on record values. Only effects the current field, "
"so e.g. ``invisible`` will hide the field but leave the same field of other "
"records visible, it will not hide the column itself"
msgstr "根据记录值动态属性。只影响当前的领域，所以如``invisible``将隐藏字段，但留下的其他记录相同的字段可见，它不会隐藏列本身"

#: ../../reference/views.rst:282
msgid ""
"if the list view is ``editable``, any field attribute from the :ref:`form "
"view <reference/views/form>` is also valid and will be used when setting up "
"the inline form view"
msgstr "如果列表视图是``editable``，从任何字段属性：参考：`表单视图<参考/视图/表>`也是有效的，将设立在线表单视图时，可以使用"

#: ../../reference/views.rst:289
msgid "Forms"
msgstr "形式"

#: ../../reference/views.rst:291
msgid ""
"Form views are used to display the data from a single record. Their root "
"element is ``<form>``. They are composed of regular HTML_ with additional "
"structural and semantic components."
msgstr "表格视图用于从单个记录显示数据。他们的根元素是``的<form>``。它们与另外的结构和语义成分组成的常规HTML_。"

#: ../../reference/views.rst:296
msgid "Structural components"
msgstr "结构部件"

#: ../../reference/views.rst:298
msgid ""
"Structural components provide structure or \"visual\" features with little "
"logic. They are used as elements or sets of elements in form views."
msgstr "结构组件提供结构或很少有逻辑\“视觉\”的特点。它们被用作在形式次元素或元素组。"

#: ../../reference/views.rst:310
msgid "``notebook``"
msgstr "``notebook``"

#: ../../reference/views.rst:302
msgid ""
"defines a tabbed section. Each tab is defined through a ``page`` child "
"element. Pages can have the following attributes:"
msgstr "定义一个选项卡式部分。每个选项卡通过``page``子元素定义。网页可以具有以下属性："

#: ../../reference/views.rst:305 ../../reference/views.rst:1148
msgid "``string`` (required)"
msgstr "``string``（必填）"

#: ../../reference/views.rst:306
msgid "the title of the tab"
msgstr "的选项卡的标题"

#: ../../reference/views.rst:307
msgid "``accesskey``"
msgstr "``accesskey``"

#: ../../reference/views.rst:308
msgid "an HTML accesskey_"
msgstr "一个HTML accesskey_"

#: ../../reference/views.rst:310
msgid "standard dynamic attributes based on record values"
msgstr "根据记录值标准的动态属性"

#: ../../reference/views.rst:325 ../../reference/views.rst:1195
msgid "``group``"
msgstr "``group``"

#: ../../reference/views.rst:313
msgid ""
"used to define column layouts in forms. By default, groups define 2 columns "
"and most direct children of groups take a single column. ``field`` direct "
"children of groups display a label by default, and the label and the field "
"itself have a colspan of 1 each."
msgstr "用于表单定义列布局。缺省情况下，组定义2列和最直接的组的儿童采取单个列。 ``组field``直接子默认显示一个标签，标签和字段本身具有1每一个列跨度。"

#: ../../reference/views.rst:318
msgid ""
"The number of columns in a ``group`` can be customized using the ``col`` "
"attribute, the number of columns taken by an element can be customized using"
" ``colspan``."
msgstr "在一个``group``列数可以使用``col``属性定制，采取的元件的列数可以用``colspan``定制。"

#: ../../reference/views.rst:322
msgid ""
"Children are laid out horizontally (tries to fill the next column before "
"changing row)."
msgstr "孩子们水平排列（试图改变行之前填写下一列）。"

#: ../../reference/views.rst:325
msgid ""
"Groups can have a ``string`` attribute, which is displayed as the group's "
"title"
msgstr "组可以有一个``string``属性，该属性显示为组的标题"

#: ../../reference/views.rst:329
msgid "``newline``"
msgstr "``newline``"

#: ../../reference/views.rst:328
msgid ""
"only useful within ``group`` elements, ends the current row early and "
"immediately switches to a new row (without filling any remaining column "
"beforehand)"
msgstr "仅在``group``元素有用，早结束当前行并立即切换到一个新行（事先不填充任何剩余的列）"

#: ../../reference/views.rst:332 ../../reference/views.rst:1191
msgid "``separator``"
msgstr "``separator``"

#: ../../reference/views.rst:332
msgid ""
"small horizontal spacing, with a ``string`` attribute behaves as a section "
"title"
msgstr "小型水平间距，用``string``属性表现为部分标题"

#: ../../reference/views.rst:335
msgid "``sheet``"
msgstr "``sheet``"

#: ../../reference/views.rst:335
msgid ""
"can be used as a direct child to ``form`` for a narrower and more responsive"
" form layout"
msgstr "可以作为一个直接子到``form``为较窄和更敏感形式布局"

#: ../../reference/views.rst:339
msgid "``header``"
msgstr "``header``"

#: ../../reference/views.rst:338
msgid ""
"combined with ``sheet``, provides a full-width location above the sheet "
"itself, generally used to display workflow buttons and status widgets"
msgstr "加上``sheet``，提供了一个全角位置片本身上面，一般用来显示工作流程按钮和状态部件"

#: ../../reference/views.rst:342
msgid "Semantic components"
msgstr "语义成分"

#: ../../reference/views.rst:344
msgid ""
"Semantic components tie into and allow interaction with the Odoo system. "
"Available semantic components are:"
msgstr "语义成分扎入，并允许与Odoo系统交互。可用的语义成分有："

#: ../../reference/views.rst:348
msgid ""
"call into the Odoo system, similar to :ref:`list view buttons "
"<reference/views/list/button>`"
msgstr "调入Odoo系统，类似于：REF：'列表视图按钮<参考/视图/表/按钮>`"

#: ../../reference/views.rst:351
msgid ""
"renders (and allow edition of, possibly) a single field of the current "
"record. Possible attributes are:"
msgstr "呈现（和允许的，版本可能的）当前记录的单个场。可能的属性有："

#: ../../reference/views.rst:355
msgid "the name of the field to render"
msgstr "呈现字段的名称"

#: ../../reference/views.rst:357
msgid ""
"fields have a default rendering based on their type (e.g. "
":class:`~openerp.fields.Char`, :class:`~openerp.fields.Many2one`). The "
"``widget`` attributes allows using a different rendering method and context."
msgstr "域有一个默认的渲染根据自己的类型（如：类：`〜openerp.fields.Char`，产品类别：`〜openerp.fields.Many2one`）。该``widget``属性允许使用不同的绘制方法和背景。"

#: ../../reference/views.rst:367
msgid "``options``"
msgstr "``options``"

#: ../../reference/views.rst:367
msgid ""
"JSON object specifying configuration option for the field's widget "
"(including default widgets)"
msgstr "指定配置选项字段的小部件（包括默认窗口小部件）JSON对象"

#: ../../reference/views.rst:382 ../../reference/views.rst:819
msgid "``class``"
msgstr "``class``"

#: ../../reference/views.rst:370
msgid "HTML class to set on the generated element, common field classes are:"
msgstr "HTML类生成的元素上设置，常见的领域类是："

#: ../../reference/views.rst:372
msgid "``oe_inline``"
msgstr "``oe_inline``"

#: ../../reference/views.rst:373
msgid "prevent the usual line break following fields"
msgstr "防止通常的换行符以下字段"

#: ../../reference/views.rst:374
msgid "``oe_left``, ``oe_right``"
msgstr "``oe_left``，``oe_right``"

#: ../../reference/views.rst:375
msgid "floats_ the field to the corresponding direction"
msgstr "floats_场到相应的方向"

#: ../../reference/views.rst:376
msgid "``oe_read_only``, ``oe_edit_only``"
msgstr "``oe_read_only``，``oe_edit_only``"

#: ../../reference/views.rst:377
msgid "only displays the field in the corresponding form mode"
msgstr "仅在相应的表格模式显示字段"

#: ../../reference/views.rst:379
msgid "``oe_no_button``"
msgstr "``oe_no_button``"

#: ../../reference/views.rst:379
msgid ""
"avoids displaying the navigation button in a "
":class:`~openerp.fields.Many2one`"
msgstr "避免了在显示导航按钮：类：`〜openerp.fields.Many2one`"

#: ../../reference/views.rst:382
msgid "``oe_avatar``"
msgstr "``oe_avatar``"

#: ../../reference/views.rst:382
msgid ""
"for image fields, displays images as \"avatar\" (square, 90x90 maximum size,"
" some image decorations)"
msgstr "图像领域，显示图像为\“阿凡达\”（广场，90x90最大尺寸，一些图像装饰）"

#: ../../reference/views.rst:385
msgid "only displays the field for specific users"
msgstr "仅显示字段为特定用户"

#: ../../reference/views.rst:392
msgid "``on_change``"
msgstr "``on_change``"

#: ../../reference/views.rst:387
msgid ""
"calls the specified method when this field's value is edited, can generate "
"update other fields or display warnings for the user"
msgstr "调用指定的方法时，该字段的值进行编辑，可以生成更新等领域或显示警告用户"

#: ../../reference/views.rst:392
msgid "Use :func:`openerp.api.onchange` on the model"
msgstr "使用方法：FUNC：`openerp.api.onchange`型号"

#: ../../reference/views.rst:395
msgid "dynamic meta-parameters based on record values"
msgstr "根据记录值动态荟萃参数"

#: ../../reference/views.rst:397 ../../reference/views.rst:1138
#: ../../reference/views.rst:1151
msgid "``domain``"
msgstr "``domain``"

#: ../../reference/views.rst:397
msgid ""
"for relational fields only, filters to apply when displaying existing "
"records for selection"
msgstr "只有关系领域，过滤器显示为选择现有记录时应用"

#: ../../reference/views.rst:400
msgid ""
"for relational fields only, context to pass when fetching possible values"
msgstr "对于关系字段只，背景，以获取可能的值时，通过"

#: ../../reference/views.rst:402
msgid "``readonly``"
msgstr "``readonly``"

#: ../../reference/views.rst:402
msgid ""
"display the field in both readonly and edition mode, but never make it "
"editable"
msgstr "显示在两个只读和出版模式的场，但从来没有使其可编辑"

#: ../../reference/views.rst:405
msgid "``required``"
msgstr "``required``"

#: ../../reference/views.rst:405
msgid ""
"generates an error and prevents saving the record if the field doesn't have "
"a value"
msgstr "产生一个错误，并且防止保存记录，如果该字段不具有值"

#: ../../reference/views.rst:408
msgid "``nolabel``"
msgstr "``nolabel``"

#: ../../reference/views.rst:408
msgid ""
"don't automatically display the field's label, only makes sense if the field"
" is a direct child of a ``group`` element"
msgstr "不会自动显示字段的标签，才有意义，如果该字段是``group``元素的直接子"

#: ../../reference/views.rst:412
msgid "``placeholder``"
msgstr "``placeholder``"

#: ../../reference/views.rst:411
msgid ""
"help message to display in *empty* fields. Can replace field labels in "
"complex forms. *Should not* be an example of data as users are liable to "
"confuse placeholder text with filled fields"
msgstr "帮助信息在*空*域显示。能在复杂的形式代替字段标签。 *不应该*是数据的一个例子，因为用户易于占位符文本填充字段混淆"

#: ../../reference/views.rst:415
msgid ""
"for :class:`~openerp.fields.One2many`, display mode (view type) to use for "
"the field's linked records. One of ``tree``, ``form``, ``kanban`` or "
"``graph``. The default is ``tree`` (a list display)"
msgstr "为：类：`〜openerp.fields.One2many`，显示模式（视图类型），用于该领域的链接的记录。一个``tree``，``form``，``kanban``或``graph``。默认值是``tree``（列表显示）"

#: ../../reference/views.rst:418 ../../reference/views.rst:1161
msgid "``help``"
msgstr "``help``"

#: ../../reference/views.rst:419
msgid "tooltip displayed for users when hovering the field or its label"
msgstr "徘徊中的字段或它的标签时显示提示用户"

#: ../../reference/views.rst:421
msgid "``filename``"
msgstr "``filename``"

#: ../../reference/views.rst:421
msgid ""
"for binary fields, name of the related field providing the name of the file"
msgstr "对于二进制字段，相关领域的名称提供该文件的名称"

#: ../../reference/views.rst:425
msgid "``password``"
msgstr "``password``"

#: ../../reference/views.rst:424
msgid ""
"indicates that a :class:`~openerp.fields.Char` field stores a password and "
"that its data shouldn't be displayed"
msgstr "指示：类：`〜openerp.fields.Char`字段存储密码，它的数据不应该显示"

#: ../../reference/views.rst:432
msgid "Business Views guidelines"
msgstr "业务视图的准则"

#: ../../reference/views.rst:436
msgid ""
"Business views are targeted at regular users, not advanced users.  Examples "
"are: Opportunities, Products, Partners, Tasks, Projects, etc."
msgstr "业务视图是针对普通用户，而不是高级用户。例子是：机遇，产品，合作伙伴，任务，项目，等等。"

#: ../../reference/views.rst:442
msgid "In general, a business view is composed of"
msgstr "在一般情况下，一个业务视图是由"

#: ../../reference/views.rst:444
msgid "a status bar on top (with technical or business flow),"
msgstr "在顶部的状态栏（带技术或业务流程），"

#: ../../reference/views.rst:445
msgid "a sheet in the middle (the form itself),"
msgstr "在中间片材（形式本身），"

#: ../../reference/views.rst:446
msgid "a bottom part with History and Comments."
msgstr "一个底部有历史和评论。"

#: ../../reference/views.rst:448
msgid "Technically, the new form views are structured as follows in XML::"
msgstr "从技术上讲，新形式观点的结构与XML如下::"

#: ../../reference/views.rst:457
msgid "The Status Bar"
msgstr "状态栏"

#: ../../reference/views.rst:459
msgid ""
"The purpose of the status bar is to show the status of the current record "
"and the action buttons."
msgstr "状态栏的目的是为了显示当前记录的状态和操作按钮。"

#: ../../reference/views.rst:466
msgid "The Buttons"
msgstr "按钮"

#: ../../reference/views.rst:468
msgid ""
"The order of buttons follows the business flow. For instance, in a sale "
"order, the logical steps are:"
msgstr "按钮的顺序遵循业务流程。例如，在出售顺序，逻辑步骤是："

#: ../../reference/views.rst:471
msgid "Send the quotation"
msgstr "发送报价"

#: ../../reference/views.rst:472
msgid "Confirm the quotation"
msgstr "确认报价"

#: ../../reference/views.rst:473
msgid "Create the final invoice"
msgstr "创建最终发票"

#: ../../reference/views.rst:474
msgid "Send the goods"
msgstr "发送货物"

#: ../../reference/views.rst:476
msgid ""
"Highlighted buttons (in red by default) emphasize the logical next step, to "
"help the user. It is usually the first active button. On the other hand, "
":guilabel:`cancel` buttons *must* remain grey (normal).  For instance, in "
"Invoice the button :guilabel:`Refund` must never be red."
msgstr "突出显示的按钮（红色默认）强调合乎逻辑的下一步，以帮助用户。它通常是在第一有源按钮。在另一方面，：guilabel：`cancel`按钮*必须*保持灰色（正常）。例如，在发票按钮：guilabel：`Refund`绝不是红色的。"

#: ../../reference/views.rst:481
msgid ""
"Technically, buttons are highlighted by adding the class \"oe_highlight\"::"
msgstr "从技术上讲，按钮是通过添加类\“oe_highlight \”强调::"

#: ../../reference/views.rst:486
msgid "The Status"
msgstr "状态"

#: ../../reference/views.rst:488
msgid ""
"Uses the ``statusbar`` widget, and shows the current state in red. States "
"common to all flows (for instance, a sale order begins as a quotation, then "
"we send it, then it becomes a full sale order, and finally it is done) "
"should be visible at all times but exceptions or states depending on "
"particular sub-flow should only be visible when current."
msgstr "使用``statusbar``插件，并且用红色显示当前状态。规定共同所有流（例如，一个销售订单开始表现为报价，那么我们将其发送，那么它变成一个完整的销售订单，并且最后它完成）应在所有时间，但例外可见或状态取决于特定子-flow只应该看到，当电流。"

#: ../../reference/views.rst:500
msgid ""
"The states are shown following the order used in the field (the list in a "
"selection field, etc). States that are always visible are specified with the"
" attribute ``statusbar_visible``."
msgstr "其状态如图以下在该领域中使用的顺序（所述列表中的选择域，等等）。这始终可见国家指定的属性``statusbar_visible``。"

#: ../../reference/views.rst:504
msgid ""
"``statusbar_colors`` can be used to give a custom color to specific states."
msgstr "``statusbar_colors``可以用来给自定义颜色，以特定状态。"

#: ../../reference/views.rst:513
msgid "The Sheet"
msgstr "该表"

#: ../../reference/views.rst:515
msgid "All business views should look like a printed sheet:"
msgstr "所有的业务视图应该看起来像一个印张："

#: ../../reference/views.rst:520
msgid ""
"Elements inside a ``<form>`` or ``<page>`` do not define groups, elements "
"inside them are laid out according to normal HTML rules. They content can be"
" explicitly grouped using ``<group>`` or regular ``<div>`` elements."
msgstr "一个``<FORM>里面的元素``或``<页>``不定义组，在他们里面的元件布局按照正常的HTML规则。它们的内容可以使用``<集团>``或定期``<DIV>``元素被明确划分。"

#: ../../reference/views.rst:523
msgid ""
"By default, the element ``<group>`` defines two columns inside, unless an "
"attribute ``col=\"n\"`` is used.  The columns have the same width (1/n th of"
" the group's width). Use a ``<group>`` element to produce a column of "
"fields."
msgstr "默认情况下，该元素``<集团>``定义了两列在里面，除非一个属性``COL = \“N \”``使用。列具有相同的宽度（1 / n个组的宽度）。使用``<基团>``元素，以产生场的一列。"

#: ../../reference/views.rst:526
msgid ""
"To give a title to a section, add a ``string`` attribute to a ``<group>`` "
"element::"
msgstr "为了给一个标题为部分中，添加一个``string``属性为``<集团>``元素::"

#: ../../reference/views.rst:530
msgid "this replaces the former use of ``<separator string=\"XXX\"/>``."
msgstr "这取代了以前使用``<分隔字符串= \“XXX \”/>``的。"

#: ../../reference/views.rst:531
msgid ""
"The ``<field>`` element does not produce a label, except as direct children "
"of a ``<group>`` element\\ [#backwards-compatibility]_.  Use :samp:`<label "
"for=\"{field_name}>` to produce a label of a field."
msgstr "该``<字段>``元素不会产生一个标签，只是一个``<集团>``元素\\ [＃向后兼容性] _的直接孩子。用途：SAMP：`<标签= \“{FIELD_NAME}>`，以产生一个场的一个标签。"

#: ../../reference/views.rst:536
msgid "Sheet Headers"
msgstr "表头"

#: ../../reference/views.rst:538
msgid ""
"Some sheets have headers with one or more fields, and the labels of those "
"fields are only shown in edit mode."
msgstr "一些片材具有标头被一个或多个字段，这些字段的标签仅在编辑模式所示。"

#: ../../reference/views.rst:544 ../../reference/views.rst:650
msgid "View mode"
msgstr "浏览模式"

#: ../../reference/views.rst:545 ../../reference/views.rst:649
msgid "Edit mode"
msgstr "编辑模式"

#: ../../reference/views.rst:551
msgid ""
"Use HTML text, ``<div>``, ``<h1>``, ``<h2>``… to produce nice headers, and "
"``<label>`` with the class ``oe_edit_only`` to only display the field's "
"label in edit mode. The class ``oe_inline`` will make fields inline (instead"
" of blocks): content following the field will be displayed on the same line "
"rather than on the line below it. The form above is produced by the "
"following XML::"
msgstr "使用HTML文本，``<DIV>``，``<H1>``，``<H2>``...产生很好的头，和``<标签>``用类``oe_edit_only``到只显示在编辑模式下字段的标签。类``oe_inline``将使字段内联（而不是块）：内容领域以下将显示在同一行上，而不是在它下面的线。形式以上是由下面的XML生成::"

#: ../../reference/views.rst:568
msgid "Button Box"
msgstr "按钮盒"

#: ../../reference/views.rst:570
msgid ""
"Many relevant actions or links can be displayed in the form. For example, in"
" Opportunity form, the actions \"Schedule a Call\" and \"Schedule a "
"Meeting\" have an important place in the use of the CRM. Instead of placing "
"them in the \"More\" menu, put them directly in the sheet as buttons (on the"
" top) to make them more visible and more easily accessible."
msgstr "许多相关的操作或链接可以显示在表格。例如，在机会表单，动作\“预约来电\”和\“预定会议\”已经在使用CRM的重要场所。相反，将它们放置在\“更多\”菜单，把它们直接在表的按钮（顶部），使他们更加明显和更容易获得。"

#: ../../reference/views.rst:579
msgid ""
"Technically, the buttons are placed inside a ``<div>`` to group them as a "
"block on the top of the sheet."
msgstr "从技术上讲，这些按钮都放在里面了``<DIV>``组他们作为在纸的顶部块。"

#: ../../reference/views.rst:590
msgid "Groups and Titles"
msgstr "组和标题"

#: ../../reference/views.rst:592
msgid ""
"A column of fields is now produced with a ``<group>`` element, with an "
"optional title."
msgstr "字段的列现在生产用``<集团>``元素，带有可选的标题。"

#: ../../reference/views.rst:605
msgid ""
"It is recommended to have two columns of fields on the form. For this, "
"simply put the ``<group>`` elements that contain the fields inside a top-"
"level ``<group>`` element."
msgstr "建议有表单上字段的两列。对于这一点，干脆把``<集团>``这里面包含一个顶级``<集团>``元素的领域元素。"

#: ../../reference/views.rst:609
msgid ""
"To make :ref:`view extension <reference/views/inheritance>` simpler, it is "
"recommended to put a ``name`` attribute on ``<group>`` elements, so new "
"fields can easily be added at the right place."
msgstr "为了让：参考：`视图扩展<参考/视图/继承>`简单，建议把``name``属性的``<集团>``元素，所以新的领域可以很容易地在合适的添加的地方。"

#: ../../reference/views.rst:614
msgid "Special Case: Subtotals"
msgstr "特例：分类汇总"

#: ../../reference/views.rst:616
msgid "Some classes are defined to render subtotals like in invoice forms:"
msgstr "有些类的定义来呈现小计像发票的形式："

#: ../../reference/views.rst:631
msgid "Placeholders and Inline Fields"
msgstr "占位符和内联场"

#: ../../reference/views.rst:633
msgid ""
"Sometimes field labels make the form too complex. One can omit field labels,"
" and instead put a placeholder inside the field. The placeholder text is "
"visible only when the field is empty. The placeholder should tell what to "
"place inside the field, it *must not* be an example as they are often "
"confused with filled data."
msgstr "有时候字段标签使形式过于复杂。人们可以省略字段标签，而是把一个占位符领域内。占位符文本是可见的，只有当该字段为空。占位符应该告诉放入字段里面有什么，它*不能*是一个例子，因为他们经常被混淆与填充数据。"

#: ../../reference/views.rst:639
msgid ""
"One can also group fields together by rendering them \"inline\" inside an "
"explicit block element like ``<div>``. This allows grouping semantically "
"related fields as if they were a single (composite) fields."
msgstr "人们也可以组字段在一起使它们\“内联\”明确块元素里面像``<DIV>``。这允许分组语义相关的领域，就像它们是单个（复合）字段。"

#: ../../reference/views.rst:643
msgid ""
"The following example, taken from the *Leads* form, shows both placeholders "
"and inline fields (zip and city)."
msgstr "下面的例子，从*拍摄信息*的形式，同时显示占位符和内联字段（邮编及城市）。"

#: ../../reference/views.rst:673
msgid "Images"
msgstr "图片"

#: ../../reference/views.rst:675
msgid ""
"Images, like avatars, should be displayed on the right of the sheet.  The "
"product form looks like:"
msgstr "图像，像替身，应显示在片材的右侧。产品形式如下："

#: ../../reference/views.rst:681
msgid "The form above contains a <sheet> element that starts with:"
msgstr "上面的表格包含<表>元素开头："

#: ../../reference/views.rst:688
msgid "Tags"
msgstr "标签"

#: ../../reference/views.rst:690
msgid ""
"Most :class:`~openerp.fields.Many2many` fields, like categories, are better "
"rendered as a list of tags. Use the widget ``many2many_tags`` for this:"
msgstr "大多数产品类别：`〜openerp.fields.Many2many`领域里，如类别，更好地呈现为标签列表。使用Widget``many2many_tags``此："

#: ../../reference/views.rst:701
msgid "Configuration forms guidelines"
msgstr "配置形式指引"

#: ../../reference/views.rst:703
msgid ""
"Examples of configuration forms: Stages, Leave Type, etc.  This concerns all"
" menu items under Configuration of each application (like "
"Sales/Configuration)."
msgstr "阶段，休假类型，等等。这涉及到每个应用程序的配置下的所有菜单项（如销售/配置）：配置形式的实例。"

#: ../../reference/views.rst:709
msgid "no header (because no state, no workflow, no button)"
msgstr "没有头（因为没有一个国家，没有工作流，无按钮）"

#: ../../reference/views.rst:710 ../../reference/views.rst:735
msgid "no sheet"
msgstr "没有表"

#: ../../reference/views.rst:713
msgid "Dialog forms guidelines"
msgstr "对话框的形式指引"

#: ../../reference/views.rst:715
msgid "Example: \"Schedule a Call\" from an opportunity."
msgstr "例如：\“预约来电\”的一个机会。"

#: ../../reference/views.rst:720
msgid ""
"avoid separators (the title is already in the popup title bar, so another "
"separator is not relevant)"
msgstr "避免分隔符（标题已经在弹出的标题栏，所以另外一个分隔符是不相关的）"

#: ../../reference/views.rst:722
msgid ""
"avoid cancel buttons (user generally close the popup window to get the same "
"effect)"
msgstr "避免取消按钮（用户一般关闭弹出窗口来获得同样的效果）"

#: ../../reference/views.rst:724
msgid "action buttons must be highlighted (red)"
msgstr "操作按钮必须强调（红色）"

#: ../../reference/views.rst:725
msgid ""
"when there is a text area, use a placeholder instead of a label or a "
"separator"
msgstr "当有一个文本区域，而不是使用一个标签或一个分离器的占位符"

#: ../../reference/views.rst:727
msgid "like in regular form views, put buttons in the <header> element"
msgstr "就像在普通形式的意见，把按钮在<header>元素"

#: ../../reference/views.rst:730
msgid "Configuration Wizards guidelines"
msgstr "配置向导指引"

#: ../../reference/views.rst:732
msgid "Example: Settings / Configuration / Sales."
msgstr "例如：设置/配置/销售。"

#: ../../reference/views.rst:734
msgid "always in line (no popup)"
msgstr "总是在线的（不弹出）"

#: ../../reference/views.rst:736
msgid "keep the cancel button (users cannot close the window)"
msgstr "保持取消按钮（用户不能关闭窗口）"

#: ../../reference/views.rst:737
msgid "the button \"Apply\" must be red"
msgstr "按钮\“应用\”必须是红色的"

#: ../../reference/views.rst:743
msgid "Graphs"
msgstr "图"

#: ../../reference/views.rst:745
msgid ""
"The graph view is used to visualize aggregations over a number of records or"
" record groups. Its root element is ``<graph>`` which can take the following"
" attributes:"
msgstr "图形视图用于可视化聚集了大量的记录或记录组。它的根元素是``<图>``可以采取以下属性："

#: ../../reference/views.rst:750
msgid ""
"one of ``bar`` (default), ``pie`` and ``line``, the type of graph to use"
msgstr "的``bar``（默认），``pie``和`是`line``，用图表的类型"

#: ../../reference/views.rst:753
msgid "``stacked``"
msgstr "``stacked``"

#: ../../reference/views.rst:752
msgid ""
"only used for ``bar`` charts. If present and set to ``True``, stacks bars "
"within a group"
msgstr "仅用于``bar``图表。如果存在并设置为``True``，那么堆叠组内的酒吧"

#: ../../reference/views.rst:755
msgid ""
"The only allowed element within a graph view is ``field`` which can have the"
" following attributes:"
msgstr "的曲线图视图中的只允许元件是``field``其可以具有以下属性："

#: ../../reference/views.rst:760 ../../reference/views.rst:836
msgid "``name`` (required)"
msgstr "``name``（必填）"

#: ../../reference/views.rst:759
msgid ""
"the name of a field to use in a graph view. If used for grouping (rather "
"than aggregating)"
msgstr "在图中，以使用一个字段的名称。如果用于分组（而不是聚集）"

#: ../../reference/views.rst:763
msgid ""
"indicates whether the field should be used as a grouping criteria or as an "
"aggregated value within a group. Possible values are:"
msgstr "指示字段是否应该使用作为分组标准或作为组内的聚合值。可能的值有："

#: ../../reference/views.rst:768
msgid "``row`` (default)"
msgstr "``row``（默认）"

#: ../../reference/views.rst:767
msgid ""
"groups by the specified field. All graph types support at least one level of"
" grouping, some may support more. For pivot views, each group gets its own "
"row."
msgstr "组按指定字段。所有图表类型支持分组中的至少一个级别，一些可以支持更多。对于支点的意见，每个小组都有自己的行。"

#: ../../reference/views.rst:770
msgid "``col``"
msgstr "``col``"

#: ../../reference/views.rst:771
msgid "only used by pivot tables, creates column-wise groups"
msgstr "仅用于数据透视表，创建逐列组"

#: ../../reference/views.rst:773
msgid "``measure``"
msgstr "``measure``"

#: ../../reference/views.rst:773
msgid "field to aggregate within a group"
msgstr "现场在一组汇总"

#: ../../reference/views.rst:778
msgid "``interval``"
msgstr "``interval``"

#: ../../reference/views.rst:776
msgid ""
"on date and datetime fields, groups by the specified interval (``day``, "
"``week``, ``month``, ``quarter`` or ``year``) instead of grouping on the "
"specific datetime (fixed second resolution) or date (fixed day resolution)."
msgstr "日期和日期时间字段，组按指定的时间间隔（``day``，``week``，``month``，``quarter``或``year``），而不是具体的日期时间分组（固定的第二项决议案）或日期（固定一天分辨率）。"

#: ../../reference/views.rst:782
msgid ""
"graph view aggregations are performed on database content, non-stored "
"function fields can not be used in graph views"
msgstr "图形视图聚合是在数据库中的内容执行，非存储功能字段不能在图形视图中使用"

#: ../../reference/views.rst:786
msgid "Pivots"
msgstr "支点"

#: ../../reference/views.rst:788
msgid ""
"The pivot view is used to visualize aggregations as a `pivot table`_. Its "
"root element is ``<pivot>`` which can take the following attributes:"
msgstr "枢轴视图用于可视化聚合为一个'支点table`_。它的根元素是``<支点>``可以采取以下属性："

#: ../../reference/views.rst:791
msgid "``disable_linking``"
msgstr "``disable_linking``"

#: ../../reference/views.rst:792
msgid "Set to ``True`` to remove table cell's links to list view."
msgstr "设置为值为``True``删除表格单元格的链接列表视图。"

#: ../../reference/views.rst:794
msgid "``display_quantity``"
msgstr "``display_quantity``"

#: ../../reference/views.rst:794
msgid "Set to ``true`` to display the Quantity column by default."
msgstr "设置为值为``True``默认显示数量列。"

#: ../../reference/views.rst:796
msgid ""
"The elements allowed within a pivot view are the same as for the graph view."
msgstr "一个枢轴视图内所允许的元件是一样的图形视图。"

#: ../../reference/views.rst:801
msgid "Kanban"
msgstr "看板"

#: ../../reference/views.rst:803
msgid ""
"The kanban view is a `kanban board`_ visualisation: it displays records as "
"\"cards\", halfway between a :ref:`list view <reference/views/list>` and a "
"non-editable :ref:`form view <reference/views/form>`. Records may be grouped"
" in columns for use in workflow visualisation or manipulation (e.g. tasks or"
" work-progress management), or ungrouped (used simply to visualize records)."
msgstr "看板视图是一个'看板board`_可视化：它显示的记录为\“牌\”，半路之间：REF：'列表视图<参考/视图/列表>`和不可编辑：参考：`表单视图<参考/视图/表>`。记录可在工作流程的可视化和操纵使用的列进行分组（如任务或工作进度管理），或取消分组（使用简单的可视化记录）。"

#: ../../reference/views.rst:809
msgid ""
"The root element of the Kanban view is ``<kanban>``, it can use the "
"following attributes:"
msgstr "看板视图的根元素是``<看板>``，它可以使用以下属性："

#: ../../reference/views.rst:814 ../../reference/views.rst:1017
msgid "``default_group_by``"
msgstr "``default_group_by``"

#: ../../reference/views.rst:813
msgid ""
"whether the kanban view should be grouped if no grouping is specified via "
"the action or the current research. Should be the name of the field to group"
" by when no grouping is otherwise specified"
msgstr "无论是如果通过动作或目前的研究中没有指定分组看板认为应该进行分组。应该是场组时另有规定不分组的名称"

#: ../../reference/views.rst:817
msgid ""
"cards sorting order used if the user has not already sorted the records (via"
" the list view)"
msgstr "卡排序顺序使用，如果用户没有已经排序的记录（经由列表视图）"

#: ../../reference/views.rst:820
msgid "adds HTML classes to the root HTML element of the Kanban view"
msgstr "添加HTML类看板视图的根HTML元素"

#: ../../reference/views.rst:826
msgid "``quick_create``"
msgstr "``quick_create``"

#: ../../reference/views.rst:822
msgid ""
"whether it should be possible to create records without switching to the "
"form view. By default, ``quick_create`` is enabled when the Kanban view is "
"grouped, and disabled when not."
msgstr "是否应该是可能的创建记录，而不转换到形式图。默认情况下，``quick_create``时启用看板视图分组，并禁用时不会。"

#: ../../reference/views.rst:826
msgid ""
"Set to ``true`` to always enable it, and to ``false`` to always disable it."
msgstr "设置为值为``True``总是启用它，并且``false``总是禁用它。"

#: ../../reference/views.rst:828
msgid "Possible children of the view element are:"
msgstr "视图元素的可能孩子是："

#: ../../reference/views.rst:831
msgid ""
"declares fields to aggregate or to use in kanban *logic*. If the field is "
"simply displayed in the kanban view, it does not need to be pre-declared."
msgstr "声明了字段或聚集在看板*逻辑使用*。如果该字段被简单地显示在看板视图，它并不需要被预先声明。"

#: ../../reference/views.rst:834
msgid "Possible attributes are:"
msgstr "可能的属性有："

#: ../../reference/views.rst:837
msgid "the name of the field to fetch"
msgstr "抓取的字段的名称"

#: ../../reference/views.rst:841
msgid "``sum``, ``avg``, ``min``, ``max``, ``count``"
msgstr "``sum``，``avg``，``min``，``max``，``count``"

#: ../../reference/views.rst:839
msgid ""
"displays the corresponding aggregation at the top of a kanban column, the "
"field's value is the label of the aggregation (a string). Only one aggregate"
" operation per field is supported."
msgstr "显示在看板塔顶部的相应聚合，该字段的值是聚合（字符串）的标签。支持每场只有一个总的操作。"

#: ../../reference/views.rst:896
msgid "``templates``"
msgstr "``templates``"

#: ../../reference/views.rst:844
msgid ""
"defines a list of :ref:`reference/qweb` templates. Cards definition may be "
"split into multiple templates for clarity, but kanban views *must* define at"
" least one root template ``kanban-box``, which will be rendered once for "
"each record."
msgstr "定义列表：参考：`参考/ qweb`模板。卡定义可以被分成多个模板清晰，但看板意见*必须*至少定义一个根模板``看板box``，这将是为每个记录呈现的一次。"

#: ../../reference/views.rst:849
msgid ""
"The kanban view uses mostly-standard :ref:`javascript qweb "
"<reference/qweb/javascript>` and provides the following context variables:"
msgstr "看板观点大都采用标准：参考：`的JavaScript qweb <参考/ qweb / JavaScript的>`并提供以下环境变量："

#: ../../reference/views.rst:852
msgid "``instance``"
msgstr "``instance``"

#: ../../reference/views.rst:853
msgid "the current :ref:`reference/javascript/client` instance"
msgstr "当前：REF：`参考/ JavaScript的/ client`实例"

#: ../../reference/views.rst:855
msgid ""
"the current :js:class:`KanbanRecord`, can be used to fetch some meta-"
"information. These methods are also available directly in the template "
"context and don't need to be accessed via ``widget``"
msgstr "当前：JS：类：`KanbanRecord`，可以用来获取一些元信息。这些方法也可以直接在模板上下文中可用​​并且不需要经由``widget``访问"

#: ../../reference/views.rst:859
msgid ""
"an object with all the requested fields as its attributes. Each field has "
"two attributes ``value`` and ``raw_value``, the former is formatted "
"according to current user parameters, the latter is the direct value from a "
":meth:`~openerp.models.Model.read` (except for date and datetime fields that"
" are `formatted according to user's locale "
"<https://github.com/odoo/odoo/blob/8.0/addons/web_kanban/static/src/js/kanban.js#L900>`_)"
msgstr "的对象与所有的请求的字段作为其属性。每个字段有两个属性``value``和``raw_value``，前者是根据用户当前的参数格式化，后者是从一个直接价值：甲基：`〜openerp.models.Model.read`（除日期和日期时间字段被`根据用户的区域设置格式<https://github.com/odoo/odoo/blob/8.0/addons/web_kanban/static/src/js/kanban.js#L900>`_）"

#: ../../reference/views.rst:896
msgid "``read_only_mode``"
msgstr "``read_only_mode``"

#: ../../reference/views.rst:866
msgid "self-explanatory"
msgstr "不言自明"

#: ../../reference/views.rst:0
msgid "buttons and fields"
msgstr "按钮和字段"

#: ../../reference/views.rst:871
msgid ""
"While most of the Kanban templates are standard :ref:`reference/qweb`, the "
"Kanban view processes ``field``, ``button`` and ``a`` elements specially:"
msgstr "虽然大多数的看板模板标准：参考：`参考/ qweb`，看板查看进程``field``，``button``和``a``元素特别："

#: ../../reference/views.rst:874
msgid ""
"by default fields are replaced by their formatted value, unless they match "
"specific kanban view widgets"
msgstr "默认域由他们格式化的值被替换，除非它们与特定的看板视图控件"

#: ../../reference/views.rst:879
msgid ""
"buttons and links with a ``type`` attribute become perform Odoo-related "
"operations rather than their standard HTML function. Possible types are:"
msgstr "按钮和一个``type``属性将成为执行Odoo相关的操作，而不是他们的标准的HTML功能。可能的类型是："

#: ../../reference/views.rst:884
msgid "``action``, ``object``"
msgstr "``action``，``object``"

#: ../../reference/views.rst:883
msgid ""
"standard behavior for :ref:`Odoo buttons <reference/views/list/button>`, "
"most attributes relevant to standard Odoo buttons can be used."
msgstr "标准的行为：参考：`Odoo按钮<参考/视图/表/按钮>`，大多数属性相关的标准Odoo按钮都可以使用。"

#: ../../reference/views.rst:886
msgid "``open``"
msgstr "``open``"

#: ../../reference/views.rst:887
msgid "opens the card's record in the form view in read-only mode"
msgstr "打开表单视图卡的记录在只读模式"

#: ../../reference/views.rst:888
msgid "``edit``"
msgstr "``edit``"

#: ../../reference/views.rst:889
msgid "opens the card's record in the form view in editable mode"
msgstr "开证的记录在编辑模式下的表单视图"

#: ../../reference/views.rst:891
msgid "deletes the card's record and removes the card"
msgstr "删除存储卡的记录，并取出卡"

#: ../../reference/views.rst:899
msgid "Javascript API"
msgstr "的JavaScript API"

#: ../../reference/views.rst:903
msgid ""
":js:class:`Widget` handling the rendering of a single record to a card. "
"Available within its own rendering as ``widget`` in the template context."
msgstr "：JS：类：`Widget`处理一条记录到记忆卡中的呈现。可在自己的渲染为``widget``在模板环境。"

#: ../../reference/views.rst:909
msgid ""
"Converts a color segmentation value to a kanban color class "
":samp:`oe_kanban_color_{color_index}`. The built-in CSS provides classes up "
"to a ``color_index`` of 9."
msgstr "SAMP：`oe_kanban_color_ {color_index}`颜色分割值看板颜色类转换。内置的CSS提供类高达9``color_index``。"

#: ../../reference/views.rst:915
msgid ""
"Converts a color segmentation value to a color index (between 0 and 9 by "
"default). Color segmentation values can be either numbers or strings."
msgstr "一个颜色值分割为颜色索引（0到9之间默认情况下）转换。颜色分割值可以是数字或字符串。"

#: ../../reference/views.rst:920
msgid "Generates the URL to the specified field as an image access."
msgstr "生成的URL指定的字段作为图像接入。"

#: ../../reference/views.rst:922
msgid "model hosting the image"
msgstr "模型托管图像"

#: ../../reference/views.rst:923
msgid "name of the field holding the image data"
msgstr "场的保持的图像数据名"

#: ../../reference/views.rst:924
msgid "identifier of the record contaning the image to display"
msgstr "记录的标识符contaning要显示的图像"

#: ../../reference/views.rst:925
msgid ""
"caching duration (in seconds) of the browser default should be overridden. "
"``0`` disables caching entirely"
msgstr "浏览器默认的缓存时间（单位：秒）应该重写。 ``0``禁用完全缓存"

#: ../../reference/views.rst:928
msgid "an image URL"
msgstr "图片网址"

#: ../../reference/views.rst:932
msgid ""
"clips text beyond the specified size and appends an ellipsis to it. Can be "
"used to display the initial part of potentially very long fields (e.g. "
"descriptions) without the risk of unwieldy cards"
msgstr "剪辑文本超出指定的大小和一个省略号追加到它。可以不使用的笨重卡的危险，以显示可能非常长字段（例如描述）的初始部分"

#: ../../reference/views.rst:939
msgid "Calendar"
msgstr "历"

#: ../../reference/views.rst:941
msgid ""
"Calendar views display records as events in a daily, weekly or monthly "
"calendar. Their root element is ``<calendar>``. Available attributes on the "
"calendar view are:"
msgstr "日历视图显示记录在每天，每周或每月日历事件。他们的根元素是``<日历>``。在日历视图可用的属性有："

#: ../../reference/views.rst:945 ../../reference/views.rst:1002
msgid "``date_start`` (required)"
msgstr "``date_start``（必填）"

#: ../../reference/views.rst:946
msgid "name of the record's field holding the start date for the event"
msgstr "记录的字段持有的开始日期的事件名称"

#: ../../reference/views.rst:949 ../../reference/views.rst:1009
msgid "``date_stop``"
msgstr "``date_stop``"

#: ../../reference/views.rst:948
msgid ""
"name of the record's field holding the end date for the event, if "
"``date_stop`` is provided records become movable (via drag and drop) "
"directly in the calendar"
msgstr "该记录的字段持有的结束日期的情况下，如果``提供date_stop``记录成为移动（通过拖放）的名字直接在日历"

#: ../../reference/views.rst:955 ../../reference/views.rst:1011
msgid "``date_delay``"
msgstr "``date_delay``"

#: ../../reference/views.rst:952
msgid ""
"alternative to ``date_end``, provides the duration of the event instead of "
"its end date"
msgstr "替代``date_end``，提供事件，而不是它的结束日期的时间"

#: ../../reference/views.rst:959
msgid "``color``"
msgstr "``color``"

#: ../../reference/views.rst:958
msgid ""
"name of a record field to use for *color segmentation*. Records in the same "
"color segment are allocated the same highlight color in the calendar, colors"
" are allocated semi-randomly."
msgstr "用于*色彩分割记录字段的名称*。在相同颜色段记录被分配在日历相同的高亮颜色，颜色被分配半随机。"

#: ../../reference/views.rst:962
msgid "``event_open_popup``"
msgstr "``event_open_popup``"

#: ../../reference/views.rst:962
msgid ""
"opens the event in a dialog instead of switching to the form view, enabled "
"by default"
msgstr "在打开对话框，而不是切换到表单视图时，默认情况下启用"

#: ../../reference/views.rst:966
msgid "``quick_add``"
msgstr "``quick_add``"

#: ../../reference/views.rst:965
msgid ""
"enables quick-event creation on click: only asks the user for a ``name`` and"
" tries to create a new event with just that and the clicked event time. "
"Falls back to a full form dialog if the quick creation fails"
msgstr "使上点击快速事件创建：只要求用户输入一个``name``，并尝试与只是和点击事件时间创建一个新的事件。回落到一个完整的表格对话框，如果快速创建失败"

#: ../../reference/views.rst:969
msgid "``display``"
msgstr "``display``"

#: ../../reference/views.rst:969
msgid ""
"format string for event display, field names should be within brackets ``[``"
" and ``]``"
msgstr "格式字符串的事件显示，字段名应该是括号内``[``和``]``"

#: ../../reference/views.rst:974
msgid "``all_day``"
msgstr "``all_day``"

#: ../../reference/views.rst:972
msgid ""
"name of a boolean field on the record indicating whether the corresponding "
"event is flagged as day-long (and duration is irrelevant)"
msgstr "在记录一个布尔字段，表示相应的事件是否被标记为一天的名称（和持续时间无关）"

#: ../../reference/views.rst:994
msgid "Gantt"
msgstr "甘特图"

#: ../../reference/views.rst:996
msgid "Gantt views appropriately display Gantt charts (for scheduling)."
msgstr "甘特的看法正确显示甘特图（调度）。"

#: ../../reference/views.rst:998
msgid ""
"The root element of gantt views is ``<gantt/>``, it has no children but can "
"take the following attributes:"
msgstr "甘特视图的根元素是``<甘特图/>``，它没有子女，但可以采取以下属性："

#: ../../reference/views.rst:1002
msgid ""
"name of the field providing the start datetime of the event for each record."
msgstr "现场提供事件的每个记录的开始日期时间命名。"

#: ../../reference/views.rst:1005
msgid ""
"name of the field providing the end duration of the event for each record. "
"Can be replaced by ``date_delay``. One (and only one) of ``date_stop`` and "
"``date_delay`` must be provided."
msgstr "领域提供该事件的每个记录的末尾持续时间命名。可以通过``date_delay``所取代。一个``date_stop``和``date_delay``必须提供（也是唯一一个）。"

#: ../../reference/views.rst:1009
msgid ""
"If the field is ``False`` for a record, it's assumed to be a \"point event\""
" and the end date will be set to the start date"
msgstr "如果该字段为``False``的记录，它认为是一个\“点事件\”和结束日期将被设置为起始日期"

#: ../../reference/views.rst:1012
msgid "name of the field providing the duration of the event"
msgstr "领域提供所述事件的持续时间的命名"

#: ../../reference/views.rst:1014
msgid "``progress``"
msgstr "``progress``"

#: ../../reference/views.rst:1014
msgid ""
"name of a field providing the completion percentage for the record's event, "
"between 0 and 100"
msgstr "一个领域提供备案的情况下完成的百分比，介于0和100名"

#: ../../reference/views.rst:1017
msgid "name of a field to group tasks by"
msgstr "通过向组任务的场的命名"

#: ../../reference/views.rst:1033
msgid "Diagram"
msgstr "图解"

#: ../../reference/views.rst:1035
msgid ""
"The diagram view can be used to display directed graphs of records. The root"
" element is ``<diagram>`` and takes no attributes."
msgstr "图示视图可用于显示记录有向图。根元素是``<图>``它不带任何属性。"

#: ../../reference/views.rst:1038
msgid "Possible children of the diagram view are:"
msgstr "图表视图的可能孩子是："

#: ../../reference/views.rst:1051
msgid "``node`` (required, 1)"
msgstr "``node``（需要1）"

#: ../../reference/views.rst:1041
msgid "Defines the nodes of the graph. Its attributes are:"
msgstr "定义了图的节点。其特征是："

#: ../../reference/views.rst:1044
msgid "the node's Odoo model"
msgstr "节点的Odoo模型"

#: ../../reference/views.rst:1047
msgid "``shape``"
msgstr "``shape``"

#: ../../reference/views.rst:1046
msgid ""
"conditional shape mapping similar to colors and fonts in :ref:`the list view"
" <reference/views/list>`. The only valid shape is ``rectangle`` (the default"
" shape is an ellipsis)"
msgstr "参考：类似的颜色和字体有条件的造型映射'列表视图<参考/视图/列表>`。唯一有效的形状``rectangle``（默认形状是一个省略号）"

#: ../../reference/views.rst:1051
msgid "``bgcolor``"
msgstr "``bgcolor``"

#: ../../reference/views.rst:1050
msgid ""
"same as ``shape``, but conditionally maps a background color for nodes. The "
"default background color is white, the only valid alternative is ``grey``."
msgstr "一样``shape``，但有条件映射的背景色节点。默认的背景色为白色，唯一有效的办法是``grey``。"

#: ../../reference/views.rst:1067
msgid "``arrow`` (required, 1)"
msgstr "``arrow``（需要1）"

#: ../../reference/views.rst:1054
msgid "Defines the directed edges of the graph. Its attributes are:"
msgstr "定义了图的有向边。其特征是："

#: ../../reference/views.rst:1056
msgid "``object`` (required)"
msgstr "``object``（必填）"

#: ../../reference/views.rst:1057
msgid "the edge's Odoo model"
msgstr "边缘的Odoo模型"

#: ../../reference/views.rst:1059
msgid "``source`` (required)"
msgstr "``source``（必填）"

#: ../../reference/views.rst:1059
msgid ""
":class:`~openerp.fields.Many2one` field of the edge's model pointing to the "
"edge's source node record"
msgstr "产品类别：`〜openerp.fields.Many2one`场边缘的模型指向的边缘的源节点纪录"

#: ../../reference/views.rst:1062
msgid "``destination`` (required)"
msgstr "``destination``（必填）"

#: ../../reference/views.rst:1062
msgid ""
":class:`~openerp.fields.Many2one` field of the edge's model pointing to the "
"edge's destination node record"
msgstr "产品类别：`〜openerp.fields.Many2one`场边缘的模型指向的边缘的目的节点记录"

#: ../../reference/views.rst:1067 ../../reference/views.rst:1072
msgid "``label``"
msgstr "``label``"

#: ../../reference/views.rst:1065
msgid ""
"Python list of attributes (as quoted strings). The corresponding "
"attributes's values will be concatenated and displayed as the edge's label"
msgstr "属性Python列表（引字符串）。相应属性的值将被连接起来并显示为边的标签"

#: ../../reference/views.rst:1070
msgid ""
"Explanatory note for the diagram, the ``string`` attribute defines the "
"note's content. Each ``label`` is output as a paragraph in the diagram "
"header, easily visible but without any special emphasis."
msgstr "解释性说明的图中，``string``属性定义了注释的内容。每个``label``是如在图报头，很容易看到，但没有任何特别强调一个段落的输出。"

#: ../../reference/views.rst:1077
msgid "Search"
msgstr "搜"

#: ../../reference/views.rst:1079
msgid ""
"Search views are a break from previous view types in that they don't display"
" *content*: although they apply to a specific model, they are used to filter"
" other view's content (generally aggregated views e.g. "
":ref:`reference/views/list` or :ref:`reference/views/graph`). Beyond that "
"difference in use case, they are defined the same way."
msgstr "搜索视图是从以前的视图类型，因为它们不显示*量*休息：虽然它们适用于一个特定的模式，它们是用来过滤其他视图的内容（一般汇总的意见，例如：参考：`参考/视图/名单`或：参考：`参考/视图/ graph`）。以外使用的情况下的差异，它们被定义的方式相同。"

#: ../../reference/views.rst:1085
msgid ""
"The root element of search views is ``<search>``. It takes no attributes."
msgstr "搜索视图的根元素是``<搜索>``。它不带任何属性。"

#: ../../reference/views.rst:1089
msgid "Possible children elements of the search view are:"
msgstr "搜索视图中可能的子元素有："

#: ../../reference/views.rst:1092
msgid ""
"fields define domains or contexts with user-provided values. When search "
"domains are generated, field domains are composed with one another and with "
"filters using **AND**."
msgstr "字段定义域或语境与用户提供的值。当生成搜索域，场域由具有彼此之间以及与使用的过滤器** **与。"

#: ../../reference/views.rst:1096
msgid "Fields can have the following attributes:"
msgstr "字段可以具有以下属性："

#: ../../reference/views.rst:1099
msgid "the name of the field to filter on"
msgstr "字段的名称过滤上"

#: ../../reference/views.rst:1101
msgid "the field's label"
msgstr "该领域的标签"

#: ../../reference/views.rst:1110
msgid "``operator``"
msgstr "``operator``"

#: ../../reference/views.rst:1103
msgid ""
"by default, fields generate domains of the form :samp:`[({name}, {operator},"
" {provided_value})]` where ``name`` is the field's name and "
"``provided_value`` is the value provided by the user, possibly filtered or "
"transformed (e.g. a user is expected to provide the *label* of a selection "
"field's value, not the value itself)."
msgstr "默认情况下，场生成表单域：SAMP：`[（{名}，{运营商}，{provided_value}）]`，其中``name``是字段的名称和``provided_value``是所提供的价值用户，可能是过滤或转化（例如，一个用户被预期提供的选择字段的值，而不是值本身的*标记*）。"

#: ../../reference/views.rst:1109
msgid ""
"The ``operator`` attribute allows overriding the default operator, which "
"depends on the field's type (e.g. ``=`` for float fields but ``ilike`` for "
"char fields)"
msgstr "该``operator``属性允许覆盖默认的运营商，这取决于字段的类型（如``=``浮法领域，但``ilike``对于char字段）"

#: ../../reference/views.rst:1118
msgid "``filter_domain``"
msgstr "``filter_domain``"

#: ../../reference/views.rst:1113
msgid ""
"complete domain to use as the field's search domain, can use a ``self`` "
"variable to inject the provided value in the custom domain. Can be used to "
"generate significantly more flexible domains than ``operator`` alone (e.g. "
"searches on multiple fields at once)"
msgstr "完整的域名作为字段的搜索域名使用，可以使用``self``变量注入的自定义域提供的值。可以使用（同时对多个字段，例如搜索）产生显著更灵活的域比``独自operator``"

#: ../../reference/views.rst:1118
msgid ""
"If both ``operator`` and ``filter_domain`` are provided, ``filter_domain`` "
"takes precedence."
msgstr "如果两个``operator``和``filter_domain``提供，``filter_domain``优先。"

#: ../../reference/views.rst:1121
msgid ""
"allows adding context keys, including the user-provided value (which as for "
"``domain`` is available as a ``self`` variable). By default, fields don't "
"generate domains."
msgstr "允许添加背景下键，包括用户提供的值（作为``domain``可作为一个``self``变量）。默认情况下，田地不产生域。"

#: ../../reference/views.rst:1125
msgid ""
"the domain and context are inclusive and both are generated if if a "
"``context`` is specified. To only generate context values, set "
"``filter_domain`` to an empty list: ``filter_domain=\"[]\"``"
msgstr "域和上下文的包容性，如果指定了``context``既产生。只生成背景值，设置``filter_domain``到一个空表：``filter_domain = \“[] \”``"

#: ../../reference/views.rst:1130
msgid "make the field only available to specific users"
msgstr "使现场只提供给特定用户"

#: ../../reference/views.rst:1132
msgid ""
"use specific search widget for the field (the only use case in standard Odoo"
" 8.0 is a ``selection`` widget for :class:`~openerp.fields.Many2one` fields)"
msgstr "使用特定的搜索窗口小部件领域（唯一的用例的标准Odoo 8.0是一个``selection``小部件：类：`〜openerp.fields.Many2one`字段）"

#: ../../reference/views.rst:1136
msgid ""
"if the field can provide an auto-completion (e.g. "
":class:`~openerp.fields.Many2one`), filters the possible completion results."
msgstr "如果字段可以提供自动完成（如：类：`〜openerp.fields.Many2one`），过滤可能的完成结果。"

#: ../../reference/views.rst:1189
msgid "``filter``"
msgstr "``filter``"

#: ../../reference/views.rst:1141
msgid ""
"a filter is a predefined toggle in the search view, it can only be enabled "
"or disabled. Its main purposes are to add data to the search context (the "
"context passed to the data view for searching/filtering), or to append new "
"sections to the search filter."
msgstr "过滤器在搜索视图中预定义的切换，它只能启用或禁用。它的主要目的是将数据添加到搜索范围内（通过为搜索/过滤数据视图中的上下文中），或追加新章节的搜索过滤器。"

#: ../../reference/views.rst:1146
msgid "Filters can have the following attributes:"
msgstr "过滤器可以具有以下属性："

#: ../../reference/views.rst:1149
msgid "the label of the filter"
msgstr "过滤器的标签"

#: ../../reference/views.rst:1151
msgid ""
"an Odoo :ref:`domain <reference/orm/domains>`, will be appended to the "
"action's domain as part of the search domain"
msgstr "一个Odoo：参考：'域<参考/ ORM /域>`，将被追加到诉讼的域名作为搜索域的一部分"

#: ../../reference/views.rst:1154
msgid ""
"a Python dictionary, merged into the action's domain to generate the search "
"domain"
msgstr "Python字典，合并到行动的领域，以生成搜索域名"

#: ../../reference/views.rst:1157
msgid ""
"logical name for the filter, can be used to :ref:`enable it by default "
"<reference/views/search/defaults>`, can also be used as :ref:`inheritance "
"hook <reference/views/inheritance>`"
msgstr "为过滤逻辑名，可用于：参考：`默认情况下启用它<参考/视图/搜索/默认值>`，也可以用作：参考：`继承钩<参考/视图/继承>`"

#: ../../reference/views.rst:1161
msgid ""
"a longer explanatory text for the filter, may be displayed as a tooltip"
msgstr "更长的说明文字过滤器，可能会显示为一个工具提示"

#: ../../reference/views.rst:1164
msgid "makes a filter only available to specific users"
msgstr "使得只提供给特定用户过滤器"

#: ../../reference/views.rst:1170
msgid ""
"Sequences of filters (without non-filters separating them) are treated as "
"inclusively composited: they will be composed with ``OR`` rather than the "
"usual ``AND``, e.g."
msgstr "过滤器序列（不含非滤波器把它们分开）被视为（含）合成：它们将与``OR``组成，而不是通常``AND``，例如"

#: ../../reference/views.rst:1179
msgid ""
"if both filters are selected, will select the records whose ``state`` is "
"``draft`` or ``done``, but"
msgstr "如果两个滤光片的选择，将选择``state``是``draft``或``done``记录，但"

#: ../../reference/views.rst:1188
msgid ""
"if both filters are selected, will select the records whose ``state`` is "
"``draft`` **and** ``delay`` is below 15."
msgstr "如果两个滤光片的选择，将选择``state``是``draft`` **和**``delay``低于15的记录。"

#: ../../reference/views.rst:1192
msgid "can be used to separates groups of filters in simple search views"
msgstr "可用于分离过滤器组简单的搜索视图"

#: ../../reference/views.rst:1194
msgid ""
"can be used to separate groups of filters, more readable than ``separator`` "
"in complex search views"
msgstr "可用于过滤器不同的群体，比`更具可读性`separator``在复杂的搜索视图"

#: ../../reference/views.rst:1200
msgid "Search defaults"
msgstr "搜索默认"

#: ../../reference/views.rst:1202
msgid ""
"Search fields and filters can be configured through the action's ``context``"
" using :samp:`search_default_{name}` keys. For fields, the value should be "
"the value to set in the field, for filters it's a boolean value. For "
"instance, assuming ``foo`` is a field and ``bar`` is a filter an action "
"context of:"
msgstr "SAMP：搜索字段和筛选器可以通过诉讼的``context``使用配置`search_default_ {名}`键。对于字段，其值应在现场设置值，过滤器是一个布尔值。例如，假定``foo``是一个字段和``bar``是过滤器的一个动作的上下文："

#: ../../reference/views.rst:1214
msgid ""
"will automatically enable the ``bar`` filter and search the ``foo`` field "
"for *acro*."
msgstr "会自动启用``bar``过滤器和搜索``foo``领域* ACRO *。"

#: ../../reference/views.rst:1222
msgid ""
"QWeb views are standard :ref:`reference/qweb` templates inside a view's "
"``arch``. They don't have a specific root element."
msgstr "QWeb的观点是标准：REF：内部的视图的```arch``参考/ qweb`模板。它们不具有特定的根元素。"

#: ../../reference/views.rst:1225
msgid ""
"A QWeb view can only contain a single template\\ [#template_inherit]_, and "
"the template's name *must* match the view's complete (including module name)"
" :term:`external id`."
msgstr "一个QWeb观点只能包含一个模板\\ [#template_inherit] _，和模板的名称*必须*匹配视图的完整（包括模块名称）：短期：`外部ID`。"

#: ../../reference/views.rst:1229
msgid ""
":ref:`reference/data/template` should be used as a shortcut to define QWeb "
"views."
msgstr "：参考：`参考/数据/ template`应作为界定QWeb意见的快捷方式。"

#: ../../reference/views.rst:1232
msgid "for backwards compatibility reasons"
msgstr "为了向下兼容的原因"

#: ../../reference/views.rst:1233
msgid ""
"an extension function is added for simpler matching in QWeb views: "
"``hasclass(*classes)`` matches if the context node has all the specified "
"classes"
msgstr "扩展功能增加了简单的匹配在QWeb观点：``hasclass（*类）``匹配。如果该节点已全部指定类"

#: ../../reference/views.rst:1236
msgid ""
"for historical reasons, it has its origin in tree-type views later "
"repurposed to a more table/list-type display"
msgstr "由于历史的原因，它有它的起源在树型意见后重新利用到多个表/列表式展示"

#: ../../reference/views.rst:1238
msgid ""
"or no template if it's an inherited view, then :ref:`it should only contain "
"xpath elements <reference/views/inheritance>`"
msgstr "或者没有模板，如果它是一个继承的观点，那么：参考：`它应该只包含XPath的元素<参考/视图/继承>`"

#: ../../reference/workflows.rst:4
msgid "Workflows"
msgstr "工作流程"

#: ../../reference/workflows.rst:6
msgid ""
"In Odoo, a workflow is a technical artefact to manage a set of \"things to "
"do\" associated to the records of a model. The workflow provides a higher-"
"level way to organize tasks to perform with or on a record."
msgstr "在Odoo，工作流是一个技术人工制品来管理一组\“的事情做\”关联模型的记录。工作流提供了一个较高级别的方式来组织任务或上的记录来执行。"

#: ../../reference/workflows.rst:10
msgid ""
"More specifically, a workflow is a directed graph where the nodes are called"
" \"activities\" and the arcs are called \"transitions\"."
msgstr "更具体地，工作流是一个有向图，其中节点被称为\“活动\”和弧称为\“跃迁\”。"

#: ../../reference/workflows.rst:13
msgid ""
"Activities define work that should be done within the Odoo server, such as "
"changing the state of some records, or sending emails."
msgstr "活动定义应该在Odoo服务器内进行，比如改变一些记录状态，或发送电子邮件的工作。"

#: ../../reference/workflows.rst:15
msgid ""
"Transitions control how the workflow progresses from activity to activity."
msgstr "转换控制工作流程，从活动如何进展到活动。"

#: ../../reference/workflows.rst:17
msgid ""
"In the definition of a workflow, one can attach conditions, signals, and "
"triggers to transitions, so that the behavior of the workflow depends on "
"user actions (such as clicking on a button), changes to records, or "
"arbitrary Python code."
msgstr "在工作​​流的定义中，可以附加条件，信号和触发器的转换，从而使工作流的行为取决于用户动作（诸如点击一个按钮），改变的记录，或任意Python代码。"

#: ../../reference/workflows.rst:22
msgid "All in all, Odoo's workflow system provides:"
msgstr "总而言之，Odoo的工作流系统提供："

#: ../../reference/workflows.rst:24
msgid "a description of the evolution of a record (document) over time"
msgstr "记录（文件）的演变随着时间的说明"

#: ../../reference/workflows.rst:25
msgid "automatic actions based on various and flexible conditions"
msgstr "基于各种灵活的条件自动操作"

#: ../../reference/workflows.rst:26
msgid "management of company roles and validation steps"
msgstr "公司的角色和验证步骤的管理"

#: ../../reference/workflows.rst:27
msgid "management of interactions between objects"
msgstr "对象之间的交互的管理"

#: ../../reference/workflows.rst:28
msgid "a visual representation of document flows through their lifecycle"
msgstr "文件的可视化表示流经它们的生命周期"

#: ../../reference/workflows.rst:30
msgid "For instance, a basic order could have the following flow:"
msgstr "例如，一个基本的顺序可能具有以下流程："

#: ../../reference/workflows.rst:39
msgid ""
"Orders start in the *Draft* state, can be *Confirmed* by a user, and then "
"either shipped (*Closed*) or *Canceled*."
msgstr "订单开始在*选秀*状态，可*确认*由用户，然后或者发货（*逢*）或*取消*。"

#: ../../reference/workflows.rst:42
msgid ""
"A company using Odoo may want to add discount support to orders, where sales"
" staff has discretionary discounting powers up to 15%, but manager "
"validation is required for discounts beyond 15%. The workflow can be altered"
" online to add the relevant steps without editing Python or XML files:"
msgstr "使用Odoo公司可能需要增加贴息支持的定单，销售人员有自由裁量的权力折扣高达15％，但经理的验证需要超过15％的折扣。工作流程可以在线修改补充相关步骤，而无需编辑Python或XML文件："

#: ../../reference/workflows.rst:50
msgid ""
"Because Activities can perform arbitrary actions, the *Validation* can "
"automatically send a validation request to the relevant employee."
msgstr "由于活动可以执行任意的操作，在*验证*可以自动发送验证请求到相关员工。"

#: ../../reference/workflows.rst:53
msgid ""
"the order view needs to be modified to add an *Accept Discount* button for "
"managers"
msgstr "订单观点需要进行修改，以添加*接受折扣*键经理"

#: ../../reference/workflows.rst:57
msgid "Basics"
msgstr "基础知识"

#: ../../reference/workflows.rst:59
msgid ""
"Defining a workflow with data files is straightforward: a record "
"\"workflow\" is given together with records for the activities and the "
"transitions. For instance, here is a simple sequence of two activities "
"defined in XML"
msgstr "定义与数据文件的工作流程很简单：一个记录\“工作流程\”与的活动和过渡记录一起给予。例如，下面是两个活动的XML定义的简单序列"

#: ../../reference/workflows.rst:91
msgid ""
"A worfklow is always defined with respect to a particular model (the model "
"is given by the attribute ``osv`` on the model ``workflow``). Methods "
"specified in the activities or transitions will be called on that model."
msgstr "一个worfklow始终定义相对于特定模型（该模型通过对模型``workflow``属性``osv``给出）。在活动或过渡规定的方法将被调用的这种模式。"

#: ../../reference/workflows.rst:95
msgid ""
"In the example code above, a workflow called \"test_workflow\" is created. "
"It is made up of two activies, named \"a\" and \"b\", and one transition, "
"going from \"a\" to \"b\"."
msgstr "在上面的示例代码，创建了一个名为\“test_workflow \”的工作流程。它是由两个activies，名为\“一个\”和\“B \”，和一种过渡，从\“一个\”打算\“B \”。"

#: ../../reference/workflows.rst:99
msgid ""
"The first activity has its attribute ``flow_start`` set to ``True`` so that "
"Odoo knows where to start the workflow traversal after it is instanciated. "
"Because ``on_create`` is set to True on the workflow record, the workflow is"
" instanciated for each newly created record. (Otherwise, the workflow should"
" be instanciated by other means, such as from some module Python code.)"
msgstr "第一个活动都有其属性``flow_start``设置值为``True``，这样Odoo知道从哪里开始工作流程穿越它被实例化后。因为``on_create``设置为True工作流的记录，工作流实例化每个新创建的记录。 （否则，该工作流程应通过其他方式，如从一些模块Python代码实例化）。"

#: ../../reference/workflows.rst:105
msgid ""
"When the workflow is instanciated, it begins with activity \"a\". That "
"activity is of kind ``function``, which means that the action ``print_a()`` "
"is a method call on the model ``test.workflow`` (the usual ``cr, uid, ids, "
"context`` arguments are passed for you)."
msgstr "当工作流实例化，它以活动\“一\”。这项活动是种``function``，这意味着行动``print_a（）``是型号``test.workflow``一个方法调用（通常的``CR，UID，IDS，context` `参数传递给你）。"

#: ../../reference/workflows.rst:110
msgid ""
"The transition between \"a\" and \"b\" does not specify any condition. This "
"means that the workflow instance immediately goes from \"a\" to \"b\" after "
"\"a\" has been processed, and thus also processes activity \"b\"."
msgstr "与\“一\”和\“B \”的转变不指定任何条件。这意味着，工作流实例立即变为从\“一个\”到\“B \”之后\“一个\”已被处理，并且因此还可以处理活动\“B \”。"

#: ../../reference/workflows.rst:115
msgid "Activities"
msgstr "活动"

#: ../../reference/workflows.rst:117
msgid ""
"While the transitions can be seen as the control structures of the "
"workflows, activities are where everything happens, from changing record "
"states to sending email."
msgstr "虽然转换可以看作是工作流的控制结构，活动是在那里发生的一切，更改记录状态，以发送电子邮件。"

#: ../../reference/workflows.rst:121
msgid ""
"Different kinds of activities exist: ``Dummy``, ``Function``, ``Subflow``, "
"and ``Stop all``, each doing different things when the activity is "
"processed. In addition to their kind, activies have other properties, "
"detailed in the next sections."
msgstr "不同类型的活动有：``Dummy``，``Function``，``Subflow``，和``停止all``，每做不同的事情，当活动进行处理。除了他们的善良，activies有其他的属性，在接下来的章节中详细介绍。"

#: ../../reference/workflows.rst:127
msgid "Flow start and flow stop"
msgstr "流式细胞启动和流停止"

#: ../../reference/workflows.rst:129
msgid ""
"The attribute ``flow_start`` is a boolean value specifying whether the "
"activity is processed when the workflow is instanciated. Multiple activities"
" can have their attribute ``flow_start`` set to ``True``. When instanciating"
" a workflow for a record, Odoo simply processes all of them, and evaluate "
"all their outgoing transitions afterwards."
msgstr "属性``flow_start``是一个布尔值，指明是否当工作流实例化活动进行处理。多活动可以有自己的属性``flow_start``设置值为``True``。当为记录instanciating工作流程，Odoo只是处理所有这些，并评估所有的输出转移之后。"

#: ../../reference/workflows.rst:135
msgid ""
"The attribute ``flow_stop`` is a boolean value specifying whether the "
"activity stops the workflow instance. A workflow instance is considered "
"completed when all its activities with the attribute ``flow_stop`` set to "
"``True`` are completed."
msgstr "属性``flow_stop``是一个布尔值，指定活动是否停止工作流实例。工作流实例被认为是当所有的活动属性``flow_stop``设置值为``True``完成完成。"

#: ../../reference/workflows.rst:140
msgid ""
"It is important for Odoo to know when a workflow instance is completed. A "
"workflow can have an activity that is actually another workflow (called a "
"subflow); that activity is completed when the subflow is completed."
msgstr "这一点很重要Odoo知道何时工作流实例被完成。工作流可以有一个活动，实际上是另一个工作流（称为子流）;当子流程完成该活动已完成。"

#: ../../reference/workflows.rst:145
msgid "Subflow"
msgstr "子流程"

#: ../../reference/workflows.rst:147
msgid ""
"An activity can embed a complete workflow, called a subflow (the embedding "
"workflow is called the parent workflow). The workflow to instanciate is "
"specified by attribute ``subflow_id``."
msgstr "活性可以嵌入一个完整的工作流，称为子流（嵌入工作流称为父工作流程）。工作流实例化是通过属性``subflow_id``规定。"

#: ../../reference/workflows.rst:151
msgid ""
"In the GUI, that attribute can not be set unless the kind of the activity is"
" ``Subflow``."
msgstr "在GUI中，该属性不能被设置，除非那种活性是``Subflow``。"

#: ../../reference/workflows.rst:154
msgid ""
"The activity is considered completed (and its outgoing transitions ready to "
"be evaluated) when the subflow is completed (see attribute ``flow_stop`` "
"above)."
msgstr "该活动被认为是完成了（和它的外向转移准备进行评估）时，子流程完成（见属性``以上flow_stop``）。"

#: ../../reference/workflows.rst:158
msgid "Sending a signal from a subflow"
msgstr "从子流发送的信号"

#: ../../reference/workflows.rst:160
msgid ""
"When a workflow is embedded in an activity (as a subflow) of a workflow, the"
" sublow can send a signal from its own activities to the parent workflow by "
"giving a signal name in the attribute ``signal_send``. Odoo processes those "
"activities by sending the value of ``signal_send`` prefixed by \"subflow.\""
"  to the parent workflow instance."
msgstr "当工作流被嵌入的活性（作为子流）的工作流的，该sublow可以通过在属性``signal_send``给出的信号名从它自己的活动将信号发送到父工作流程。 Odoo通过发送``signal_send``由\前缀值处理这些活动“子流程。\”到父工作流实例。"

#: ../../reference/workflows.rst:166
msgid ""
"In other words, it is possible to react and get transitions in the parent "
"workflow as activities are executed in the sublow."
msgstr "换句话说，有可能作出反应，并作为活动是以sublow执行获得在父工作流程的转换。"

#: ../../reference/workflows.rst:170
msgid "Server actions"
msgstr "服务器操作"

#: ../../reference/workflows.rst:172
msgid ""
"An activity can run a \"Server Action\" by specifying its ID in the "
"attribute ``action_id``."
msgstr "一个活动可以通过指定其ID属性中的``action_id``运行\“服务器操作\”。"

#: ../../reference/workflows.rst:176
msgid "Python action"
msgstr "蟒蛇行动"

#: ../../reference/workflows.rst:178
msgid ""
"An activity can execute some Python code, given by the attribute ``action``."
" The evaluation environment is the same as the one explained in the section "
"`Conditions`_."
msgstr "一个活动可以执行一些Python代码，由属性``action``给出。评估环境是相同的，在部分`Conditions`_所述一个说明。"

#: ../../reference/workflows.rst:183
msgid "Split mode"
msgstr "分离模式"

#: ../../reference/workflows.rst:185
msgid ""
"After an activity has been processed, Odoo evaluates its transition to reach"
" the next activity in the flow."
msgstr "后的活性已被处理，Odoo评价其过渡到到达下一个活动中的流动。"

#: ../../reference/workflows.rst:188
msgid ""
"However if an activity has more than one transition, Odoo must decide which "
"activity or activities to follow."
msgstr "但是，如果一个活动有多个转变，Odoo必须决定要遵循哪些活动或活动。"

#: ../../reference/workflows.rst:194
msgid "This choice is controlled by the ``split_mode`` attribute:"
msgstr "这种选择是由``split_mode``属性控制："

#: ../../reference/workflows.rst:197 ../../reference/workflows.rst:222
msgid "``XOR`` (default)"
msgstr "``XOR``（默认）"

#: ../../reference/workflows.rst:197
msgid ""
"By default, Odoo will use the first transition (in ``sequence`` order) whose"
" condition is satisfied. All other transitions are ignored."
msgstr "默认情况下，Odoo将使用第一个转换（在``sequence``顺序）的条件被满足。所有其它的过渡将被忽略。"

#: ../../reference/workflows.rst:201
msgid "``OR``"
msgstr "``OR``"

#: ../../reference/workflows.rst:200
msgid ""
"In ``OR`` mode, all transitions with a satisfied condition are traversed "
"simultanously. Transitions not yet valid will be ignored, even if they "
"become valid later."
msgstr "在``OR``模式，带着满足的条件的所有跃迁simultanously走过。转换尚未生效将被忽略，即使他们成为有效的更新版本。"

#: ../../reference/workflows.rst:205 ../../reference/workflows.rst:226
msgid "``AND``"
msgstr "``AND``"

#: ../../reference/workflows.rst:204
msgid ""
"In ``AND`` mode, Odoo will wait until *all* transitions are satisfied, and "
"will traverse all of them (much like the ``OR`` mode)."
msgstr "在``AND``模式，Odoo将等待直到*所有*转换是满意的，并会遍历所有的人（很像``OR``模式）。"

#: ../../reference/workflows.rst:207
msgid ""
"Both ``OR`` and ``AND`` mode will lead to activities being active in the "
"same workflow."
msgstr "两个``OR``和``AND``模式将导致活动是活跃在相同的工作流程。"

#: ../../reference/workflows.rst:211
msgid "Join mode"
msgstr "加盟模式"

#: ../../reference/workflows.rst:213
msgid ""
"Just like outgoing transition conditions can be combined together to decide "
"whether they can be traversed or not, incoming transitions can be combined "
"together to decide if and when an activity may be processed."
msgstr "就像向外的转移条件可被组合在一起，以决定它们是否可以遍历或没有，进入转移可以结合在一起，以决定是否以及何时活动可被处理。"

#: ../../reference/workflows.rst:220
msgid "The ``join_mode`` attribute controls that behavior:"
msgstr "该``join_mode``属性控制的行为："

#: ../../reference/workflows.rst:223
msgid ""
"Any incoming transition enables the activity and starts its processing."
msgstr "任何传入过渡使活动，并开始其处理。"

#: ../../reference/workflows.rst:225
msgid ""
"The activity is enabled and processed only once *all* incoming transitions "
"have been traversed."
msgstr "该活动已启用，并且只处理一次* *所有进入转移已经走过。"

#: ../../reference/workflows.rst:229
msgid "Kinds"
msgstr "种"

#: ../../reference/workflows.rst:231
msgid "An activity's kind defines the type of work an activity can perform."
msgstr "一个活动的一种定义工作的一个活动可以执行的任务类型。"

#: ../../reference/workflows.rst:234
msgid "Dummy (``dummy``, default)"
msgstr "虚拟（``dummy``，默认）"

#: ../../reference/workflows.rst:234
msgid ""
"Do nothing at all, or call a server action. Often used as dispatch or gather"
" \"hubs\" for transitions."
msgstr "什么也不做，或者调用服务器动作。常被用作分派或收集\“中心\”的过渡。"

#: ../../reference/workflows.rst:236
msgid "Function (``function``)"
msgstr "功能（``function``）"

#: ../../reference/workflows.rst:237
msgid "Run some python code, execute a server action."
msgstr "运行一些Python代码，执行服务器动作。"

#: ../../reference/workflows.rst:238
msgid "Stop all (``stopall``)"
msgstr "停止所有（``stopall``）"

#: ../../reference/workflows.rst:239
msgid "Completely stops the workflow instance and marks it as completed."
msgstr "完全停止工作流实例并将其标记为已完成。"

#: ../../reference/workflows.rst:248
msgid "Subflow (``subflow``)"
msgstr "子流（``subflow``）"

#: ../../reference/workflows.rst:241
msgid ""
"Starts executing an other workflow, once that workflow is completed the "
"activity is done processing."
msgstr "开始执行的其他工作流，一旦工作流完成时进行处理的活动。"

#: ../../reference/workflows.rst:244
msgid ""
"By default, the subflow is instanciated for the same record as the parent "
"workflow. It is possible to change that behavior by providing Python code "
"that returns a record ID (of the same data model as the subflow). The "
"embedded subflow instance is then the one of the given record."
msgstr "默认情况下，子流实例化在同一记录作为父母的工作流程。它也可能通过提供Python代码返回（相同的数据模型作为子流）记录ID来改变该行为。嵌入子流实例被给定记录中的一个。"

#: ../../reference/workflows.rst:251
msgid "Transitions"
msgstr "转换"

#: ../../reference/workflows.rst:253
msgid ""
"Transitions provide the control structures to orchestrate a workflow. When "
"an activity is completed, the workflow engine tries to get across "
"transitions departing from the completed activity, towards the next "
"activities. In their simplest form (as in the example above), they link "
"activities sequentially: activities are processed as soon as the activities "
"preceding them are completed."
msgstr "转换提供控制结构来协调的工作流。当活动结束后，工作流引擎试图传达的过渡，从已完成的活动出发，朝着下一个活动。在其最简单的形式（如在上面的例子中），他们链接活动顺序：活动只要它们之前的活动完成处理。"

#: ../../reference/workflows.rst:260
msgid ""
"Instead of running all activities in one fell swoop, it is also possible to "
"wait on transitions, going through them only when some criteria are met. The"
" criteria are the conditions, the signals, and the triggers. They are "
"detailed in the following sections."
msgstr "而不是运行一举所有活动，它也有可能等待过渡，经过他们只有在满足某些条件​​。标准的条件是，信号，和所述触发器。它们在以下部分中详细说明。"

#: ../../reference/workflows.rst:266
msgid "Conditions"
msgstr "条件"

#: ../../reference/workflows.rst:268
msgid ""
"When an activity has been completed, its outgoing transitions are inspected "
"to determine whether it is possible for the workflow instance to proceed "
"through them and reach the next activities. When only a condition is defined"
" (i.e., no signal or trigger is defined), the condition is evaluated by "
"Odoo, and if it evaluates to ``True``, the worklfow instance progresses "
"through the transition.  If the condition is not met, it will be reevaluated"
" every time the associated record is modified, or by an explicit method call"
" to do it."
msgstr "当一个活动已完成，其输出转换被检验，以确定它是否是可能的工作流实例以继续通过它们和到达下一个活动。当只有一个条件被定义（即没有信号或触发定义），条件是由Odoo计算，如果计算结果为``True``，那么通过过渡worklfow实例进展。如果条件不被满足，它会在每个相关的记录被修改的时间重新评估，或通过显式方法调用做。"

#: ../../reference/workflows.rst:276
msgid ""
"By default, the attribute ``condition`` (i.e., the expression to be "
"evaluated) is just \"True\", which trivially evaluates to ``True``. Note "
"that the condition may be several lines long; in that case, the value of the"
" last one determines whether the transition can be taken."
msgstr "默认情况下，该属性``condition``（即要计算的表达式）只是\“真正的\”，这平凡的计算结果为值为``True``。注意，条件可以是几行长;在那种情况下，最后一个的值确定过渡是否可以采取。"

#: ../../reference/workflows.rst:281
msgid ""
"In the condition evaluation environment, several symbols are conveniently "
"defined (in addition to the Odoo ``safe_eval`` environment):"
msgstr "在条件评估环境，几个符号便利定义（除了Odoo``safe_eval``环境）："

#: ../../reference/workflows.rst:284
msgid "all the model column names, and"
msgstr "所有型号的列名，和"

#: ../../reference/workflows.rst:285
msgid "all the browse record's attributes."
msgstr "浏览记录的所有属性。"

#: ../../reference/workflows.rst:290
msgid "Signals"
msgstr "信号"

#: ../../reference/workflows.rst:292
msgid ""
"In addition to a condition, a transition can specify a signal name. When "
"such a signal name is present, the transition is not taken directly, even if"
" the condition evaluates to ``True``. Instead the transition blocks, waiting"
" to be woken up."
msgstr "除了一个条件，过渡可以指定信号名称。当这种信号的名字出现，过渡不采取直接，即使条件为值为``True``。取而代之的是过渡块，等待被唤醒。"

#: ../../reference/workflows.rst:297
msgid ""
"In order to wake up a transition with a defined signal name, the signal must"
" be sent to the workflow instance. A common way to send a signal is to use a"
" button in the user interface, using the element ``<button/>`` with the "
"signal name as the attribute ``name`` of the button. Once the button is "
"clicked, the signal is sent to the workflow instance of the current record."
msgstr "为了唤醒具有限定信号名称的过渡时，信号必须被发送到工作流实例。发送信号的一般方法是在用户界面中使用的一个按钮，利用所述元素``<钮/>``与作为按钮的属性``name``的信号名称。一旦按钮被点击时，信号被发送到当前记录的工作流实例。"

#: ../../reference/workflows.rst:303
msgid ""
"The condition is still evaluated when the signal is sent to the workflow "
"instance."
msgstr "当该信号被发送到工作流实例中的条件仍然是评价。"

#: ../../reference/workflows.rst:307
msgid "Triggers"
msgstr "触发器"

#: ../../reference/workflows.rst:309
msgid ""
"With conditions that evaluate to ``False``, transitions are not taken (and "
"thus the activity it leads to is not processed immediately). Still, the "
"workflow instance can get new chances to progress across that transition by "
"providing so-called triggers. The idea is that when the condition is not "
"satisfied, triggers are recorded in database. Later, it is possible to wake "
"up specifically the workflow instances that installed those triggers, "
"offering them to reevaluate their transition conditions. This mechanism "
"makes it cheaper to wake up workflow instances by targetting just a few of "
"them (those that have installed the triggers) instead of all of them."
msgstr "与评价条件``False``，过渡不采取（以及因此的活动它导致不立即处理）。不过，工作流实例可以得到新的机会，通过提供所谓的触发器跨越这种转变的进展。这个想法是，当条件不成立时，触发器被记录在数据库中。后来，有可能唤醒特别是安装这些触发器，为他们提供重新评估他们的转移条件的工作流实例。这种机制使得它更便宜的通过目标定位只是一小部分，而不是全部的人（那些已经安装了触发器）醒来的工作流实例。"

#: ../../reference/workflows.rst:319
msgid ""
"Triggers are recorded in database as record IDs (together with the model "
"name) and refer to the workflow instance waiting for those records. The "
"transition definition provides a model name (attribute ``trigger_model``) "
"and a Python expression (attribute ``trigger_expression``) that evaluates to"
" a list of record IDs in the given model. Any of those records can wake up "
"the workflow instance they are associated with."
msgstr "触发器都记录在数据库中记录的ID（连同型号名称），指的是工作流实例等待这些记录。过渡定义提供计算结果为给定的模型中记录ID列表的型号名称（属性``trigger_model``）和Python表达式（属性``trigger_expression``）。任何的这些记录可以唤醒它们与相关联的工作流实例。"

#: ../../reference/workflows.rst:326
msgid "triggers are not re-installed whenever the transition is re-tried."
msgstr "触发器没有被重新安装时的过渡重新尝试。"

