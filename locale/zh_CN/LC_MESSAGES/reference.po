# SOME DESCRIPTIVE TITLE.
# Copyright (C) Odoo S.A.
# This file is distributed under the same license as the odoo package.
#
# Translators:
# Jeffery Chenn <jeffery9@gmail.com>, 2015
# Jeffery Chenn <jeffery9@gmail.com>, 2015-2016
# Uming Peng <umingpeng@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: odoo documentation technical\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-30 19:35+0800\n"
"PO-Revision-Date: 2016-05-31 15:06+0800\n"
"Last-Translator: Jeffery Chenn <jeffery9@gmail.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/odoo-cn/odoo-documentation-technical/language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"
"X-Generator: Poedit 1.8.6\n"

#: ../../reference.rst:3
msgid "Reference"
msgstr "参考"

#: ../../reference/actions.rst:7
msgid "Actions"
msgstr "动作"

#: ../../reference/actions.rst:9
msgid "Actions define the behavior of the system in response to user actions: login, action button, selection of an invoice, ..."
msgstr "动作定义系统在响应用户动作的行为:登录, 动作按钮, 发票的选项, ..."

#: ../../reference/actions.rst:12
msgid "Actions can be stored in the database or returned directly as dictionaries in e.g. button methods. All actions share two mandatory attributes:"
msgstr "动作可以保存在数据库, 或者作为字典直接返回, 例如, 按钮方法。所有的动作共享2个强制的属性:"

#: ../../reference/actions.rst:16 ../../reference/actions.rst:273 ../../reference/data.rst:116 ../../reference/views.rst:215 ../../reference/views.rst:753 ../../reference/views.rst:777 ../../reference/views.rst:1031
msgid "``type``"
msgstr " ``type`` "

#: ../../reference/actions.rst:16
msgid "the category of the current action, determines which fields may be used and how the action is interpreted"
msgstr "当前动作的类别, 确定哪些字段可以被使用, 以及动作如何被解释"

#: ../../reference/actions.rst:20 ../../reference/views.rst:217 ../../reference/views.rst:250 ../../reference/views.rst:1125 ../../reference/views.rst:1185
msgid "``name``"
msgstr " ``name`` "

#: ../../reference/actions.rst:19
msgid "short user-readable description of the action, may be displayed in the client's interface"
msgstr "简短的用户可读的动作说明, 可以显示在客户端界面"

#: ../../reference/actions.rst:22
msgid "A client can get actions in 4 forms:"
msgstr "客户端有4种形式可以取得动作:"

#: ../../reference/actions.rst:24
msgid "``False``"
msgstr " ``False`` "

#: ../../reference/actions.rst:25
msgid "if any action dialog is currently open, close it"
msgstr "如果任何操作对话框当前处于打开状态, 请将其关闭"

#: ../../reference/actions.rst:27
msgid "A string"
msgstr "字符串"

#: ../../reference/actions.rst:27
msgid "if a :ref:`client action <reference/actions/client>` matches, interpret as a client action's tag, otherwise treat as a number"
msgstr "如果 :ref:`客户端动作 <reference/actions/client>` 比赛中, 解释为一个客户端操作的标记, 否则视为一个数字"

#: ../../reference/actions.rst:30
msgid "A number"
msgstr "数字"

#: ../../reference/actions.rst:30
msgid "read the corresponding action record from the database, may be a database identifier or an :term:`external id`"
msgstr "从数据库中读取相应的操作记录, 可以是数据库标识符或一个 :term:`external id` "

#: ../../reference/actions.rst:33
msgid "A dictionary"
msgstr "字典"

#: ../../reference/actions.rst:33
msgid "treat as a client action descriptor and execute"
msgstr "视为客户端动作描述符和执行"

#: ../../reference/actions.rst:38
msgid "Window Actions (``ir.actions.act_window``)"
msgstr "窗口动作 ( ``ir.actions.act_window`` )"

#: ../../reference/actions.rst:40
msgid "The most common action type, used to present visualisations of a model through :ref:`views <reference/views>`: a window action defines a set of view types (and possibly specific views) for a model (and possibly specific record of the model)."
msgstr "最常见的动作类型, 用于通过提出一个模型的可视化 :ref:`视图 <reference/views>` :一个窗口的动作定义一组视图类型（以及可能的具体意见）为模型（和可能的特殊纪录该模型）。"

#: ../../reference/actions.rst:45
msgid "Its fields are:"
msgstr "它的字段有:"

#: ../../reference/actions.rst:47
msgid "``res_model``"
msgstr " ``res_model`` "

#: ../../reference/actions.rst:48
msgid "model to present views for"
msgstr "模型提出的意见进行"

#: ../../reference/actions.rst:56
msgid "``views``"
msgstr " ``views`` "

#: ../../reference/actions.rst:50
msgid ""
"a list of ``(view_id, view_type)`` pairs. The second element of each pair is the category of the view (tree, form, graph, ...) and the first is an optional database id (or ``False``). If no id is provided, the client should fetch the default view of the specified type for the requested model (this is automatically done by :meth:`~openerp.models.Model.fields_view_get`). The first type of the list is the default view type and will be open by default when the action is executed. Each view type should be "
"present at most once in the list"
msgstr "中 ``（view_id来, view_type来）`` 对的列表。每对的第二个元素是视图（树, 表格, 图表, ...）的范畴, 首先是一个可选的数据库ID（或 ``False`` ）。如果没有ID提供, 客户应取指定类型的请求模型的默认视图（这是自动完成的 :meth:`~openerp.models.Model.fields_view_get` ）。列表的第一种类型是默认视图类型并且在执行动作时将开放默认。每个视图类型应该是目前最多一次在列表"

#: ../../reference/actions.rst:59
msgid "``res_id`` (optional)"
msgstr " ``res_id`` (可选)"

#: ../../reference/actions.rst:59
msgid "if the default view is ``form``, specifies the record to load (otherwise a new record should be created)"
msgstr "如果默认视图是 ``form`` , 指定记录加载（否则应该创建一个新的记录）"

#: ../../reference/actions.rst:63
msgid "``search_view_id`` (optional)"
msgstr " ``search_view_id`` (可选)"

#: ../../reference/actions.rst:62
msgid "``(id, name)`` pair, ``id`` is the database identifier of a specific search view to load for the action. Defaults to fetching the default search view for the model"
msgstr " ``(id, name)`` 对, ``id`` 是一个特定的搜索视图的数据库标识符加载的行动。默认为获取默认的搜索视图模型"

#: ../../reference/actions.rst:66
msgid "``target`` (optional)"
msgstr " ``target`` (可选)"

#: ../../reference/actions.rst:66
msgid "whether the views should be open in the main content area (``current``) or in a dialog/popup (``new``). Defaults to ``current``."
msgstr "该意见是否应在主要内容区开放（ ``current`` ）, 或在一个对话框/弹出（ ``new`` ）。默认为 ``current`` 。"

#: ../../reference/actions.rst:68 ../../reference/actions.rst:178
msgid "``context`` (optional)"
msgstr " ``context`` (可选)"

#: ../../reference/actions.rst:69
msgid "additional context data to pass to the views"
msgstr "附加的上下文数据要传递到此视图"

#: ../../reference/actions.rst:70
msgid "``domain`` (optional)"
msgstr " ``domain`` (可选)"

#: ../../reference/actions.rst:71
msgid "filtering domain to implicitly add to all view search queries"
msgstr "过滤域隐式添加到所有视图搜索查询"

#: ../../reference/actions.rst:73
msgid "``limit`` (optional)"
msgstr " ``limit`` (可选)"

#: ../../reference/actions.rst:73
msgid "number of records to display in lists by default. Defaults to 80 in the web client"
msgstr "记录数为默认的列表中显示。默认为8​​0, 在Web客户端"

#: ../../reference/actions.rst:77
msgid "``auto_search`` (optional)"
msgstr " ``auto_search`` (可选)"

#: ../../reference/actions.rst:76
msgid "whether a search should be performed immediately after loading the default view. Defaults to ``True``"
msgstr "是否搜索应加载默认视图后立即进行。默认为值为 ``True`` "

#: ../../reference/actions.rst:79
msgid "For instance, to open customers (partner with the ``customer`` flag set) with list and form views::"
msgstr "例如, 打开客户（合作伙伴的 ``customer`` 标志集）与名单, 并形成视图 ::"

#: ../../reference/actions.rst:89
msgid "Or to open the form view of a specific product (obtained separately) in a new dialog::"
msgstr "或者打开一个特定的产品在一个新的对话框表单视图（单独获得） ::"

#: ../../reference/actions.rst:100
msgid "In-database window actions have a few different fields which should be ignored by clients, mostly to use in composing the ``views`` list:"
msgstr "在数据库窗口中的操作有一些不同的字段应该由客户端被忽略, 大多在构成 ``views`` 列表中使用:"

#: ../../reference/actions.rst:104
msgid "``view_mode``"
msgstr " ``view_mode`` "

#: ../../reference/actions.rst:104
msgid "comma-separated list of view types as a string. All of these types will be present in the generated ``views`` list (with at least a ``False`` view_id)"
msgstr "逗号分隔的视图类型列表作为字符串。所有这些类型的将存在于生成的 ``views`` 列表（与至少一个 ``False`` 的view_id）"

#: ../../reference/actions.rst:107
msgid "``view_ids``"
msgstr " ``view_ids`` "

#: ../../reference/actions.rst:107
msgid "M2M\\ [#notquitem2m]_ to view objects, defines the initial content of ``views``"
msgstr "M2M \\ [＃notquitem2m] _查看对象, 定义了 ``views`` 的初始内容"

#: ../../reference/actions.rst:112
msgid "``view_id``"
msgstr " ``view_id`` "

#: ../../reference/actions.rst:110
msgid "specific view added to the ``views`` list in case its type is part of the ``view_mode`` list and not already filled by one of the views in ``view_ids``"
msgstr "具体的视图加入到 ``views`` 列表中的情况下, 它的类型是 ``view_mode`` 名单的一部分, 并且尚未填补的 ``view_ids`` 一个视图"

#: ../../reference/actions.rst:114
msgid "These are mostly used when defining actions from :ref:`reference/data`:"
msgstr ":ref:`reference/data` 这些定义, 从行为时, 大多使用:"

#: ../../reference/actions.rst:125
msgid "will use the \"my_specific_view\" view even if that's not the default view for the model."
msgstr "将使用'my_specific_view'的视图, 即使这不是该型号的默认视图。"

#: ../../reference/actions.rst:128
msgid "The server-side composition of the ``views`` sequence is the following:"
msgstr "在 ``views`` 序列的服务器端组成如下:"

#: ../../reference/actions.rst:130
msgid "get each ``(id, type)`` from ``view_ids`` (ordered by ``sequence``)"
msgstr "获得每个 ``（ID, 类型）`` 的 ``view_ids`` （订购 ``sequence`` ）"

#: ../../reference/actions.rst:131
msgid "if ``view_id`` is defined and its type isn't already filled, append its ``(id, type)``"
msgstr "如果 ``view_id`` 的定义, 其类型是不是已经填满, 追加了 ``（ID, 类型）`` "

#: ../../reference/actions.rst:133
msgid "for each unfilled type in ``view_mode``, append ``(False, type)``"
msgstr "每个填充类型 ``view_mode`` , 追加 ``（假, 类型）`` "

#: ../../reference/actions.rst:146
msgid "URL Actions (``ir.actions.act_url``)"
msgstr "URL 动作( ``ir.actions.act_url`` )"

#: ../../reference/actions.rst:148
msgid "Allow opening a URL (website/web page) via an Odoo action. Can be customized via two fields:"
msgstr "允许通过Odoo操作打开URL（网站/网页）。可以通过两个字段定制:"

#: ../../reference/actions.rst:151
msgid "``url``"
msgstr " ``url`` "

#: ../../reference/actions.rst:152
msgid "the address to open when activating the action"
msgstr "地址来激活操作时打开"

#: ../../reference/actions.rst:155 ../../reference/upgrade_api.rst:411
msgid "``target``"
msgstr " ``target`` "

#: ../../reference/actions.rst:154
msgid "opens the address in a new window/page if ``new``, replaces the current content with the page if ``self``. Defaults to ``new``"
msgstr "打开该地址在新窗口/网页, 如果 ``new`` , 替换当前内容的页面, 如果 ``self`` 。默认为 ``new`` "

#: ../../reference/actions.rst:165
msgid "will replace the current content section by the Odoo home page."
msgstr "将取代由Odoo主页当前的内容部分。"

#: ../../reference/actions.rst:170
msgid "Server Actions (``ir.actions.server``)"
msgstr "服务器动作 ( ``ir.actions.server`` )"

#: ../../reference/actions.rst:172
msgid "Allow triggering complex server code from any valid action location. Only two fields are relevant to clients:"
msgstr "允许从任何有效的行动定位触发复杂的服务器代码。只有两个字段相关的客户:"

#: ../../reference/actions.rst:175 ../../reference/data.rst:51 ../../reference/data.rst:136 ../../reference/data.rst:200 ../../reference/data.rst:210 ../../reference/reports.rst:34 ../../reference/upgrade_api.rst:405
msgid "``id``"
msgstr " ``id`` "

#: ../../reference/actions.rst:176
msgid "the in-database identifier of the server action to run"
msgstr "在数据库内标识的服务器操作的运行"

#: ../../reference/actions.rst:178
msgid "context data to use when running the server action"
msgstr "运行服务器操作时的上下文数据使用"

#: ../../reference/actions.rst:180
msgid "In-database records are significantly richer and can perform a number of specific or generic actions based on their ``state``. Some fields (and corresponding behaviors) are shared between states:"
msgstr "数据库内记录显著更丰富, 可以执行许多基于它们 ``state`` 特定或通用行动。某些字段（以及相应的行为）的国家之间共享:"

#: ../../reference/actions.rst:185
msgid "``model_id``"
msgstr " ``model_id`` "

#: ../../reference/actions.rst:185
msgid "Odoo model linked to the action, made available in :ref:`evaluation contexts <reference/actions/server/context>`"
msgstr "裁判:挂动作Odoo模式, 提供 `评价上下文<reference/actions/server/context>` "

#: ../../reference/actions.rst:190
msgid "``condition`` (optional)"
msgstr " ``condition`` (可选)"

#: ../../reference/actions.rst:188
msgid "evaluated as Python code using the server action's :ref:`evaluation context <reference/actions/server/context>`. If ``False``, prevents the action from running. Default: ``True``"
msgstr "评价使用服务器操作的Python代码 :ref:`评价方面<reference/actions/server/context>` 。如果 ``False`` , 阻止操作运行。默认值:值为 ``True`` "

#: ../../reference/actions.rst:192
msgid "Valid action types (``state`` field) are extensible, the default types are:"
msgstr "有效的动作类型 ( ``state`` field) 是可扩展的, 默认类型 :"

#: ../../reference/actions.rst:195 ../../reference/actions.rst:203
msgid "``code``"
msgstr " ``code`` "

#: ../../reference/actions.rst:197
msgid "The default and most flexible server action type, executes arbitrary Python code with the action's :ref:`evaluation context <reference/actions/server/context>`. Only uses one specific type-specific field:"
msgstr "默认的和最灵活的服务器动作类型, 执行任意的Python代码与操作的 :ref:`评价方面<reference/actions/server/context>` 。只使用一个特定的类型特定字段:"

#: ../../reference/actions.rst:203
msgid "a piece of Python code to execute when the action is called"
msgstr "一段Python代码执行时的动作被称为"

#: ../../reference/actions.rst:217
msgid "The code segment can define a variable called ``action``, which will be returned to the client as the next action to execute:"
msgstr "代码段可以定义一个称为 ``action`` 变量, 这将被返回给客户机的下一个操作执行:"

#: ../../reference/actions.rst:236
msgid "will ask the client to open a form for the record if it fulfills some condition"
msgstr ""

#: ../../reference/actions.rst:239
msgid "This tends to be the only action type created from :ref:`data files <reference/data>`, other types aside from :ref:`reference/actions/server/multi` are simpler than Python code to define from the UI, but not from :ref:`data files <reference/data>`."
msgstr "这往往是从创建的唯一动作类型 :ref:`数据文件<reference/data>` , 其他类型的除了 :ref:`参考/动作/服务器/ multi` 比Python代码简单的从UI定义, 但不能从 :ref:`数据文件<reference/data>` 。"

#: ../../reference/actions.rst:247
msgid "``object_create``"
msgstr " ``object_create`` "

#: ../../reference/actions.rst:249
msgid "Creates a new record, from scratch (via :meth:`~openerp.models.Model.create`) or by copying an existing record (via :meth:`~openerp.models.Model.copy`)"
msgstr "创建一个新的记录, 从头开始（通过 :meth:`~openerp.models.Model.create` ）, 或者通过复制现有的记录（通过 :meth:`~openerp.models.Model.copy` ）"

#: ../../reference/actions.rst:261
msgid "``use_create``"
msgstr " ``use_create`` "

#: ../../reference/actions.rst:253
msgid "the creation policy, one of:"
msgstr "创建策略之一 :"

#: ../../reference/actions.rst:255
msgid "``new``"
msgstr " ``new`` "

#: ../../reference/actions.rst:256
msgid "creates a record in the model specified by ``model_id``"
msgstr "通过 ``model_id`` 指定的模型创建了创纪录"

#: ../../reference/actions.rst:257
msgid "``new_other``"
msgstr " ``new_other`` "

#: ../../reference/actions.rst:258
msgid "creates a record in the model specified by ``crud_model_id``"
msgstr "在模型创建一个由 ``crud_model_id`` 指定的记录"

#: ../../reference/actions.rst:259
msgid "``copy_current``"
msgstr " ``copy_current`` "

#: ../../reference/actions.rst:260
msgid "copies the record on which the action was invoked"
msgstr "副本在其上调用操作记录"

#: ../../reference/actions.rst:261
msgid "``copy_other``"
msgstr " ``copy_other`` "

#: ../../reference/actions.rst:262
msgid "copies an other record, obtained via ``ref_object``"
msgstr "其他记录的副本, 通过 ``ref_object`` 获得"

#: ../../reference/actions.rst:273 ../../reference/actions.rst:309
msgid "``fields_lines``"
msgstr " ``fields_lines`` "

#: ../../reference/actions.rst:264
msgid "fields to override when creating or copying the record. :class:`~openerp.fields.One2many` with the fields:"
msgstr "字段来创建或复制记录时覆盖。 :class:`~openerp.fields.One2many` 的字段:"

#: ../../reference/actions.rst:267
msgid "``col1``"
msgstr " ``col1`` "

#: ../../reference/actions.rst:268
msgid "``ir.model.fields`` to set in the model implied by ``use_create``"
msgstr " ``ir.model.fields`` 在由 ``use_create`` 所隐含的模式设置"

#: ../../reference/actions.rst:269 ../../reference/javascript.rst:648 ../../reference/orm.rst:1001
msgid "``value``"
msgstr " ``value`` "

#: ../../reference/actions.rst:270
msgid "value for the field, interpreted via ``type``"
msgstr "字段的值, 通过 ``type`` 解释"

#: ../../reference/actions.rst:272
msgid "If ``value``, the ``value`` field is interpreted as a literal value (possibly converted), if ``equation`` the ``value`` field is interpreted as a Python expression and evaluated"
msgstr "如果 ``value`` 的 ``value`` 场被解释为一个文本值（可能是转换）, 如果 ``equation`` 的 ``value`` 字段被解释为一个Python表达式和评估"

#: ../../reference/actions.rst:276 ../../reference/actions.rst:311
msgid "``crud_model_id``"
msgstr " ``crud_model_id`` "

#: ../../reference/actions.rst:276
msgid "model in which to create a new record, if ``use_create`` is set to ``new_other``"
msgstr "模式, 即创建一个新的记录, 如果 ``use_create`` 设置为 ``new_other`` "

#: ../../reference/actions.rst:279 ../../reference/actions.rst:314
msgid "``ref_object``"
msgstr " ``ref_object`` "

#: ../../reference/actions.rst:279
msgid ":class:`~openerp.fields.Reference` to an arbitrary record to copy, used if ``use_create`` is set to ``copy_other``"
msgstr ":class:`~openerp.fields.Reference` 到任意的记录复制, 使用, 如果 ``use_create`` 设置为 ``copy_other`` "

#: ../../reference/actions.rst:282
msgid "``link_new_record``"
msgstr " ``link_new_record`` "

#: ../../reference/actions.rst:282
msgid "boolean flag linking the newly created record to the current one via a many2one field specified through ``link_field_id``, defaults to ``False``"
msgstr "布尔标志通过通 ``link_field_id`` 指定many2one场连接新创建的记录当前的, 默认为 ``False`` "

#: ../../reference/actions.rst:286
msgid "``link_field_id``"
msgstr " ``link_field_id`` "

#: ../../reference/actions.rst:285
msgid "many2one to ``ir.model.fields``, specifies the current record's m2o field on which the newly created record should be set (models should match)"
msgstr "many2one到 ``ir.model.fields`` , 指明该新创建的记录应设置（型号应匹配）当前记录的M2O字段"

#: ../../reference/actions.rst:289
msgid "``object_write``"
msgstr " ``object_write`` "

#: ../../reference/actions.rst:291
msgid "Similar to :ref:`reference/actions/server/object_create` but alters an existing records instead of creating one"
msgstr "类似的 :ref:`reference/actions/server/object_create` 但会改变现有的记录, 而不是创建1"

#: ../../reference/actions.rst:303
msgid "``use_write``"
msgstr " ``use_write`` "

#: ../../reference/actions.rst:295
msgid "write policy, one of:"
msgstr "写入策略, 之一 :"

#: ../../reference/actions.rst:297
msgid "``current``"
msgstr " ``current`` "

#: ../../reference/actions.rst:298
msgid "write to the current record"
msgstr "写入当前记录"

#: ../../reference/actions.rst:300
msgid "``other``"
msgstr " ``other`` "

#: ../../reference/actions.rst:300
msgid "write to an other record selected via ``crud_model_id`` and ``ref_object``"
msgstr "写经选择的其他记录 ``crud_model_id`` 和 ``ref_object`` "

#: ../../reference/actions.rst:303
msgid "``expression``"
msgstr " ``expression`` "

#: ../../reference/actions.rst:303
msgid "write to an other record whose model is selected via ``crud_model_id`` and whose id is selected by evaluating ``write_expression``"
msgstr "将数据写入到其他记录, 其模型通过 ``crud_model_id`` 被选中, 其ID被选中评价 ``write_expression`` "

#: ../../reference/actions.rst:307
msgid "``write_expression``"
msgstr " ``write_expression`` "

#: ../../reference/actions.rst:306
msgid "Python expression returning a record or an object id, used when ``use_write`` is set to ``expression`` in order to decide which record should be modified"
msgstr "Python表达式返回记录或对象ID, 以便决定使用时 ``use_write`` 设置为 ``expression`` 该记录应修改"

#: ../../reference/actions.rst:310 ../../reference/actions.rst:312 ../../reference/actions.rst:314
msgid "see :ref:`reference/actions/server/object_create`"
msgstr "请参阅 :ref:`reference/actions/server/object_create` "

#: ../../reference/actions.rst:319
msgid "``multi``"
msgstr " ``multi`` "

#: ../../reference/actions.rst:321
msgid "Executes multiple actions one after the other. Actions to execute are defined via the ``child_ids`` m2m. If sub-actions themselves return actions, the last one will be returned to the client as the multi's own next action"
msgstr "执行多个动作一个接一个。操作执行是通过 ``child_ids`` M2M定义。如果子动作本身返回的动作, 最后一个将被返回给客户端作为多自己下一个动作"

#: ../../reference/actions.rst:326
msgid "``trigger``"
msgstr " ``trigger`` "

#: ../../reference/actions.rst:328
msgid "Sends a signal to a workflow."
msgstr "将信号发送到一个工作流程。"

#: ../../reference/actions.rst:330
msgid "``wkf_transition_id``"
msgstr " ``wkf_transition_id`` "

#: ../../reference/actions.rst:331
msgid ":class:`~openerp.fields.Many2one` to a ``workflow.transition`` to trigger"
msgstr ":class:`~openerp.fields.Many2one` 到 ``workflow.transition`` 触发"

#: ../../reference/actions.rst:335
msgid "``use_relational_model``"
msgstr " ``use_relational_model`` "

#: ../../reference/actions.rst:333
msgid "if ``base`` (the default), trigger the signal on behalf of the current record. If ``relational``, trigger the signal on behalf of a field of the current record selected through ``wkf_model_id`` and ``wkf_field_id``"
msgstr "如果 ``base`` （默认值）, 触发代表当前记录的信号。如果 ``relational`` , 触发信号代表当前记录, 通过 ``wkf_model_id`` 和 ``wkf_field_id`` 选择一个字段"

#: ../../reference/actions.rst:338
msgid "``client_action``"
msgstr " ``client_action`` "

#: ../../reference/actions.rst:340
msgid "Indirection for directly returning an other action defined using ``action_id``. Simply returns that action to the client for execution."
msgstr "使用 ``action_id`` 间接直接返回一个其他操作规定。简单地返回该操作的客户端执行。"

#: ../../reference/actions.rst:346
msgid "Evaluation context"
msgstr "评估上下文"

#: ../../reference/actions.rst:348
msgid "A number of keys are available in the evaluation context of or surrounding server actions:"
msgstr "有多个键的或周围服务器操作的评估上下文中可用​​:"

#: ../../reference/actions.rst:351
msgid "``self``"
msgstr " ``self`` "

#: ../../reference/actions.rst:352
msgid "the model object linked to the action via ``model_id``"
msgstr "通过 ``model_id`` 链接到操作模型对象"

#: ../../reference/actions.rst:354
msgid "``object``, ``obj``"
msgstr " ``object`` , ``obj`` "

#: ../../reference/actions.rst:354
msgid "only available if ``active_model`` and ``active_id`` are provided (via context) otherwise ``None``. The actual record selected by ``active_id``"
msgstr "只有提供 ``active_model`` 和 ``active_id`` 可以（通过上下文）, 否则 ``None`` 。通过 ``active_id`` 选择的实际记录"

#: ../../reference/actions.rst:356
msgid "``pool``"
msgstr " ``pool`` "

#: ../../reference/actions.rst:357
msgid "the current database registry"
msgstr "当前数据库注册表"

#: ../../reference/actions.rst:358
msgid "``datetime``, ``dateutil``, ``time``"
msgstr " ``datetime`` , ``dateutil`` , ``time`` "

#: ../../reference/actions.rst:359
msgid "corresponding Python modules"
msgstr "相应的Python模块"

#: ../../reference/actions.rst:360
msgid "``cr``"
msgstr " ``cr`` "

#: ../../reference/actions.rst:361
msgid "the current cursor"
msgstr "当前光标"

#: ../../reference/actions.rst:362 ../../reference/reports.rst:115
msgid "``user``"
msgstr " ``user`` "

#: ../../reference/actions.rst:363
msgid "the current user record"
msgstr "当前用户记录"

#: ../../reference/actions.rst:364 ../../reference/data.rst:53 ../../reference/views.rst:237 ../../reference/views.rst:400 ../../reference/views.rst:1154 ../../reference/views.rst:1181
msgid "``context``"
msgstr " ``context`` "

#: ../../reference/actions.rst:365
msgid "execution context"
msgstr "执行上下文"

#: ../../reference/actions.rst:367
msgid "``Warning``"
msgstr " ``Warning`` "

#: ../../reference/actions.rst:367
msgid "constructor for the ``Warning`` exception"
msgstr "构造函数 ``Warning`` 异常"

#: ../../reference/actions.rst:375
msgid "Report Actions (``ir.actions.report.xml``)"
msgstr "报表动作( ``ir.actions.report.xml`` )"

#: ../../reference/actions.rst:377
msgid "Triggers the printing of a report"
msgstr "触发报表的打印"

#: ../../reference/actions.rst:380 ../../reference/reports.rst:37 ../../reference/reports.rst:236 ../../reference/views.rst:19 ../../reference/views.rst:355
msgid "``name`` (mandatory)"
msgstr " ``name`` (必须)"

#: ../../reference/actions.rst:380 ../../reference/reports.rst:37 ../../reference/reports.rst:236
msgid "only useful as a mnemonic/description of the report when looking for one in a list of some sort"
msgstr "只有在某种类型的列表作为报告的记忆/描述有用找一当"

#: ../../reference/actions.rst:382 ../../reference/reports.rst:39
msgid "``model`` (mandatory)"
msgstr " ``model`` (必须)"

#: ../../reference/actions.rst:383 ../../reference/reports.rst:40
msgid "the model your report will be about"
msgstr "你的报告要报告的模型"

#: ../../reference/actions.rst:384 ../../reference/reports.rst:41
msgid "``report_type`` (mandatory)"
msgstr " ``report_type`` (强制的)"

#: ../../reference/actions.rst:385 ../../reference/reports.rst:42
msgid "either ``qweb-pdf`` for PDF reports or ``qweb-html`` for HTML"
msgstr "无论是 ``qweb-pdf`` 的PDF报告或 ``qweb-html`` 为HTML"

#: ../../reference/actions.rst:386 ../../reference/reports.rst:43
msgid "``report_name``"
msgstr " ``report_name`` "

#: ../../reference/actions.rst:387 ../../reference/reports.rst:44
msgid "the name of your report (which will be the name of the PDF output)"
msgstr "报告的名称（这将是PDF输出的名称）"

#: ../../reference/actions.rst:389 ../../reference/views.rst:34
msgid "``groups_id``"
msgstr " ``groups_id`` "

#: ../../reference/actions.rst:389 ../../reference/reports.rst:46
msgid ":class:`~openerp.fields.Many2many` field to the groups allowed to view/use the current report"
msgstr ":class:`~openerp.fields.Many2many` 字段允许查看组/使用当前的报告"

#: ../../reference/actions.rst:392
msgid "``paperformat_id``"
msgstr " ``paperformat_id`` "

#: ../../reference/actions.rst:392
msgid ":class:`~openerp.fields.Many2one` field to the paper format you wish to use for this report (if not specified, the company format will be used)"
msgstr ":class:`~openerp.fields.Many2one` 场要使用此报告（如果不指定, 该公司的格式将被使用）的文件格式"

#: ../../reference/actions.rst:399 ../../reference/reports.rst:51
msgid "``attachment_use``"
msgstr " ``attachment_use`` "

#: ../../reference/actions.rst:395
msgid "if set to ``True``, the report is only generated once the first time it is requested, and re-printed from the stored report afterwards instead of being re-generated every time."
msgstr "如果设置为 ``True`` , 那么该报告只产生一次, 第一次被请求, 并重新打印从存储的报告之后, 而不是被重新生成的每个时间。"

#: ../../reference/actions.rst:399
msgid "Can be used for reports which must only be generated once (e.g. for legal reasons)"
msgstr "可用于必须只能使用一次生成的报告（例如出于法律原因）"

#: ../../reference/actions.rst:403 ../../reference/reports.rst:54
msgid "``attachment``"
msgstr " ``attachment`` "

#: ../../reference/actions.rst:402
msgid "python expression that defines the name of the report; the record is accessible as the variable ``object``"
msgstr "定义报表的名称Python表达;该记录是可以访问的变量 ``object`` "

#: ../../reference/actions.rst:408
msgid "Client Actions (``ir.actions.client``)"
msgstr "客户端动作 ( ``ir.actions.client`` )"

#: ../../reference/actions.rst:410
msgid "Triggers an action implemented entirely in the client."
msgstr "触发完全在客户机中实现的操作。"

#: ../../reference/actions.rst:413
msgid "``tag``"
msgstr " ``tag`` "

#: ../../reference/actions.rst:413
msgid "the client-side identifier of the action, an arbitrary string which the client should know how to react to"
msgstr "动作的客户端标识符, 一个任意字符串客户机应该知道如何作出反应, 以"

#: ../../reference/actions.rst:417
msgid "``params`` (optional)"
msgstr " ``params`` （可选）"

#: ../../reference/actions.rst:416
msgid "a Python dictionary of additional data to send to the client, alongside the client action tag"
msgstr "附加数据一个Python字典来发送给客户端, 旁边的客户端动作标签"

#: ../../reference/actions.rst:426
msgid "tells the client to start the Point of Sale interface, the server has no idea how the POS interface works."
msgstr "通知客户端开始销售界面的角度来看, 服务器有不知道如何在POS接口工作。"

#: ../../reference/actions.rst:429
msgid "technically not an M2M: adds a sequence field and may be composed of just a view type, without a view id."
msgstr "技术上没有一个M2M:增加了一个序列字段可以由只是一个视图类型的, 没有一个视图id。"

#: ../../reference/async.rst:6
msgid "Asynchronous Operations"
msgstr "异步操作"

#: ../../reference/async.rst:8
msgid "As a language (and runtime), javascript is fundamentally single-threaded. This means any blocking request or computation will block the whole page (and, in older browsers, the software itself even preventing users from switching to another tab): a javascript environment can be seen as an event-based runloop where application developers have no control over the runloop itself."
msgstr "作为一门语言（和运行时）, JavaScript是从根本上单线程的。这意味着任何阻拦的请求或计算将阻止整个页面（和, 在旧的浏览器, 软件本身甚至阻止用户切换到另一个选项卡）:一个JavaScript环境可以看作是基于事件的runloop, 其中应用程序开发人员没有控制在runloop本身。"

#: ../../reference/async.rst:15
msgid "As a result, performing long-running synchronous network requests or other types of complex and expensive accesses is frowned upon and asynchronous APIs are used instead."
msgstr "其结果是, 在执行长期运行的同步网络请求或其他类型的复杂且昂贵的访问是令人难以接受的和异步API用于代替。"

#: ../../reference/async.rst:19
msgid "The goal of this guide is to provide some tools to deal with asynchronous systems, and warn against systemic issues or dangers."
msgstr "本指南的目标是提供一些工具来处理异步系统, 并警告反对系统性的问题或危险。"

#: ../../reference/async.rst:23
msgid "Deferreds"
msgstr "延迟"

#: ../../reference/async.rst:25
msgid "Deferreds are a form of `promises`_. OpenERP Web currently uses `jQuery's deferred`_."
msgstr "Deferreds是 `promises` _的一种形式。 OpenERP的网站目前使用'jQuery的deferred `_。"

#: ../../reference/async.rst:28
msgid "The core idea of deferreds is that potentially asynchronous methods will return a :js:class:`Deferred` object instead of an arbitrary value or (most commonly) nothing."
msgstr "deferreds的核心思想是, 潜在的异步方法将返回 :js: class :`Deferred` 对象, 而不是一个任意值或（最常见）, 什么都没有。"

#: ../../reference/async.rst:32
msgid "This object can then be used to track the end of the asynchronous operation by adding callbacks onto it, either success callbacks or error callbacks."
msgstr "此对象然后可用于通过添加回调到它跟踪异步操作的结束, 无论是成功的回调或错误回调。"

#: ../../reference/async.rst:36
msgid "A great advantage of deferreds over simply passing callback functions directly to asynchronous methods is the ability to :ref:`compose them <reference/async/composition>`."
msgstr "deferreds过干脆直接传递回调函数来异步方法一大优点是能够 :ref:`撰写他们<reference/async/composition>` 。"

#: ../../reference/async.rst:41
msgid "Using deferreds"
msgstr "使用延迟"

#: ../../reference/async.rst:43
msgid "Deferreds's most important method is :js:func:`Deferred.then`. It is used to attach new callbacks to the deferred object."
msgstr "Deferreds的最重要的方法是 :js: func :`Deferred.then` 。它是用来连接新的回调延迟对象。"

#: ../../reference/async.rst:46
msgid "the first parameter attaches a success callback, called when the deferred object is successfully resolved and provided with the resolved value(s) for the asynchronous operation."
msgstr "第一个参数附加一个成功的回调, 调用时延迟的对象被成功解决, 并提供与解析值（S）的异步操作。"

#: ../../reference/async.rst:50
msgid "the second parameter attaches a failure callback, called when the deferred object is rejected and provided with rejection values (often some sort of error message)."
msgstr "第二个参数附加一个失败的回调, 调用时延迟的对象被拒绝, 并提供了拒绝值（通常是某种错误消息）。"

#: ../../reference/async.rst:54
msgid "Callbacks attached to deferreds are never \"lost\": if a callback is attached to an already resolved or rejected deferred, the callback will be called (or ignored) immediately. A deferred is also only ever resolved or rejected once, and is either resolved or rejected: a given deferred can not call a single success callback twice, or call both a success and a failure callbacks."
msgstr "连接到deferreds回调是永远'丢失':如果回调连接到一个已经解决或拒绝延期, 则回调将会被调用（或忽略）立即。一个Deferred也永远只能解决或拒绝一次, 是解决或拒绝:给定延期不能称之为一个成功的回调两次, 或拨打成功及失败的回调。"

#: ../../reference/async.rst:61
msgid ":js:func:`~Deferred.then` should be the method you'll use most often when interacting with deferred objects (and thus asynchronous APIs)."
msgstr ":js: func :`~Deferred.then` 应与延迟对象（因此异步API）的交互时, 你会最常使用的方法。"

#: ../../reference/async.rst:65
msgid "Building deferreds"
msgstr "构建延迟"

#: ../../reference/async.rst:67
msgid "After using asynchronous APIs may come the time to build them: for mocks_, to compose deferreds from multiple source in a complex manner, in order to let the current operations repaint the screen or give other events the time to unfold, ..."
msgstr "使用异步的API后可能出现的时间来建立他们, 因mocks_, 组成从多个源deferreds以复杂的方式, 为了让目前的操作重绘屏幕或给予其他事件展开的时候, ..."

#: ../../reference/async.rst:72
msgid "This is easy using jQuery's deferred objects."
msgstr "这是很容易使用jQuery的延迟对象。"

#: ../../reference/async.rst:74
msgid "this section is an implementation detail of jQuery Deferred objects, the creation of promises is not part of any standard (even tentative) that I know of. If you are using deferred objects which are not jQuery's, their API may (and often will) be completely different."
msgstr "这一部分是jQuery的递延对象的实现细节, 创造的承诺是不是任何标准（甚至暂定）, 我知道的一部分。如果您使用的不是jQuery的延迟对象, 他们的API可能（而且往往会）是完全不同的。"

#: ../../reference/async.rst:80
msgid "Deferreds are created by invoking their constructor [#]_ without any argument. This creates a :js:class:`Deferred` instance object with the following methods:"
msgstr "Deferreds通过调用其构造[＃] _不带任何参数创建。这将创建一个 :js: class :`以下方法Deferred` 实例对象:"

#: ../../reference/async.rst:84
msgid ":js:func:`Deferred.resolve`"
msgstr ":js: func :`Deferred.resolve` "

#: ../../reference/async.rst:86
msgid "As its name indicates, this method moves the deferred to the \"Resolved\" state. It can be provided as many arguments as necessary, these arguments will be provided to any pending success callback."
msgstr "正如其名称所示, 这种方法移动推迟到'已解决'状态。它可以被提供作为根据需要, 这些参数将被提供给任何未决的成功回调很多争论。"

#: ../../reference/async.rst:91
msgid ":js:func:`Deferred.reject`"
msgstr ":js: func :`Deferred.reject` "

#: ../../reference/async.rst:93
msgid "Similar to :js:func:`~Deferred.resolve`, but moves the deferred to the \"Rejected\" state and calls pending failure handlers."
msgstr "类似 :js: func :`~Deferred.resolve` , 但移动推迟到'拒绝'状态, 并呼吁正在申请失败处理。"

#: ../../reference/async.rst:96
msgid ":js:func:`Deferred.promise`"
msgstr ":js: func :`Deferred.promise` "

#: ../../reference/async.rst:98
msgid "Creates a readonly view of the deferred object. It is generally a good idea to return a promise view of the deferred to prevent callers from resolving or rejecting the deferred in your stead."
msgstr "创建延迟对象的只读视图。它一般是返回的承诺视图推迟到防止对方解决或拒绝推迟代替你一个好主意。"

#: ../../reference/async.rst:102
msgid ":js:func:`~Deferred.reject` and :js:func:`~Deferred.resolve` are used to inform callers that the asynchronous operation has failed (or succeeded). These methods should simply be called when the asynchronous operation has ended, to notify anybody interested in its result(s)."
msgstr ":js: func :`~Deferred.reject` 和: js :func:`~Deferred.resolve` 被用来通知主叫方的异步操作失败（或成功）。这些方法应该简单地调用时异步操作已经结束, 通知任何人感兴趣的结果（S）。"

#: ../../reference/async.rst:111
msgid "Composing deferreds"
msgstr "撰写延迟"

#: ../../reference/async.rst:113
msgid "What we've seen so far is pretty nice, but mostly doable by passing functions to other functions (well adding functions post-facto would probably be a chore... still, doable)."
msgstr "我们到目前为止看到的是相当不错的, 但通过传递函数的其他功能（以及增加功能事后可能会是一个苦差事......不过, 是可行的）主要是可行的。"

#: ../../reference/async.rst:117
msgid "Deferreds truly shine when code needs to compose asynchronous operations in some way or other, as they can be used as a basis for such composition."
msgstr "当代码需要构成异步操作以某种方式或其他Deferreds真正亮, 因为它们可以被用作该组合物的基础。"

#: ../../reference/async.rst:121
msgid "There are two main forms of compositions over deferred: multiplexing and piping/cascading."
msgstr "有超过延期组成的两种主要形式:复用和管道/级联。"

#: ../../reference/async.rst:125
msgid "Deferred multiplexing"
msgstr "延迟复用"

#: ../../reference/async.rst:127
msgid "The most common reason for multiplexing deferred is simply performing multiple asynchronous operations and wanting to wait until all of them are done before moving on (and executing more stuff)."
msgstr "延迟只是执行多个异步操作, 并希望等到所有的人都对移动（和执行更多的东西）之前完成的最常见原因多路。"

#: ../../reference/async.rst:131
msgid "The jQuery multiplexing function for promises is :js:func:`when`."
msgstr "jQuery的复用功能的承诺是 :js: func :`when` 。"

#: ../../reference/async.rst:133
msgid "the multiplexing behavior of jQuery's :js:func:`when` is an (incompatible, mostly) extension of the behavior defined in `CommonJS Promises/B`_."
msgstr "jQuery的的复用特性 :js: func :`when` 是一个（不兼容的, 主要是）在 `CommonJS的承诺/ B` _定义的行为的延伸。"

#: ../../reference/async.rst:137
msgid "This function can take any number of promises [#]_ and will return a promise."
msgstr "该功能可以采取任何数量的承诺[＃] _, 并会返回一个承诺。"

#: ../../reference/async.rst:140
msgid "The returned promise will be resolved when *all* multiplexed promises are resolved, and will be rejected as soon as one of the multiplexed promises is rejected (it behaves like Python's ``all()``, but with promise objects instead of boolean-ish)."
msgstr "当 *所有* 复用的承诺都解决了返回的承诺将得到解决, 并会尽快复用的承诺之一是拒绝被拒绝（它像Python的 ``所有（）`` , 但与承诺对象, 而不是boolean- ISH）。"

#: ../../reference/async.rst:145
msgid "The resolved values of the various promises multiplexed via :js:func:`when` are mapped to the arguments of :js:func:`when`'s success callback, if they are needed. The resolved values of a promise are at the same index in the callback's arguments as the promise in the :js:func:`when` call so you will have:"
msgstr "通过复用的各种承诺的决心值 :js: func :`when` 分别对应的参数: js :func:`when` 的成功回调, 如果需要他们。的承诺的决心值是在回调的论据作为承诺相同指数在 :js: func :`when` 调用, 所以你将有:"

#: ../../reference/async.rst:160
msgid "in a normal mapping, each parameter to the callback would be an array: each promise is conceptually resolved with an array of 0..n values and these values are passed to :js:func:`when`'s callback. But jQuery treats deferreds resolving a single value specially, and \"unwraps\" that value."
msgstr "在一个正常的映射, 每个参数的回调将是一个数组:每个承诺在概念上解决了与0到n值的数组, 这些价值传递到 :js: func :`when` 的回调。但是jQuery的治疗deferreds解决单个值特别, 和'解开'的价值。"

#: ../../reference/async.rst:166
msgid "For instance, in the code block above if the index of each promise is the number of values it resolves (0 to 3), ``results0`` is an empty array, ``results2`` is an array of 2 elements (a pair) but ``results1`` is the actual value resolved by ``p1``, not an array."
msgstr "例如, 在码块上方如果每个许的索引是它解决值的数目（0至3）, ``results0`` 为空数组, ``results2`` 是2元件的阵列（一一对）, 但 ``results1`` 是由 ``p1`` , 不是数组解决的实际值。"

#: ../../reference/async.rst:172
msgid "Deferred chaining"
msgstr "延迟链条"

#: ../../reference/async.rst:174
msgid "A second useful composition is starting an asynchronous operation as the result of an other asynchronous operation, and wanting the result of both: with the tools described so far, handling e.g. OpenERP's search/read sequence with this would require something along the lines of:"
msgstr "第二种有用组合物开始异步操作作为其它异步操作的结果, 并希望两者的结果是:与所描述的工具, 到目前为止, 处理例如OpenERP的搜索/读取该序列将需要沿着的路线的东西:"

#: ../../reference/async.rst:190
msgid "While it doesn't look too bad for trivial code, this quickly gets unwieldy."
msgstr "虽然它看起来并不太坏了琐碎的代码, 这很快就会笨重。"

#: ../../reference/async.rst:193
msgid "But :js:func:`~Deferred.then` also allows handling this kind of chains: it returns a new promise object, not the one it was called with, and the return values of the callbacks is important to this behavior: whichever callback is called,"
msgstr "但是 :js: func :`~Deferred.then` 还可以处理这类链:它返回一个新的承诺的对象, 而不是一个, 它被称为用, 而回调的返回值是很重要的这种行为:任何回调叫,"

#: ../../reference/async.rst:198
msgid "If the callback is not set (not provided or left to null), the resolution or rejection value(s) is simply forwarded to :js:func:`~Deferred.then`'s promise (it's essentially a noop)"
msgstr "如果回调不设置（不提供或不为空）, 分辨率或拒绝值（s）是简单地转发至 :js: func :`~Deferred.then` 的承诺（它本质上是一个空操作）"

#: ../../reference/async.rst:202
msgid "If the callback is set and does not return an observable object (a deferred or a promise), the value it returns (``undefined`` if it does not return anything) will replace the value it was given, e.g."
msgstr "如果回调设置, 不返回一个可观察的对象（延迟或承诺）, 该值将返回（ ``undefined`` , 如果它不返回任何东西）将代替它被赋予的价值, 例如:"

#: ../../reference/async.rst:212
msgid "will resolve with the sole value ``undefined``."
msgstr "将解决与唯一的价值 ``undefined`` 。"

#: ../../reference/async.rst:214
msgid "If the callback is set and returns an observable object, that object will be the actual resolution (and result) of the pipe. This means a resolved promise from the failure callback will resolve the pipe, and a failure promise from the success callback will reject the pipe."
msgstr "如果回叫被设置并返回一个可观察对象, 该对象将是管的实际分辨率（和结果）。这意味着从失败回调一个解决承诺将解决管, 和从成功回调失败承诺将拒绝该管。"

#: ../../reference/async.rst:220
msgid "This provides an easy way to chain operation successes, and the previous piece of code can now be rewritten:"
msgstr "这提供了一种简单的方法, 以连锁经营的成功, 与前一段代码可以改写为:"

#: ../../reference/async.rst:229
msgid "the result of the whole expression will encode failure if either ``search`` or ``read`` fails (with the right rejection values), and will be resolved with ``read``'s resolution values if the chain executes correctly."
msgstr "如果任一 ``search`` 或 ``read`` 失败（用正确的拒绝值）, 整个表达式的结果将编码失效, 并会与 ``read`` 的分辨率值来解决, 如果链条正确执行。"

#: ../../reference/async.rst:234
msgid ":js:func:`~Deferred.then` is also useful to adapt third-party promise-based APIs, in order to filter their resolution value counts for instance (to take advantage of :js:func:`when` 's special treatment of single-value promises)."
msgstr ":js: func :`~Deferred.then` 也是适应第三方承诺为基础的API, 以过滤其分辨率值计数实例（占便宜有用: js :func:`when` 的特殊处理单值的承诺）。"

#: ../../reference/async.rst:240
msgid "jQuery.Deferred API"
msgstr "jQuery.Deferred API"

#: ../../reference/async.rst:244
msgid "deferred objects to multiplex"
msgstr "deferred objects to multiplex"

#: ../../reference/async.rst:245
msgid "a multiplexed deferred"
msgstr "多路复用延迟"

#: ../../reference/async.rst:246 ../../reference/async.rst:268 ../../reference/async.rst:285 ../../reference/async.rst:300
msgid ":js:class:`Deferred`"
msgstr ":js: class :`Deferred` "

#: ../../reference/async.rst:252
msgid "Attaches new callbacks to the resolution or rejection of the deferred object. Callbacks are executed in the order they are attached to the deferred."
msgstr "重视新的回调递延对象的分辨率或拒绝。回调在它们所连接的延迟的顺序执行。"

#: ../../reference/async.rst:256
msgid "To provide only a failure callback, pass ``null`` as the ``doneCallback``, to provide only a success callback the second argument can just be ignored (and not passed at all)."
msgstr "只提供一个失败的回调, 通 ``null`` 为 ``doneCallback`` , 只提供一个成功的回调（都过去了, 没有）可以直接被忽略了第二个参数。"

#: ../../reference/async.rst:260
msgid "Returns a new deferred which resolves to the result of the corresponding callback, if a callback returns a deferred itself that new deferred will be used as the resolution of the chain."
msgstr "返回一个新的推迟解析为相应的回调的结果, 如果回调函数返回一个deferred本身新的延期将用作链的分辨率。"

#: ../../reference/async.rst:265 ../../reference/async.rst:282
msgid "function called when the deferred is resolved"
msgstr "延迟得到解决时函数被调用"

#: ../../reference/async.rst:266 ../../reference/async.rst:297
msgid "function called when the deferred is rejected"
msgstr "延迟被拒绝时函数被调用"

#: ../../reference/async.rst:267 ../../reference/async.rst:284 ../../reference/async.rst:299
msgid "the deferred object on which it was called"
msgstr "在它被称为延迟的对象"

#: ../../reference/async.rst:272
msgid "Attaches a new success callback to the deferred, shortcut for ``deferred.then(doneCallback)``."
msgstr "附加一个新的成功回调至推迟, 捷径 ``deferred.then（doneCallback）`` 。"

#: ../../reference/async.rst:275
msgid "a difference is the result of :js:func:`Deferred.done`'s is ignored rather than forwarded through the chain"
msgstr "的差的结果 :js: func :`Deferred.done` 的被忽略, 而不是通过该链转发"

#: ../../reference/async.rst:278
msgid "This is a jQuery extension to `CommonJS Promises/A`_ providing little value over calling :js:func:`~Deferred.then` directly, it should be avoided."
msgstr "这是一个jQuery扩展 `CommonJS的承诺/ A` _几乎没有价值超过致电 :js: func :`~Deferred.then` 直接, 应该避免。"

#: ../../reference/async.rst:289
msgid "Attaches a new failure callback to the deferred, shortcut for ``deferred.then(null, failCallback)``."
msgstr "附加一个新的故障回调的延期, 捷径 ``deferred.then（空, failCallback）`` 。"

#: ../../reference/async.rst:292
msgid "A second jQuery extension to `Promises/A <CommonJS Promises/A>`_. Although it provides more value than :js:func:`~Deferred.done`, it still is not much and should be avoided as well."
msgstr "第二jQuery的扩展'的承诺/ A <CommonJS的娓娓道来/ A> `_。虽然它提供了比更多的价值 :js: func :` ~Deferred.done `, 但它仍然是没有太大的, 应该避免。"

#: ../../reference/async.rst:304
msgid "Returns a read-only view of the deferred object, with all mutators (resolve and reject) methods removed."
msgstr "返回递延对象的只读视图, 所有的存取器（解决和拒绝）中删除的方法。"

#: ../../reference/async.rst:309
msgid "Called to resolve a deferred, any value provided will be passed onto the success handlers of the deferred object."
msgstr "调用此方法来解决延迟, 任何规定将被传递到延迟的对象的成功处理程序的价值。"

#: ../../reference/async.rst:312
msgid "Resolving a deferred which has already been resolved or rejected has no effect."
msgstr "解决了延迟已经被解决或拒绝没有任何影响。"

#: ../../reference/async.rst:317
msgid "Called to reject (fail) a deferred, any value provided will be passed onto the failure handler of the deferred object."
msgstr "调用拒绝（失败）一推迟, 所提供的任何值将被传递到递延对象的故障处理程序。"

#: ../../reference/async.rst:320
msgid "Rejecting a deferred which has already been resolved or rejected has no effect."
msgstr "拒绝延期它已经得到解决或拒绝没有任何影响。"

#: ../../reference/async.rst:323
msgid "or simply calling :js:class:`Deferred` as a function, the result is the same"
msgstr "或者简单地调用 :js: class :`Deferred` 作为一个函数, 结果是一样的"

#: ../../reference/async.rst:326
msgid "or not-promises, the `CommonJS Promises/B`_ role of :js:func:`when` is to be able to treat values and promises uniformly: :js:func:`when` will pass promises through directly, but non-promise values and objects will be transformed into a resolved promise (resolving themselves with the value itself)."
msgstr "或不承诺, 请 `CommonJS的承诺/的B` _作用 :js: func :`when` 是能够均匀地对待价值观和承诺: js :func:`when` 将通过承诺通过直接, 但非-promise值和对象将被改造成一个解决的承诺（与本身的价值解析自理）。"

#: ../../reference/async.rst:332
msgid "jQuery's :js:func:`when` keeps this behavior making deferreds easy to build from \"static\" values, or allowing defensive code where expected promises are wrapped in :js:func:`when` just in case."
msgstr "jQuery的 :js: func :`when` 保持这种行为使得deferreds容易建立从'静'的价值观, 或允许防守代码中预计的承诺被包裹在: js :func:`when` 以防万一。"

#: ../../reference/cmdline.rst:7
msgid "Command-line interface: odoo.py"
msgstr "命令行界面 : odoo.py"

#: ../../reference/cmdline.rst:12
msgid "Running the server"
msgstr "运行服务器"

#: ../../reference/cmdline.rst:18
msgid "database used when installing or updating modules."
msgstr "数据库使用安装或更新模块时。"

#: ../../reference/cmdline.rst:22
msgid "comma-separated list of modules to install before running the server (requires :option:`-d`)."
msgstr "模块在运行服务器之前安装的逗号分隔的列表（要求 :option:`-d` ）。"

#: ../../reference/cmdline.rst:27
msgid "comma-separated list of modules to update before running the server (requires :option:`-d`)."
msgstr "模块在运行服务器之前更新的逗号分隔的列表（要求 :option:`-d` ）。"

#: ../../reference/cmdline.rst:32
msgid "comma-separated list of directories in which modules are stored. These directories are scanned for modules (nb: when and why?)"
msgstr "在模块存储目录的逗号分隔的列表。这些目录扫描模块（注:什么时候, 为什么？）"

#: ../../reference/cmdline.rst:37
msgid "if ``count`` is not 0 (the default), enables multiprocessing and sets up the specified number of HTTP workers (sub-processes processing HTTP and RPC requests)."
msgstr "如果 ``count`` 不为0（默认值）, 使多并设置HTTP工人的指定数目（子进程处理HTTP和RPC请求）。"

#: ../../reference/cmdline.rst:41
msgid "multiprocessing mode is only available on Unix-based systems"
msgstr "多模式仅适用于基于Unix的系统"

#: ../../reference/cmdline.rst:43
msgid "A number of options allow limiting and recycling workers:"
msgstr ""

#: ../../reference/cmdline.rst:47
msgid "Number of requests a worker will process before being recycled and restarted."
msgstr "被回收并重新启动要求工人将之前处理的数量。"

#: ../../reference/cmdline.rst:50
msgid "Defaults to 8196."
msgstr "默认为8​​196。"

#: ../../reference/cmdline.rst:54
msgid "Maximum allowed virtual memory per worker. If the limit is exceeded, the worker is killed and recycled at the end of the current request."
msgstr "每个工人允许的最大虚拟内存。如果超过限制, 该名工人死亡, 回收在当前请求结束。"

#: ../../reference/cmdline.rst:57
msgid "Defaults to 640MB."
msgstr "默认为640MB。"

#: ../../reference/cmdline.rst:61
msgid "Hard limit on virtual memory, any worker exceeding the limit will be immediately killed without waiting for the end of the current request processing."
msgstr "虚拟内存硬性限制, 任何工人超过限制将被立即杀死而不等待当前请求处理结束。"

#: ../../reference/cmdline.rst:65
msgid "Defaults to 768MB."
msgstr "默认为768MB。"

#: ../../reference/cmdline.rst:69
msgid "Prevents the worker from using more than <limit> CPU seconds for each request. If the limit is exceeded, the worker is killed."
msgstr "防止使用超过<极限> CPU秒为每个请求的工人。如果超出限制, 工人被杀害。"

#: ../../reference/cmdline.rst:72
msgid "Defaults to 60."
msgstr "默认为60。"

#: ../../reference/cmdline.rst:76
msgid "Prevents the worker from taking longer than <limit> seconds to process a request. If the limit is exceeded, the worker is killed."
msgstr "防止时间超过<极限>秒来处理请求的工人。如果超出限制, 工人被杀害。"

#: ../../reference/cmdline.rst:79
msgid "Differs from :option:`--limit-time-cpu` in that this is a \"wall time\" limit including e.g. SQL queries."
msgstr "不同于 :option:`--limit-时间cpu` 的, 这是一个'挂钟时间'的限制, 包括如SQL查询。"

#: ../../reference/cmdline.rst:82
msgid "Defaults to 120."
msgstr "默认为120。"

#: ../../reference/cmdline.rst:86
msgid "number of workers dedicated to cron jobs. Defaults to 2. The workers are threads in multi-threading mode and processes in multi-processing mode."
msgstr ""

#: ../../reference/cmdline.rst:89
msgid "For multi-processing mode, this is in addition to the HTTP worker processes."
msgstr ""

#: ../../reference/cmdline.rst:94
msgid "provide an alternate configuration file"
msgstr "提供一个备用的配置文件"

#: ../../reference/cmdline.rst:98
msgid "saves the server configuration to the current configuration file (:file:`{$HOME}/.openerp_serverrc` by default, and can be overridden using :option:`-c`)"
msgstr ""

#: ../../reference/cmdline.rst:104
msgid "enables the use of ``X-Forwarded-*`` headers through `Werkzeug's proxy support`_."
msgstr "支持通过 `WERKZEUG的代理support` _使用 ``的X Forwarded- *`` 头。"

#: ../../reference/cmdline.rst:107
msgid "proxy mode *must not* be enabled outside of a reverse proxy scenario"
msgstr "代理模式 *不能* 反向代理方案之外启用"

#: ../../reference/cmdline.rst:112
msgid "runs tests after installing modules"
msgstr "安装模块后运行测试"

#: ../../reference/cmdline.rst:116
msgid "when an unexpected error is raised (not a warning or an access error), automatically starts :mod:`python:pdb` before logging and returning the error"
msgstr "时, 引发意外的错误（不是警告或访问错误）, 将自动启动 :mod:`Python:pdb` 记录前, 返回错误"

#: ../../reference/cmdline.rst:123
msgid "database"
msgstr "数据库"

#: ../../reference/cmdline.rst:127
msgid "database username, used to connect to PostgreSQL."
msgstr "数据库用户名, 用于连接到PostgreSQL。"

#: ../../reference/cmdline.rst:131
msgid "database password, if using `password authentication`_."
msgstr "数据库密码, 如果使用 `密码authentication` _。"

#: ../../reference/cmdline.rst:135
msgid "host for the database server"
msgstr "托管数据库服务器"

#: ../../reference/cmdline.rst:137
msgid "``localhost`` on Windows"
msgstr "在Windows 平台 ``localhost`` "

#: ../../reference/cmdline.rst:138
msgid "UNIX socket otherwise"
msgstr "UNIX套接字, 否则"

#: ../../reference/cmdline.rst:142
msgid "port the database listens on, defaults to 5432"
msgstr "数据库监听端口, 默认为5432"

#: ../../reference/cmdline.rst:146
msgid "hides databases that do not match ``<filter>``. The filter is a `regular expression`_, with the additions that:"
msgstr "隐藏的数据库不匹配 ``<filter>`` . 。该过滤器是一个 `定期expression` _, 用加的是:"

#: ../../reference/cmdline.rst:149
msgid "``%h`` is replaced by the whole hostname the request is made on."
msgstr " ``%h`` is replaced by the whole hostname the request is made on."

#: ../../reference/cmdline.rst:150
msgid "``%d`` is replaced by the subdomain the request is made on, with the exception of ``www`` (so domain ``odoo.com`` and ``www.odoo.com`` both match the database ``odoo``)"
msgstr " ``%d`` is replaced by the subdomain the request is made on, with the exception of ``www`` (so domain ``odoo.com`` and ``www.odoo.com`` both match the database ``odoo`` )"

#: ../../reference/cmdline.rst:156
msgid "when creating new databases from the database-management screens, use the specified `template database`_. Defaults to ``template1``."
msgstr "创建从数据库管理界面的新数据库时, 使用指定的 `模板database` _。默认为 ``template1`` 。"

#: ../../reference/cmdline.rst:160
msgid "built-in HTTP"
msgstr "内置的HTTP"

#: ../../reference/cmdline.rst:164
msgid "do not start the HTTP or long-polling workers (may still start cron workers)"
msgstr "不要启动HTTP或长轮询工人（仍然可以启动cron的工作人员）"

#: ../../reference/cmdline.rst:167
msgid "has no effect if :option:`--test-enable` is set, as tests require an accessible HTTP server"
msgstr "如果有任何影响 :option:'--test-enable `设置, 作为测试要求可访问的HTTP服务器"

#: ../../reference/cmdline.rst:172
msgid "TCP/IP address on which the HTTP server listens, defaults to ``0.0.0.0`` (all addresses)"
msgstr "在其上的HTTP服务器监听TCP / IP地址, 默认为 ``0.0.0.0`` （所有地址）"

#: ../../reference/cmdline.rst:177
msgid "Port on which the HTTP server listens, defaults to 8069."
msgstr "端口上的HTTP服务器监听, 默认为8069。"

#: ../../reference/cmdline.rst:181
msgid "TCP port for long-polling connections in multiprocessing or gevent mode, defaults to 8072. Not used in default (threaded) mode."
msgstr "对于长轮询连接的多或GEVENT模式的TCP端口, 默认为8072.未使用的默认值（线程）模式。"

#: ../../reference/cmdline.rst:185
msgid "logging"
msgstr "日志"

#: ../../reference/cmdline.rst:187
msgid "By default, Odoo displays all logging of level_ ``info`` except for workflow logging (``warning`` only), and log output is sent to ``stdout``. Various options are available to redirect logging to other destinations and to customize the amount of logging output"
msgstr ""

#: ../../reference/cmdline.rst:194
msgid "sends logging output to the specified file instead of stdout. On Unix, the file `can be managed by external log rotation programs <https://docs.python.org/2/library/logging.handlers.html#watchedfilehandler>`_ and will automatically be reopened when replaced"
msgstr "发送日志输出到指定的文件, 而不是标准输出。在Unix上, 文件'可以通过外部的日志轮换计划管理<https ://docs.python.org/2/library/logging.handlers.html#watchedfilehandler> `_, 并会自动进行更换时, 重新打开"

#: ../../reference/cmdline.rst:201
msgid "enables `log rotation <https://docs.python.org/2/library/logging.handlers.html#timedrotatingfilehandler>`_ daily, keeping 30 backups. Log rotation frequency and number of backups is not configurable."
msgstr "开启 `日志翻转<https ://docs.python.org/2/library/logging.handlers.html#timedrotatingfilehandler>` _每日, 保持30份备份。日志旋转频率和备份的数量不可配置。"

#: ../../reference/cmdline.rst:207
msgid "logs to the system's event logger: `syslog on unices <https://docs.python.org/2/library/logging.handlers.html#sysloghandler>`_ and `the Event Log on Windows <https://docs.python.org/2/library/logging.handlers.html#nteventloghandler>`_."
msgstr "登录到系统的事件记录器:`系统日志在Unix系统<https ://docs.python.org/2/library/logging.handlers.html#sysloghandler>` _和 `事件日志在Windows <https://开头的文档。 python.org/2/library/logging.handlers.html#nteventloghandler>` _。"

#: ../../reference/cmdline.rst:210
msgid "Neither is configurable"
msgstr "无论是可配置"

#: ../../reference/cmdline.rst:214
msgid "logs to the ``ir.logging`` model (``ir_logging`` table) of the specified database. The database can be the name of a database in the \"current\" PostgreSQL, or `a PostgreSQL URI`_ for e.g. log aggregation"
msgstr "登录到指定的数据库的 ``ir.logging`` 模型（ ``ir_logging`` 表）。该数据库可以在数据库名称“当前'PostgreSQL或 `一个PostgreSQL URI` _用于例如日志汇总"

#: ../../reference/cmdline.rst:220
msgid ":samp:`{LOGGER}:{LEVEL}`, enables ``LOGGER`` at the provided ``LEVEL`` e.g. ``openerp.models:DEBUG`` will enable all logging messages at or above ``DEBUG`` level in the models."
msgstr ":samp:`{}记录器:{LEVEL}` , 使 ``LOGGER`` 在提供 ``LEVEL`` 如 ``openerp.models:DEBUG`` 将使所有日志消息或高于 ``DEBUG`` 在模型中的水平。"

#: ../../reference/cmdline.rst:224
msgid "The colon ``:`` is mandatory"
msgstr "冒号 ``:`` 是强制的"

#: ../../reference/cmdline.rst:225
msgid "The logger can be omitted to configure the root (default) handler"
msgstr "记录器可以被省略, 以配置根（默认）的处理程序"

#: ../../reference/cmdline.rst:226
msgid "If the level is omitted, the logger is set to ``INFO``"
msgstr "如果液位被省略, 记录器被设置为 ``INFO`` "

#: ../../reference/cmdline.rst:228
msgid "The option can be repeated to configure multiple loggers e.g."
msgstr "可重复的选项配置多个记录器如"

#: ../../reference/cmdline.rst:236
msgid "enable DEBUG logging for RPC requests, equivalent to ``--log-handler=openerp.http.rpc.request:DEBUG``"
msgstr "启用调试日志记录RPC请求, 相当于 ``--log处理程序= openerp.http.rpc.request:DEBUG`` "

#: ../../reference/cmdline.rst:241
msgid "enable DEBUG logging for RPC responses, equivalent to ``--log-handler=openerp.http.rpc.response:DEBUG``"
msgstr "启用调试日志记录RPC响应, 相当于 ``--log处理程序= openerp.http.rpc.response:DEBUG`` "

#: ../../reference/cmdline.rst:246
msgid "enables DEBUG logging of HTTP requests and responses, equivalent to ``--log-handler=openerp.http:DEBUG``"
msgstr "允许HTTP请求和响应的调试日志, 相当于 ``--log处理程序= openerp.http:DEBUG`` "

#: ../../reference/cmdline.rst:251
msgid "enables DEBUG logging of SQL querying, equivalent to ``--log-handler=openerp.sql_db:DEBUG``"
msgstr "使SQL查询的调试日志, 相当于 ``--log处理程序= openerp.sql_db:DEBUG`` "

#: ../../reference/cmdline.rst:256
msgid "Shortcut to more easily set predefined levels on specific loggers. \"real\" levels (``critical``, ``error``, ``warn``, ``debug``) are set on the ``openerp`` and ``werkzeug`` loggers (except for ``debug`` which is only set on ``openerp``)."
msgstr "Shortcut to more easily set predefined levels on specific loggers. ``real`` levels ( ``critical`` , ``error`` , ``warn`` , ``debug`` ) are set on the ``openerp`` and ``werkzeug`` loggers (except for ``debug`` which is only set on ``openerp`` )."

#: ../../reference/cmdline.rst:261
msgid "Odoo also provides debugging pseudo-levels which apply to different sets of loggers:"
msgstr "Odoo还提供了调试伪级别适用于不同组记录器:"

#: ../../reference/cmdline.rst:266
msgid "``debug_sql``"
msgstr " ``debug_sql`` "

#: ../../reference/cmdline.rst:265
msgid "sets the SQL logger to ``debug``"
msgstr "设置SQL记录器为 ``debug`` "

#: ../../reference/cmdline.rst:267
msgid "equivalent to ``--log-sql``"
msgstr "相当于 ``--log-sql`` "

#: ../../reference/cmdline.rst:270
msgid "``debug_rpc``"
msgstr " ``debug_rpc`` "

#: ../../reference/cmdline.rst:269
msgid "sets the ``openerp`` and HTTP request loggers to ``debug``"
msgstr "设置了 ``openerp`` 和HTTP请求记录仪 ``debug`` "

#: ../../reference/cmdline.rst:271
msgid "equivalent to ``--log-level debug --log-request``"
msgstr "相当于 ``--log级调试--log-request`` "

#: ../../reference/cmdline.rst:276
msgid "``debug_rpc_answer``"
msgstr " ``debug_rpc_answer`` "

#: ../../reference/cmdline.rst:273
msgid "sets the ``openerp`` and HTTP request and response loggers to ``debug``"
msgstr "设置了 ``openerp`` 和HTTP请求和响应记录器 ``debug`` "

#: ../../reference/cmdline.rst:276
msgid "equivalent to ``--log-level debug --log-request --log-response``"
msgstr "相当于 ``--log级调试--log请求--log-response`` "

#: ../../reference/cmdline.rst:280
msgid "In case of conflict between :option:`--log-level` and :option:`--log-handler`, the latter is used"
msgstr "万一发生冲突的 :option:'--log-level `和 :option:'--log-handler` , 后者用于"

#: ../../reference/cmdline.rst:287
msgid "Scaffolding"
msgstr "脚手架"

#: ../../reference/cmdline.rst:291
msgid "Scaffolding is the automated creation of a skeleton structure to simplify bootstrapping (of new modules, in the case of Odoo). While not necessary it avoids the tedium of setting up basic structures and looking up what all starting requirements are."
msgstr "脚手架的骨架结构的自动创建以简化自举（新模块, 在Odoo的情况下）。虽然没有必要, 避免了建立基本结构, 望着什么都开始要求的单调乏味。"

#: ../../reference/cmdline.rst:296
msgid "Scaffolding is available via the :command:`odoo.py scaffold` subcommand."
msgstr "命令:`odoo.py scaffold` 子脚手架通过可用。"

#: ../../reference/cmdline.rst:300
msgid "a template directory, files are passed through jinja2_ then copied to the ``destination`` directory"
msgstr "模板目录下, 文件是通过jinja2_然后复制到 ``destination`` 目录传递"

#: ../../reference/cmdline.rst:305
msgid "the name of the module to create, may munged in various manners to generate programmatic names (e.g. module directory name, model names, …)"
msgstr "模块创建, 名称可以以各种方式被改写的, 以产生编程的名称（如模块目录名称, 型号名称, ...）"

#: ../../reference/cmdline.rst:310
msgid "directory in which to create the new module, defaults to the current directory"
msgstr "在目录中创建新的模块, 默认为当前目录"

#: ../../reference/cmdline.rst:316
msgid "Configuration file"
msgstr "配置文件"

#: ../../reference/cmdline.rst:318
msgid "Most of the command-line options can also be specified via a configuration file. Most of the time, they use similar names with the prefix ``-`` removed and other ``-`` are replaced by ``_`` e.g. :option:`--db-template` becomes ``db_template``."
msgstr "大多数的命令行选项, 也可以通过配置文件中指定。选项​​:`--db-template` 变得 ``db_template`` 在大多数情况下, 他们使用类似名称的前缀 ``-`` 删除等 ``-`` 通过 ``_`` 如被替换。"

#: ../../reference/cmdline.rst:323
msgid "Some conversions don't match the pattern:"
msgstr "有些转换不匹配模式:"

#: ../../reference/cmdline.rst:325
msgid ":option:`--db-filter` becomes ``dbfilter``"
msgstr ":option:`--db-filter` 变为 ``dbfilter`` "

#: ../../reference/cmdline.rst:326
msgid ":option:`--no-xmlrpc` corresponds to the ``xmlrpc`` boolean"
msgstr ":option:`--no-xmlrpc` 相当于 ``xmlrpc`` 布尔"

#: ../../reference/cmdline.rst:327
msgid "logging presets (all options starting with ``--log-`` except for :option:`--log-handler` and :option:`--log-db`) just add content to ``log_handler``, use that directly in the configuration file"
msgstr "记录预设（所有选项开始 ``--log-`` 除外 :option:'--log-handler `和 :option:'--log-db` ）只是将内容添加到 ``log_handler`` , 使用直接在配置文件"

#: ../../reference/cmdline.rst:330
msgid ":option:`--smtp` is stored as ``smtp_server``"
msgstr ":option:`--smtp` 存储为 ``smtp_server`` "

#: ../../reference/cmdline.rst:331
msgid ":option:`--database` is stored as ``db_name``"
msgstr ""

#: ../../reference/cmdline.rst:332
msgid ":option:`--debug` is stored as ``debug_mode`` (a boolean)"
msgstr ":option:`--debug` 存储为 ``debug_mode`` （一个布尔值）"

#: ../../reference/cmdline.rst:333
msgid ":option:`--i18n-import` and :option:`--i18n-export` aren't available at all from configuration files"
msgstr ":option:`--i18n-import` 和 :option:`--i18n-export` 不可用在所有的配置文件"

#: ../../reference/cmdline.rst:336
msgid "The default configuration file is :file:`{$HOME}/.openerp_serverrc` which can be overridden using :option:`--config <odoo.py -c>`. Specifying :option:`--save <odoo.py -s>` will save the current configuration state back to that file."
msgstr "默认的配置文件是 :file:`{$HOME}/.openerp_serverrc` 可使用被覆盖。选项:`--config <odoo.py -c>` 。指定 :option:`--save <odoo.py -s>` 将保存当前配置的状态恢复到该文件。"

#: ../../reference/data.rst:7
msgid "Data Files"
msgstr "数据文件"

#: ../../reference/data.rst:9
msgid "Odoo is greatly data-driven, and a big part of modules definition is thus the definition of the various records it manages: UI (menus and views), security (access rights and access rules), reports and plain data are all defined via records."
msgstr "Odoo是主要由数据驱动的, 并且模块定义的很大一部分, 是它所管理的记录的定义:用户界面（菜单和视图）, 安全性（访问权限和访问规则）, 报告和普通数据都是通过记录定义的。"

#: ../../reference/data.rst:15
msgid "Structure"
msgstr "结构"

#: ../../reference/data.rst:17
msgid "The main way to define data in Odoo is via XML data files: The broad structure of an XML data file is the following:"
msgstr "在Odoo定义数据的主要途径是通过XML数据文件:XML数据文件的大体结构如下:"

#: ../../reference/data.rst:20
msgid "Any number of operation elements within the root element ``odoo``"
msgstr "任何数量的操作元素具有根元素 ``odoo`` "

#: ../../reference/data.rst:30
msgid "Data files are executed sequentially, operations can only refer to the result of operations defined previously"
msgstr "数据文件被顺序地执行, 操作能只引用先前定义的操作结果"

#: ../../reference/data.rst:34
msgid "Core operations"
msgstr "核心操作"

#: ../../reference/data.rst:39 ../../reference/views.rst:867
msgid "``record``"
msgstr " ``record`` "

#: ../../reference/data.rst:41
msgid "``record`` appropriately defines or updates a database record, it has the following attributes:"
msgstr " ``record`` 定义或更新数据库记录, 它具有下列属性:"

#: ../../reference/data.rst:44 ../../reference/data.rst:134
msgid "``model`` (required)"
msgstr " ``model`` （必填）"

#: ../../reference/data.rst:45
msgid "name of the model to create (or update)"
msgstr "该模型的名称以创建（或更新）"

#: ../../reference/data.rst:47
msgid "the :term:`external identifier` for this record. It is strongly recommended to provide one"
msgstr "the :term:`external identifier` for this record. It is strongly recommended to provide one"

#: ../../reference/data.rst:50
msgid "for record creation, allows subsequent definitions to either modify or refer to this record"
msgstr "备案创作, 让后续的定义, 要么修改或引用此记录"

#: ../../reference/data.rst:52
msgid "for record modification, the record to modify"
msgstr "记录修改, 需要修改的记录"

#: ../../reference/data.rst:54
msgid "context to use when creating the record"
msgstr "上下文创建记录时使用"

#: ../../reference/data.rst:58
msgid "``forcecreate``"
msgstr " ``forcecreate`` "

#: ../../reference/data.rst:56
msgid "in update mode whether the record should be created if it doesn't exist"
msgstr "在更新模式是否该记录应该创建, 如果它不存在"

#: ../../reference/data.rst:58
msgid "Requires an :term:`external id`, defaults to ``True``."
msgstr "Requires an :term:`external id` , defaults to ``True`` ."

#: ../../reference/data.rst:61 ../../reference/views.rst:285 ../../reference/views.rst:426 ../../reference/views.rst:845 ../../reference/views.rst:1165
msgid "``field``"
msgstr " ``field`` "

#: ../../reference/data.rst:63
msgid "Each record can be composed of ``field`` tags, defining values to set when creating the record. A ``record`` with no ``field`` will use all default values (creation) or do nothing (update)."
msgstr "每个记录可以由 ``field`` 标签, 定义价值创造的纪录时设置。一个 ``record`` 没有 ``field`` 将使用所有默认值（创建）, 或者什么也不做（更新）。"

#: ../../reference/data.rst:67
msgid "A ``field`` has a mandatory ``name`` attribute, the name of the field to set, and various methods to define the value itself:"
msgstr "甲 ``field`` 具有强制性 ``name`` 属性, 该字段设置的名称, 以及各种方法来定义的值本身:"

#: ../../reference/data.rst:72
msgid "Nothing"
msgstr "没有"

#: ../../reference/data.rst:71
msgid "if no value is provided for the field, an implicit ``False`` will be set on the field. Can be used to clear a field, or avoid using a default value for the field."
msgstr "如果提供的字段没有值, 一个隐式 ``False`` 将在字段进行设置。可以用来清除字段, 或避免使用的字段的缺省值。"

#: ../../reference/data.rst:79 ../../reference/data.rst:140
msgid "``search``"
msgstr " ``search`` "

#: ../../reference/data.rst:75
msgid "for :ref:`relational fields <reference/orm/fields/relational>`, should be a :ref:`domain <reference/orm/domains>` on the field's model."
msgstr "为 :ref:`关系字段<reference/orm/fields/relational>` , 应该是 :ref:'域<reference/orm/domains> `在球场上的典范。"

#: ../../reference/data.rst:78
msgid "Will evaluate the domain, search the field's model using it and set the search's result as the field's value. Will only use the first result if the field is a :class:`~openerp.fields.Many2one`"
msgstr "将评估字段, 利用其搜索字段的模式和设定搜索的结果作为该字段的值。将只使用第一个结果, 如果该字段为 :class:`~openerp.fields.Many2one` "

#: ../../reference/data.rst:85
msgid "``ref``"
msgstr " ``ref`` "

#: ../../reference/data.rst:82
msgid "if a ``ref`` attribute is provided, its value must be a valid :term:`external id`, which will be looked up and set as the field's value."
msgstr "如果提供了 ``ref`` 属性, 它的值必须是有效的 :term:`外部ID` , 这将是抬起头, 设置为字段的值。"

#: ../../reference/data.rst:85
msgid "Mostly for :class:`~openerp.fields.Many2one` and :class:`~openerp.fields.Reference` fields"
msgstr "主要用于 :class:`~openerp.fields.Many2one` 和 :class:`~openerp.fields.Reference` 字段"

#: ../../reference/data.rst:88
msgid "if a ``type`` attribute is provided, it is used to interpret and convert the field's content. The field's content can be provided through an external file using the ``file`` attribute, or through the node's body."
msgstr "如果提供了 ``type`` 属性, 它是用来解释并转换该字段的内容。该字段的内容可以通过一个外部文件使用 ``file`` 属性来提供, 或通过节点的身体。"

#: ../../reference/data.rst:92
msgid "Available types are:"
msgstr "可用的类型有:"

#: ../../reference/data.rst:96
msgid "``xml``, ``html``"
msgstr " ``xml`` , ``html`` "

#: ../../reference/data.rst:95
msgid "extracts the ``field``'s children as a single document, evaluates any :term:`external id` specified with the form ``%(external_id)s``. ``%%`` can be used to output actual *%* signs."
msgstr "提取 ``field`` 的孩子作为一个单一的文件, 任何评估:短期:`的形式 ``％（external_id）s`` 指定的外部ID` 。 ``%%`` 可用于输出实际 *％* 迹象。"

#: ../../reference/data.rst:99
msgid "``file``"
msgstr " ``file`` "

#: ../../reference/data.rst:99
msgid "ensures that the field content is a valid file path in the current model, saves the pair :samp:`{module},{path}` as the field value"
msgstr "确保该字段的内容是在当前模型一个有效的文件路径, 保存对 :samp:`{模块}, {路径}` 作为字段值"

#: ../../reference/data.rst:102
msgid "``char``"
msgstr " ``char`` "

#: ../../reference/data.rst:102
msgid "sets the field content directly as the field's value without alterations"
msgstr "直接设置字段内容没有改变该字段的值"

#: ../../reference/data.rst:105
msgid "``base64``"
msgstr " ``base64`` "

#: ../../reference/data.rst:105
msgid "base64_-encodes the field's content, useful combined with the ``file`` *attribute* to load e.g. image data into attachments"
msgstr "base64_-编码字段的内容, 与 ``file`` *attribute* 属性结合来加载如图像数据到附件"

#: ../../reference/data.rst:108
msgid "``int``"
msgstr " ``int`` "

#: ../../reference/data.rst:108
msgid "converts the field's content to an integer and sets it as the field's value"
msgstr "该字段的内容转换为整数, 并将其设置该字段的值"

#: ../../reference/data.rst:111
msgid "``float``"
msgstr " ``float`` "

#: ../../reference/data.rst:111
msgid "converts the field's content to a float and sets it as the field's value"
msgstr "该字段的内容转换为浮动, 并将其设置字段的值"

#: ../../reference/data.rst:116
msgid "``list``, ``tuple``"
msgstr " ``list`` , ``tuple`` "

#: ../../reference/data.rst:114
msgid "should contain any number of ``value`` elements with the same properties as ``field``, each element resolves to an item of a generated tuple or list, and the generated collection is set as the field's value"
msgstr "应该包含任何数目的 ``value`` 元件具有相同属性如 ``field`` , 每个元素解析为生成元组或列表的一个项目, 并将所产生的集合被设置为字段的值"

#: ../../reference/data.rst:126
msgid "``eval``"
msgstr " ``eval`` "

#: ../../reference/data.rst:119
msgid "for cases where the previous methods are unsuitable, the ``eval`` attributes simply evaluates whatever Python expression it is provided and sets the result as the field's value."
msgstr "为在先前的方法是不适合的情况下, ``eval`` 属性简单地计算任何Python表达式它被设置, 并设置其结果作为该字段的值。"

#: ../../reference/data.rst:123
msgid "The evaluation context contains various modules (``time``, ``datetime``, ``timedelta``, ``relativedelta``), a function to resolve :term:`external identifiers` (``ref``) and the model object for the current field if applicable (``obj``)"
msgstr "评价范围内包含各种模块（ ``time`` , ``datetime`` , ``timedelta`` , ``relativedelta`` ）, 一个函数来解决:短期:`外部identifiers` （ ``ref`` ）和当前场中的模型对象（如果适用）（ ``obj`` ）"

#: ../../reference/data.rst:129 ../../reference/views.rst:897
msgid "``delete``"
msgstr " ``delete`` "

#: ../../reference/data.rst:131
msgid "The ``delete`` tag can remove any number of records previously defined. It has the following attributes:"
msgstr "该 ``delete`` 标签可以删除先前定义的任何数量的记录。它具有以下属性:"

#: ../../reference/data.rst:135
msgid "the model in which a specified record should be deleted"
msgstr "其中一个指定的记录应予以删除模型"

#: ../../reference/data.rst:137
msgid "the :term:`external id` of a record to remove"
msgstr ":term:`external id` 是要移除的记录"

#: ../../reference/data.rst:139
msgid "a :ref:`domain <reference/orm/domains>` to find records of the model to remove"
msgstr "答 :ref:'域<reference/orm/domains> `来找到模型的记录删除"

#: ../../reference/data.rst:142
msgid "``id`` and ``search`` are exclusive"
msgstr " ``id`` 和 ``search`` 互斥"

#: ../../reference/data.rst:145
msgid "``function``"
msgstr " ``function`` "

#: ../../reference/data.rst:147
msgid "The ``function`` tag calls a method on a model, with provided parameters. It has two mandatory parameters ``model`` and ``name`` specifying respectively the model and the name of the method to call."
msgstr "该 ``function`` 标签调用一个模型, 提供的参数的方法。它有两个强制参数 ``model`` 和 ``name`` 分别指定模型和调用的方法的名称。"

#: ../../reference/data.rst:151
msgid "Parameters can be provided using ``eval`` (should evaluate to a sequence of parameters to call the method with) or ``value`` elements (see ``list`` values)."
msgstr "参数可以使用 ``eval`` （应该评估的参数序列与调用方法）或 ``value`` 元素（见 ``list`` 值）来提供。"

#: ../../reference/data.rst:156
msgid "``workflow``"
msgstr " ``workflow`` "

#: ../../reference/data.rst:158
msgid "The ``workflow`` tag sends a signal to an existing workflow. The workflow can be specified via a ``ref`` attribute (the :term:`external id` of an existing workflow) or a ``value`` tag returning the id of a workflow."
msgstr "在 ``workflow`` 标签发送信号到现有的工作流程。 （:短期:`现有工作流程的外部ID` 的）或 ``value`` 标签返回一个工作流的ID的工作流可以通过 ``ref`` 属性来指定。"

#: ../../reference/data.rst:162
msgid "The tag also has two mandatory attributes ``model`` (the model linked to the workflow) and ``action`` (the name of the signal to send to the workflow)."
msgstr "标签也有两个必选属性 ``model`` （链接到工作流模型）和 ``action`` （信号的名称发送到工作流）。"

#: ../../reference/data.rst:168
msgid "Shortcuts"
msgstr "快捷方式"

#: ../../reference/data.rst:170
msgid "Because some important structural models of Odoo are complex and involved, data files provide shorter alternatives to defining them using :ref:`record tags <reference/data/record>`:"
msgstr "由于Odoo的一些重要结构模型非常复杂难缠, 数据文件提供给更短的替代方式来定义它们 :ref:`record tags <reference/data/record>` :"

#: ../../reference/data.rst:175
msgid "``menuitem``"
msgstr " ``menuitem`` "

#: ../../reference/data.rst:177
msgid "Defines an ``ir.ui.menu`` record with a number of defaults and fallbacks:"
msgstr "定义了一些默认值和回退的 ``ir.ui.menu`` 记录:"

#: ../../reference/data.rst:186
msgid "Parent menu"
msgstr "父菜单"

#: ../../reference/data.rst:180
msgid "If a ``parent`` attribute is set, it should be the :term:`external id` of an other menu item, used as the new item's parent"
msgstr "如果 ``parent`` 属性设置, 它应该是 :term:`的其他菜单项的外部ID` , 用作新项目的父"

#: ../../reference/data.rst:182
msgid "If no ``parent`` is provided, tries to interpret the ``name`` attribute as a ``/``-separated sequence of menu names and find a place in the menu hierarchy. In that interpretation, intermediate menus are automatically created"
msgstr "如果没有 ``parent`` 提供, 试图解释 ``name`` 属性为 ``/`` - 分隔菜单名称的序列, 发现在菜单层级的地方。在这种解释, 自动创建中间的菜单"

#: ../../reference/data.rst:186
msgid "Otherwise the menu is defined as a \"top-level\" menu item (*not* a menu with no parent)"
msgstr "否则, 菜单被定义为一个'顶层'菜单项（ *不* 没有父菜单）"

#: ../../reference/data.rst:189
msgid "Menu name"
msgstr "菜单名称"

#: ../../reference/data.rst:189
msgid "If no ``name`` attribute is specified, tries to get the menu name from a linked action if any. Otherwise uses the record's ``id``"
msgstr "如果没有指定 ``name`` 属性, 试图从一个链接的行动, 如果得到任何菜单名称。否则, 使用记录的 ``id`` "

#: ../../reference/data.rst:194
msgid "Groups"
msgstr "组"

#: ../../reference/data.rst:192
msgid "A ``groups`` attribute is interpreted as a comma-separated sequence of :term:`external identifiers` for ``res.groups`` models. If an :term:`external identifier` is prefixed with a minus (``-``), the group is *removed* from the menu's groups"
msgstr "一个 ``groups`` 属性被解释为一个逗号分隔的序列 :term:`外部identifiers` 的 ``res.groups`` 车型。如果:短期:`外部identifier` 前缀为负（ ``-`` ）, 该集团 *删除* 从菜单中的组"

#: ../../reference/data.rst:197 ../../reference/views.rst:215
msgid "``action``"
msgstr " ``action`` "

#: ../../reference/data.rst:197
msgid "if specified, the ``action`` attribute should be the :term:`external id` of an action to execute when the menu is open"
msgstr "如果指定了 ``action`` 属性应该是:条件:执行操作的'外部ID `当菜单打开"

#: ../../reference/data.rst:200
msgid "the menu item's :term:`external id`"
msgstr "菜单项的 :term:`外部ID` "

#: ../../reference/data.rst:205
msgid "``template``"
msgstr " ``template`` "

#: ../../reference/data.rst:207
msgid "Creates a :ref:`QWeb view <reference/views/qweb>` requiring only the ``arch`` section of the view, and allowing a few *optional* attributes:"
msgstr "创建 :ref:`QWeb查看<reference/views/qweb>` 要求来看, 只有 ``arch`` 部分, 并允许一些 *可选* 属性:"

#: ../../reference/data.rst:211
msgid "the view's :term:`external identifier`"
msgstr "该视图的 :term:`外部identifier` "

#: ../../reference/data.rst:213
msgid "``name``, ``inherit_id``, ``priority``"
msgstr " ``name`` , ``inherit_id`` , ``priority`` "

#: ../../reference/data.rst:213
msgid "same as the corresponding field on ``ir.ui.view`` (nb: ``inherit_id`` should be an :term:`external identifier`)"
msgstr "同为相应的字段 ``ir.ui.view`` （注意:``inherit_id`` 应该是 :term:`外部identifier` ）"

#: ../../reference/data.rst:216
msgid "``primary``"
msgstr " ``primary`` "

#: ../../reference/data.rst:216
msgid "if set to ``True`` and combined with a ``inherit_id``, defines the view as a primary"
msgstr "如果设置为 ``True和结合了`` inherit_id ``, 定义视图作为主"

#: ../../reference/data.rst:218 ../../reference/reports.rst:46 ../../reference/views.rst:259 ../../reference/views.rst:385 ../../reference/views.rst:1156 ../../reference/views.rst:1191
msgid "``groups``"
msgstr " ``groups`` "

#: ../../reference/data.rst:219
msgid "comma-separated list of group :term:`external identifiers`"
msgstr "长期:组逗号分隔的列表 `外部identifiers` "

#: ../../reference/data.rst:221
msgid "``page``"
msgstr " ``page`` "

#: ../../reference/data.rst:221
msgid "if set to ``\"True\"``, the template is a website page (linkable to, deletable)"
msgstr "如果设置为 ``'真正的'`` , 该模板是一个网站的页面（可链接到, 可删除）"

#: ../../reference/data.rst:226
msgid "``optional``"
msgstr " ``optional`` "

#: ../../reference/data.rst:224
msgid "``enabled`` or ``disabled``, whether the view can be disabled (in the website interface) and its default status. If unset, the view is always enabled."
msgstr " ``enabled`` 或 ``disabled`` , 视图是否可以被禁用（在网站界面）和它的默认状态。如果未设置, 视图始终启用。"

#: ../../reference/data.rst:229
msgid "``report``"
msgstr " ``report`` "

#: ../../reference/data.rst:231
msgid "Creates a ``ir.actions.report.xml`` record with a few default values."
msgstr "创建一个带有一些默认值 ``ir.actions.report.xml`` 记录。"

#: ../../reference/data.rst:233
msgid "Mostly just proxies attributes to the corresponding fields on ``ir.actions.report.xml``, but also automatically creates the item in the :guilabel:`More` menu of the report's ``model``."
msgstr "大多只是委托书 ``ir.actions.report.xml`` 属性对应的字段, 而且还自动创建的项目 :guilabel:`报告的 ``model`` 的More` 菜单。"

#: ../../reference/data.rst:240
msgid "CSV data files"
msgstr "CSV数据文件"

#: ../../reference/data.rst:242
msgid "XML data files are flexible and self-descriptive, but very verbose when creating a number of simple records of the same model in bulk."
msgstr "造就了一批散装相同型号的简单记录时XML数据文件是灵活的, 自描述的, 但很冗长。"

#: ../../reference/data.rst:245
msgid "For this case, data files can also use csv_, this is often the case for :ref:`access rights <reference/security/acl>`:"
msgstr "对于这种情况, 数据文件, 也可以使用csv_, 这往往是这样的 :ref: 访问权限<reference/security/acl> ``:"

#: ../../reference/data.rst:248
msgid "the file name is :file:`{model_name}.csv`"
msgstr "该文件的名称是 :file:`{} MODEL_NAME .csv` "

#: ../../reference/data.rst:249
msgid "the first row lists the fields to write, with the special field ``id`` for :term:`external identifiers` (used for creation or update)"
msgstr "第一行列出的字段来写, 用专业的 ``id`` 为 :term:`外部identifiers` （用于创建或更新）"

#: ../../reference/data.rst:251
msgid "each row thereafter creates a new record"
msgstr "每一行之后创建一个新记录"

#: ../../reference/data.rst:253
msgid "Here's the first lines of the data file defining US states ``res.country.state.csv``"
msgstr "下面是数据文件的第一行定义美国各州 ``res.country.state.csv`` "

#: ../../reference/data.rst:260
msgid "rendered in a more readable format:"
msgstr "呈现在一个更可读的格式:"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "id"
msgstr "ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "country_id:id"
msgstr "COUNTRY_ID:ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "name"
msgstr "名字"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "code"
msgstr "代码"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_1"
msgstr "state_au_1"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "au"
msgstr "au"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Australian Capital Territory"
msgstr "澳大利亚首都直辖区"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ACT"
msgstr "ACT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_2"
msgstr "state_au_2"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New South Wales"
msgstr "新南威尔士"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NSW"
msgstr "NSW"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_3"
msgstr "state_au_3"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Northern Territory"
msgstr "北领地"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NT"
msgstr "NT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_4"
msgstr "state_au_4"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Queensland"
msgstr "昆士兰"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "QLD"
msgstr "QLD"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_5"
msgstr "state_au_5"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Australia"
msgstr "南澳大利亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SA"
msgstr "SA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_6"
msgstr "state_au_6"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Tasmania"
msgstr "塔斯马尼亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TAS"
msgstr "TAS"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_7"
msgstr "state_au_7"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Victoria"
msgstr "维多利亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VIC"
msgstr "VIC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_au_8"
msgstr "state_au_8"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Western Australia"
msgstr "西澳大利亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WA"
msgstr "WA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_1"
msgstr "state_us_1"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "us"
msgstr "us"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Alabama"
msgstr "阿拉巴马州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AL"
msgstr "AL"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_2"
msgstr "state_us_2"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Alaska"
msgstr "阿拉斯加州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AK"
msgstr "AK"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_3"
msgstr "state_us_3"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Arizona"
msgstr "亚利桑那"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AZ"
msgstr "AZ"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_4"
msgstr "state_us_4"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Arkansas"
msgstr "阿肯色州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "AR"
msgstr "AR"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_5"
msgstr "state_us_5"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "California"
msgstr "加利福尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CA"
msgstr "CA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_6"
msgstr "state_us_6"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Colorado"
msgstr "科罗拉多州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CO"
msgstr "CO"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_7"
msgstr "state_us_7"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Connecticut"
msgstr "康涅狄格"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "CT"
msgstr "CT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_8"
msgstr "state_us_8"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Delaware"
msgstr "特拉华州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "DE"
msgstr "DE"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_9"
msgstr "state_us_9"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "District of Columbia"
msgstr "哥伦比亚区"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "DC"
msgstr "DC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_10"
msgstr "state_us_10"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Florida"
msgstr "佛罗里达"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "FL"
msgstr "佛罗里达州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_11"
msgstr "state_us_11"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Georgia"
msgstr "格鲁吉亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "GA"
msgstr "GA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_12"
msgstr "state_us_12"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Hawaii"
msgstr "夏威夷"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "HI"
msgstr "HI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_13"
msgstr "state_us_13"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Idaho"
msgstr "爱达荷州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ID"
msgstr "ID"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_14"
msgstr "state_us_14"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Illinois"
msgstr "伊利诺伊"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IL"
msgstr "IL"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_15"
msgstr "state_us_15"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Indiana"
msgstr "印地安那"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IN"
msgstr "IN"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_16"
msgstr "state_us_16"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Iowa"
msgstr "爱荷华州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "IA"
msgstr "IA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_17"
msgstr "state_us_17"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Kansas"
msgstr "堪萨斯州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "KS"
msgstr "KS"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_18"
msgstr "state_us_18"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Kentucky"
msgstr "肯塔基州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "KY"
msgstr "KY"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_19"
msgstr "state_us_19"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Louisiana"
msgstr "路易斯安那州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "LA"
msgstr "LA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_20"
msgstr "state_us_20"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Maine"
msgstr "缅因"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ME"
msgstr "ME"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_21"
msgstr "state_us_21"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Montana"
msgstr "蒙大拿"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MT"
msgstr "MT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_22"
msgstr "state_us_22"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Nebraska"
msgstr "内布拉斯加"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NE"
msgstr "NE"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_23"
msgstr "state_us_23"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Nevada"
msgstr "内华达"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NV"
msgstr "NV"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_24"
msgstr "state_us_24"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Hampshire"
msgstr "新罕布什尔"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NH"
msgstr "NH"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_25"
msgstr "state_us_25"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Jersey"
msgstr "新泽西州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NJ"
msgstr "NJ"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_26"
msgstr "state_us_26"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New Mexico"
msgstr "新墨西哥"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NM"
msgstr "NM"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_27"
msgstr "state_us_27"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "New York"
msgstr "纽约"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NY"
msgstr "NY"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_28"
msgstr "state_us_28"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "North Carolina"
msgstr "北卡罗来纳"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "NC"
msgstr "NC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_29"
msgstr "state_us_29"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "North Dakota"
msgstr "北达科他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "ND"
msgstr "ND"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_30"
msgstr "state_us_30"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Ohio"
msgstr "俄亥俄"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OH"
msgstr "OH"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_31"
msgstr "state_us_31"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Oklahoma"
msgstr "俄克拉何马州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OK"
msgstr "OK"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_32"
msgstr "state_us_32"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Oregon"
msgstr "俄勒冈"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "OR"
msgstr "OR"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_33"
msgstr "state_us_33"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Maryland"
msgstr "马里兰"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MD"
msgstr "MD"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_34"
msgstr "state_us_34"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Massachusetts"
msgstr "马萨诸塞州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MA"
msgstr "MA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_35"
msgstr "state_us_35"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Michigan"
msgstr "密歇根"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MI"
msgstr "MI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_36"
msgstr "state_us_36"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Minnesota"
msgstr "明尼苏达州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MN"
msgstr "MN"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_37"
msgstr "state_us_37"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Mississippi"
msgstr "密西西比"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MS"
msgstr "MS"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_38"
msgstr "state_us_38"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Missouri"
msgstr "密苏里州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "MO"
msgstr "MO"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_39"
msgstr "state_us_39"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Pennsylvania"
msgstr "宾夕法尼亚"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "PA"
msgstr "PA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_40"
msgstr "state_us_40"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Rhode Island"
msgstr "罗德岛"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "RI"
msgstr "RI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_41"
msgstr "state_us_41"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Carolina"
msgstr "南卡罗来纳"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SC"
msgstr "SC"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_42"
msgstr "state_us_42"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "South Dakota"
msgstr "南达科他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "SD"
msgstr "SD"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_43"
msgstr "state_us_43"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Tennessee"
msgstr "田纳西"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TN"
msgstr "TN"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_44"
msgstr "state_us_44"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Texas"
msgstr "得克萨斯州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "TX"
msgstr "TX"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_45"
msgstr "state_us_45"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Utah"
msgstr "犹他州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "UT"
msgstr "UT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_46"
msgstr "state_us_46"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Vermont"
msgstr "佛蒙特"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VT"
msgstr "VT"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_47"
msgstr "state_us_47"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Virginia"
msgstr "弗吉尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "VA"
msgstr "VA"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_48"
msgstr "state_us_48"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Washington"
msgstr "华盛顿"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_49"
msgstr "state_us_49"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "West Virginia"
msgstr "西弗吉尼亚州"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WV"
msgstr "WV"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_50"
msgstr "state_us_50"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Wisconsin"
msgstr "威斯康星"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WI"
msgstr "WI"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "state_us_51"
msgstr "state_us_51"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "Wyoming"
msgstr "怀俄明"

#: ../../../openerp/addons/base/res/res.country.state.csv:1
msgid "WY"
msgstr "WY"

#: ../../reference/data.rst:267
msgid "For each row (record):"
msgstr "对于每一行（记录）:"

#: ../../reference/data.rst:269
msgid "the first column is the :term:`external id` of the record to create or update"
msgstr "第一列是 :term:`记录创建或更新的外部ID` "

#: ../../reference/data.rst:271
msgid "the second column is the :term:`external id` of the country object to link to (country objects must have been defined beforehand)"
msgstr "第二列是 :term:`全国对象链接到外部ID` （国家对象必须已预先定义）"

#: ../../reference/data.rst:273
msgid "the third column is the ``name`` field for ``res.country.state``"
msgstr "第三列是 ``name`` 字段 ``res.country.state`` "

#: ../../reference/data.rst:274
msgid "the fourth column is the ``code`` field for ``res.country.state``"
msgstr "第四列是 ``code`` 字段 ``res.country.state`` "

#: ../../reference/guidelines.rst:7
msgid "Odoo Guidelines"
msgstr "Odoo指南"

#: ../../reference/guidelines.rst:9
msgid "This page introduces the new Odoo Coding Guidelines. Those aim to improve the quality of the code (e.g. better readability of source) and Odoo Apps. Indeed, proper code eases maintenance, aids debugging, lowers complexity and promotes reliability."
msgstr ""

#: ../../reference/guidelines.rst:11
msgid "These guidelines should be applied to every new module, and new developpment. These guidelines will be applied to old module **only** in case of code refactoring (migration to new API, big refactoring, ...)."
msgstr ""

#: ../../reference/guidelines.rst:15
msgid "These guidelines are written with new modules and new files in mind. When modifying existing files, the original style of the file strictly supersedes any other style guidelines. In other words, never modify existing files in order to apply these guidelines, to avoid disrupting the revision history of each line. For more details, see our `pull request guide <https://odoo.com/submit-pr>`_."
msgstr ""

#: ../../reference/guidelines.rst:22
msgid "Module structure"
msgstr "模块结构"

#: ../../reference/guidelines.rst:25
msgid "Directories"
msgstr "目录"

#: ../../reference/guidelines.rst:26
msgid "A module is organised in important directories. Those contain the business logic; having a look at them should make understand the purpose of the module."
msgstr ""

#: ../../reference/guidelines.rst:28
msgid "*data/* : demo and data xml"
msgstr "*data/* : 演示和数据 xml 文件"

#: ../../reference/guidelines.rst:29
msgid "*models/* : models definition"
msgstr "*models/* : 模型定义"

#: ../../reference/guidelines.rst:30
msgid "*controllers/* : contains controllers (HTTP routes)."
msgstr ""

#: ../../reference/guidelines.rst:31
msgid "*views/* : contains the views and templates"
msgstr "*views/* : 包含视图和模板"

#: ../../reference/guidelines.rst:32
msgid "*static/* : contains the web assets, separated into *css/, js/, img/, lib/, ...*"
msgstr "*static/* : contains the web assets, separated into *css/, js/, img/, lib/, ...*"

#: ../../reference/guidelines.rst:34
msgid "Other optional directories compose the module."
msgstr ""

#: ../../reference/guidelines.rst:36
msgid "*wizard/* : regroups the transient models (formerly *osv_memory*) and their views."
msgstr ""

#: ../../reference/guidelines.rst:37
msgid "*report/* : contains the reports (RML report **[deprecated]**, models based on SQL views (for reporting) and other complex reports). Python objects and XML views are included in this directory."
msgstr ""

#: ../../reference/guidelines.rst:38
msgid "*tests/* : contains the Python/YML tests"
msgstr ""

#: ../../reference/guidelines.rst:42
msgid "File naming"
msgstr "文件命名"

#: ../../reference/guidelines.rst:43
msgid "For *views* declarations, split backend views from (frontend) templates in 2 differents files."
msgstr "对于 *意见* 声明, 拆分后端从（前端）的2型动物文件模板的意见。"

#: ../../reference/guidelines.rst:46
msgid "For *models*, split the business logic by sets of models, in each set select a main model, this model gives its name to the set. If there is only one model, its name is the same as the module name. For each set named <main_model> the following files may be created:"
msgstr "对于 *型号* , 拆分业务逻辑通过套模型, 在每一组中选择一个主要的模式, 这一模式给它的名字集合。如果只有一个模型, 它的名字是相同的模块的名字。对于每一组名为<main_model>下列文件可以被创建:"

#: ../../reference/guidelines.rst:51
msgid ":file:`models/{<main_model>}.py`"
msgstr ":file:`models/{<main_model>} py` "

#: ../../reference/guidelines.rst:52
msgid ":file:`models/{<inherited_main_model>}.py`"
msgstr ":file:`models/{<inherited_main_model>} py` "

#: ../../reference/guidelines.rst:53
msgid ":file:`views/{<main_model>}_templates.xml`"
msgstr ":file:`views/{<main_model>} _ templates.xml` "

#: ../../reference/guidelines.rst:54
msgid ":file:`views/{<main_model>}_views.xml`"
msgstr ":file:`views/{<main_model>} _ views.xml` "

#: ../../reference/guidelines.rst:56
msgid "For instance, *sale* module introduces ``sale_order`` and ``sale_order_line`` where ``sale_order`` is dominant. So the ``<main_model>`` files will be named :file:`models/sale_order.py` and :file:`views/sale_order_views.py`."
msgstr "例如, *销售* 模块引入了 ``sale_order`` 和 ``sale_order_line`` 其中 ``sale_order`` 占主导地位。所以 ``<main_model>`` 文件将被命名为 :file:`models/sale_order.py` 和 :file:`views/sale_order_views.py` 。"

#: ../../reference/guidelines.rst:61
msgid "For *data*, split them by purpose : demo or data. The filename will be the main_model name, suffixed by *_demo.xml* or *_data.xml*."
msgstr "演示或数据:对于 *数据* , 按用途分割。文件名会是MAIN_MODEL名称, 由 * _demo.xml * 或 * _data.xml * 后缀。"

#: ../../reference/guidelines.rst:64
msgid "For *controllers*, the only file should be named *main.py*. Otherwise, if you need to inherit an existing controller from another module, its name will be *<module_name>.py*. Unlike *models*, each controller class should be contained in a separated file."
msgstr ""

#: ../../reference/guidelines.rst:66
msgid ""
"For *static files*, since the resources can be used in different contexts (frontend, backend, both), they will be included in only one bundle. So, CSS/Less, JavaScript and XML files should be suffixed with the name of the bundle type. i.e.: *im_chat_common.css*, *im_chat_common.js* for 'assets_common' bundle, and *im_chat_backend.css*, *im_chat_backend.js* for 'assets_backend' bundle. If the module owns only one file, the convention will be *<module_name>.ext* (i.e.: *project.js*). Don't link data "
"(image, libraries) outside Odoo: do not use an URL to an image but copy it in our codebase instead."
msgstr ""

#: ../../reference/guidelines.rst:71
msgid "Regarding *data*, split them by purpose: data or demo. The filename will be the *main_model* name, suffixed by *_data.xml* or *_demo.xml*."
msgstr ""

#: ../../reference/guidelines.rst:74
msgid "Regarding *wizards*, naming convention is :"
msgstr ""

#: ../../reference/guidelines.rst:76
msgid ":file:`{<main_transient>}.py`"
msgstr ""

#: ../../reference/guidelines.rst:77
msgid ":file:`{<main_transient>}_views.xml`"
msgstr ""

#: ../../reference/guidelines.rst:79
msgid "Where *<main_transient>* is the name of the dominant transient model, just like for *models*. <main_transient>.py can contains the models 'model.action' and 'model.action.line'."
msgstr ""

#: ../../reference/guidelines.rst:81
msgid "For *statistics reports*, their names should look like :"
msgstr ""

#: ../../reference/guidelines.rst:83
msgid ":file:`{<report_name_A>}_report.py`"
msgstr ""

#: ../../reference/guidelines.rst:84
msgid ":file:`{<report_name_A>}_report_views.py` (often pivot and graph views)"
msgstr ""

#: ../../reference/guidelines.rst:86
msgid "For *printable reports*, you should have :"
msgstr ""

#: ../../reference/guidelines.rst:88
msgid ":file:`{<print_report_name>}_reports.py` (report actions, paperformat definition, ...)"
msgstr ""

#: ../../reference/guidelines.rst:89
msgid ":file:`{<print_report_name>}_templates.xml` (xml report templates)"
msgstr ""

#: ../../reference/guidelines.rst:92
msgid "The complete tree should look like"
msgstr "整个树看起来应该像"

#: ../../reference/guidelines.rst:145
msgid "File names should only contain ``[a-z0-9_]`` (lowercase alphanumerics and ``_``)"
msgstr "文件名应该只包含 ``[A-Z0-9 _]`` （小写字母数字和 ``_`` ）"

#: ../../reference/guidelines.rst:148
msgid "Use correct file permissions : folder 755 and file 644."
msgstr "使用正确的文件权限:文件夹755和文件644。"

#: ../../reference/guidelines.rst:151
msgid "XML files"
msgstr "XML文件"

#: ../../reference/guidelines.rst:154
msgid "Format"
msgstr "格式"

#: ../../reference/guidelines.rst:155
msgid "To declare a record in XML, the **record** notation (using *<record>*) is recommended:"
msgstr ""

#: ../../reference/guidelines.rst:157
msgid "Place ``id`` attribute before ``model``"
msgstr "地方 ``model`` 之前 ``id`` 属性"

#: ../../reference/guidelines.rst:158
msgid "For field declaration, ``name`` attribute is first. Then place the *value* either in the ``field`` tag, either in the ``eval`` attribute, and finally other attributes (widget, options, ...) ordered by importance."
msgstr "对于现场报关, ``name`` 属性是第一位。然后把 *值* 无论是在 ``field`` 标签, 无论是在 ``eval`` 属性, 最后其他属性（挂件, 选项...）订购的重要性。"

#: ../../reference/guidelines.rst:163
msgid "Try to group the record by model. In case of dependencies between action/menu/views, this convention may not be applicable."
msgstr ""

#: ../../reference/guidelines.rst:165
msgid "Use naming convention defined at the next point"
msgstr "当时所用的下一个点定义命名规则"

#: ../../reference/guidelines.rst:166
msgid "The tag *<data>* is only used to set not-updatable data with ``noupdate=1``"
msgstr "标签 *<data>* 仅用于与 ``NOUPD​​ATE = 1`` 设置未更新数据"

#: ../../reference/guidelines.rst:182
msgid "Odoo supports custom tags acting as syntactic sugar:"
msgstr ""

#: ../../reference/guidelines.rst:184
msgid "menuitem: use it as a shortcut to declare a ``ir.ui.menu``"
msgstr ""

#: ../../reference/guidelines.rst:185
msgid "workflow: the <workflow> tag sends a signal to an existing workflow."
msgstr ""

#: ../../reference/guidelines.rst:186
msgid "template: use it to declare a QWeb View requiring only the ``arch`` section of the view."
msgstr ""

#: ../../reference/guidelines.rst:187
msgid "report: use to declare a :ref:`report action <reference/actions/report>`"
msgstr ""

#: ../../reference/guidelines.rst:188
msgid "act_window: use it if the record notation can't do what you want"
msgstr ""

#: ../../reference/guidelines.rst:190
msgid "The 4 first tags are prefered over the *record* notation."
msgstr ""

#: ../../reference/guidelines.rst:194
msgid "Naming xml_id"
msgstr "命名xml_id"

#: ../../reference/guidelines.rst:197
msgid "Security, View and Action"
msgstr "安全, 视图以及动作"

#: ../../reference/guidelines.rst:199
msgid "Use the following pattern :"
msgstr "使用下面的模式 :"

#: ../../reference/guidelines.rst:201
msgid "For a menu: :samp:`{<model_name>}_menu`"
msgstr "对于菜单 :samp:`{<model_name>} _ menu` "

#: ../../reference/guidelines.rst:202
msgid "For a view: :samp:`{<model_name>}_view_{<view_type>}`, where *view_type* is ``kanban``, ``form``, ``tree``, ``search``, ..."
msgstr "对于一个视图 :samp:`{<<model_name>>} _view_ {<view_type>}` , 其中 *的view_type * 是 ``kanban`` , ``form`` , ``tree`` , ``search`` , ..."

#: ../../reference/guidelines.rst:204
msgid "For an action: the main action respects :samp:`{<model_name>}_action`. Others are suffixed with :samp:`_{<detail>}`, where *detail* is a lowercase string briefly explaining the action. This is used only if multiple actions are declared for the model."
msgstr "对于一个动作:主操作方面 :samp:`{<model_name>}_action` 。其他人则后缀 :samp:`_ {<详细>}` , 其中 *详细* 是一个小写的字符串, 简要说明操作。这是仅用于多个动作的模式声明。"

#: ../../reference/guidelines.rst:209
msgid "For a group: :samp:`{<model_name>}_group_{<group_name>}` where *group_name* is the name of the group, generally 'user', 'manager', ..."
msgstr "对于组 :samp:`{<model_name>}_group_{<group_name>}` , 其中 *组名* 是组, 一般“用户\" , “经理 \", 的名称..."

#: ../../reference/guidelines.rst:211
msgid "For a rule: :samp:`{<model_name>}_rule_{<concerned_group>}` where *concerned_group* is the short name of the concerned group ('user' for the 'model_name_group_user', 'public' for public user, 'company' for multi-company rules, ...)."
msgstr "对于一个规则 :samp:`{<model_name>}_rule_{<concerned_group>}` , 其中 * concerned_group * 是关注组（'用户'的'model_name_group_user“的简称,\" 公开“公开的用户, \"公司多公司规定, ...）。"

#: ../../reference/guidelines.rst:215
msgid "For a group : :samp:`{<model_name>}_group_{<group_name>}` where *group_name* is the name of the group, generally 'user', 'manager', ..."
msgstr ""

#: ../../reference/guidelines.rst:265
msgid "View names use dot notation ``my.model.view_type`` or ``my.model.view_type.inherit`` instead of *\"This is the form view of My Model\"*."
msgstr "查看名称使用点符号 ``my.model.view_type`` 或 ``my.model.view_type.inherit`` , 而不是 *'这是我的模型表单视图\" * 。 "

#: ../../reference/guidelines.rst:271
msgid "Inherited XML"
msgstr "继承的XML"

#: ../../reference/guidelines.rst:273
msgid "The naming pattern of inherited view is :samp:`{<base_view>}_inherit_{<current_module_name>}`. A module may only extend a view once.  Suffix the orginal name with :samp:`_inherit_{<current_module_name>}` where *current_module_name* is the technical name of the module extending the view."
msgstr "继承视图的命名模式是 :samp:`{<base_view>} _继承_ {<current_module_name>}` 。一个模块可能只扩展视图一次。后缀原单名 :samp:`_inherit _ {<current_module_name>}` , 其中 * current_module_name * 是扩展视图模块的技术名称。"

#: ../../reference/guidelines.rst:288 ../../reference/qweb.rst:319
msgid "Python"
msgstr "Python"

#: ../../reference/guidelines.rst:291
msgid "PEP8 options"
msgstr "PEP8选项"

#: ../../reference/guidelines.rst:293
msgid "Using a linter can help show syntax and semantic warnings or errors. Odoo source code tries to respect Python standard, but some of them can be ignored."
msgstr "使用棉绒可以帮助显示语法和语义警告或错误。 Odoo源代码试图尊重Python标准, 但其中一些可以忽略不计。"

#: ../../reference/guidelines.rst:296
msgid "E501: line too long"
msgstr "E501:线太长"

#: ../../reference/guidelines.rst:297
msgid "E301: expected 1 blank line, found 0"
msgstr "E301:预计1空行, 发现0"

#: ../../reference/guidelines.rst:298
msgid "E302: expected 2 blank lines, found 1"
msgstr "E302:预计2空白行, 发现1"

#: ../../reference/guidelines.rst:299
msgid "E126: continuation line over-indented for hanging indent"
msgstr "E126:过缩进悬挂缩进续行"

#: ../../reference/guidelines.rst:300
msgid "E123: closing bracket does not match indentation of opening bracket's line"
msgstr "E123:右括号不匹配左括号的行缩进"

#: ../../reference/guidelines.rst:301
msgid "E127: continuation line over-indented for visual indent"
msgstr "E127:过缩进视觉缩进续行"

#: ../../reference/guidelines.rst:302
msgid "E128: continuation line under-indented for visual indent"
msgstr "E128:下缩进的视觉缩进续行"

#: ../../reference/guidelines.rst:303
msgid "E265: block comment should start with '# '"
msgstr "E265:块注释应该以'＃'"

#: ../../reference/guidelines.rst:306
msgid "Imports"
msgstr "引入"

#: ../../reference/guidelines.rst:307
msgid "The imports are ordered as"
msgstr "引入的顺序"

#: ../../reference/guidelines.rst:309
msgid "External libraries (one per line sorted and split in python stdlib)"
msgstr "外部库（每行一个分类和分裂PythonSTDLIB）"

#: ../../reference/guidelines.rst:310
msgid "Imports of ``odoo``"
msgstr ""

#: ../../reference/guidelines.rst:311
msgid "Imports from Odoo modules (rarely, and only if necessary)"
msgstr "从Odoo模块（很少, 只有在必要时）的进口"

#: ../../reference/guidelines.rst:313
msgid "Inside these 3 groups, the imported lines are alphabetically sorted."
msgstr "在这3组里面, 引入是按字母顺序排序的。"

#: ../../reference/guidelines.rst:333
msgid "Idiomatics Python Programming"
msgstr ""

#: ../../reference/guidelines.rst:335
msgid "Each python file should have ``# -*- coding: utf-8 -*-`` as first line."
msgstr ""

#: ../../reference/guidelines.rst:336
msgid "Always favor *readability* over *conciseness* or using the language features or idioms."
msgstr ""

#: ../../reference/guidelines.rst:337
msgid "Don't use ``.clone()``"
msgstr ""

#: ../../reference/guidelines.rst:348
msgid "Python dictionnary : creation and update"
msgstr ""

#: ../../reference/guidelines.rst:373
msgid "Use meaningful variable/class/method names"
msgstr "使用有意义的变量/类/方法名"

#: ../../reference/guidelines.rst:374
msgid "Useless variable : Temporary variables can make the code clearer by giving names to objects, but that doesn't mean you should create temporary variables all the time:"
msgstr ""

#: ../../reference/guidelines.rst:386
msgid "Multiple return points are OK, when they're simpler"
msgstr ""

#: ../../reference/guidelines.rst:406
msgid "Know your builtins : You should at least have a basic understanding of all the Python builtins (http://docs.python.org/library/functions.html)"
msgstr ""

#: ../../reference/guidelines.rst:414
msgid "Also, ``if 'key' in my_dict`` and ``if my_dict.get('key')`` have very different meaning, be sure that you're using the right one."
msgstr ""

#: ../../reference/guidelines.rst:417
msgid "Learn list comprehensions : Use list comprehension, dict comprehension, and basic manipulation using ``map``, ``filter``, ``sum``, ... They make the code easier to read."
msgstr ""

#: ../../reference/guidelines.rst:430
msgid "Collections are booleans too : In python, many objects have \"boolean-ish\" value when evaluated in a boolean context (such as an if). Among these are collections (lists, dicts, sets, ...) which are \"falsy\" when empty and \"truthy\" when containing items:"
msgstr ""

#: ../../reference/guidelines.rst:441
msgid "So, you can write ``if some_collection:`` instead of ``if len(some_collection):``."
msgstr ""

#: ../../reference/guidelines.rst:444
msgid "Iterate on iterables"
msgstr ""

#: ../../reference/guidelines.rst:461
msgid "Use dict.setdefault"
msgstr ""

#: ../../reference/guidelines.rst:477
msgid "As a good developper, document your code (docstring on methods, simple comments for tricky part of code)"
msgstr ""

#: ../../reference/guidelines.rst:479
msgid "In additions to these guidelines, you may also find the following link interesting: http://python.net/~goodger/projects/pycon/2007/idiomatic/handout.html (a little bit outdated, but quite relevant)"
msgstr ""

#: ../../reference/guidelines.rst:484
msgid "Programming in Odoo"
msgstr ""

#: ../../reference/guidelines.rst:486
msgid "Avoid to create generators and decorators: only use the ones provided by the Odoo API."
msgstr ""

#: ../../reference/guidelines.rst:488
msgid "As in python, use ``filtered``, ``mapped``, ``sorted``, ... methods to ease code reading and performance."
msgstr ""

#: ../../reference/guidelines.rst:493
msgid "Make your method works in batch"
msgstr ""

#: ../../reference/guidelines.rst:494
msgid "When adding a function, make sure it can process multiple records. Typically, such method is decorated with ``api.multi`` decorator (or takes a list of *id*, if written in old api). Then you will have to iterate on ``self`` to treat each record."
msgstr ""

#: ../../reference/guidelines.rst:506
msgid "Avoid to use ``api.one``  decorator : this will probably not do what you expected, and extending a such method is not as easy than a *api.multi* method, since it returns a list of result (ordered by recordset ids)."
msgstr ""

#: ../../reference/guidelines.rst:510
msgid "For performance issue, when developping a 'stat button' (for instance), do not perform a ``search`` or a ``search_count`` in a loop in a ``api.multi`` method. It is recommended to use ``read_group`` method, to compute all value in only one request."
msgstr ""

#: ../../reference/guidelines.rst:526
msgid "Propagate the context"
msgstr ""

#: ../../reference/guidelines.rst:527
msgid "In new API, the context is a ``frozendict`` that cannot be modified. To call a method with a different context, the ``with_context`` method should be used :"
msgstr ""

#: ../../reference/guidelines.rst:535
msgid "Passing parameter in context can have dangerous side-effects. Since the values are propagated automatically, some behavior can appears. Calling ``create()`` method of a model with *default_my_field* key in context will set the default value of *my_field* for the concerned model. But if curing this creation, other object (such as sale.order.line, on sale.order creation) having a field name *my_field*, their default value will be set too."
msgstr ""

#: ../../reference/guidelines.rst:542
msgid "If you need to create a key context influencing the behavior of some object, choice a good name, and eventually prefix it by the name of the module to isolate its impact. A good example are the keys of ``mail`` module : *mail_create_nosubscribe*, *mail_notrack*, *mail_notify_user_signature*, ..."
msgstr ""

#: ../../reference/guidelines.rst:549
msgid "Do not bypass the ORM"
msgstr ""

#: ../../reference/guidelines.rst:550
msgid "You should never use the database cursor directly when the ORM can do the same thing! By doing so you are bypassing all the ORM features, possibly the transactions, access rights and so on."
msgstr ""

#: ../../reference/guidelines.rst:554
msgid "And chances are that you are also making the code harder to read and probably less secure."
msgstr ""

#: ../../reference/guidelines.rst:573
msgid "No SQL injections, please !"
msgstr ""

#: ../../reference/guidelines.rst:574
msgid "Care must be taken not to introduce SQL injections vulnerabilities when using manual SQL queries. The vulnerability is present when user input is either incorrectly filtered or badly quoted, allowing an attacker to introduce undesirable clauses to a SQL query (such as circumventing filters or executing UPDATE or DELETE commands)."
msgstr ""

#: ../../reference/guidelines.rst:580
msgid "The best way to be safe is to never, NEVER use Python string concatenation (+) or string parameters interpolation (%) to pass variables to a SQL query string."
msgstr ""

#: ../../reference/guidelines.rst:583
msgid "The second reason, which is almost as important, is that it is the job of the database abstraction layer (psycopg2) to decide how to format query parameters, not your job! For example psycopg2 knows that when you pass a list of values it needs to format them as a comma-separated list, enclosed in parentheses !"
msgstr ""

#: ../../reference/guidelines.rst:603
msgid "This is very important, so please be careful also when refactoring, and most importantly do not copy these patterns!"
msgstr ""

#: ../../reference/guidelines.rst:606
msgid "Here is a memorable example to help you remember what the issue is about (but do not copy the code there). Before continuing, please be sure to read the online documentation of pyscopg2 to learn of to use it properly:"
msgstr ""

#: ../../reference/guidelines.rst:610
msgid "The problem with query parameters (http://initd.org/psycopg/docs/usage.html#the-problem-with-the-query-parameters)"
msgstr ""

#: ../../reference/guidelines.rst:611
msgid "How to pass parameters with psycopg2 (http://initd.org/psycopg/docs/usage.html#passing-parameters-to-sql-queries)"
msgstr ""

#: ../../reference/guidelines.rst:612
msgid "Advanced parameter types (http://initd.org/psycopg/docs/usage.html#adaptation-of-python-values-to-sql-types)"
msgstr ""

#: ../../reference/guidelines.rst:616
msgid "Keep your methods short/simple when possible"
msgstr ""

#: ../../reference/guidelines.rst:617
msgid "Functions and methods should not contain too much logic: having a lot of small and simple methods is more advisable than having few large and complex methods. A good rule of thumb is to split a method as soon as: - it has more than one responsibility (see http://en.wikipedia.org/wiki/Single_responsibility_principle) - it is too big to fit on one screen."
msgstr ""

#: ../../reference/guidelines.rst:623
msgid "Also, name your functions accordingly: small and properly named functions are the starting point of readable/maintainable code and tighter documentation."
msgstr ""

#: ../../reference/guidelines.rst:625
msgid "This recommendation is also relevant for classes, files, modules and packages. (See also http://en.wikipedia.org/wiki/Cyclomatic_complexity)"
msgstr ""

#: ../../reference/guidelines.rst:629
msgid "Never commit the transaction"
msgstr "从未提交翻译"

#: ../../reference/guidelines.rst:630
msgid "The Odoo framework is in charge of providing the transactional context for all RPC calls. The principle is that a new database cursor is opened at the beginning of each RPC call, and committed when the call has returned, just before transmitting the answer to the RPC client, approximately like this:"
msgstr ""

#: ../../reference/guidelines.rst:651
msgid "If any error occurs during the execution of the RPC call, the transaction is rolled back atomically, preserving the state of the system."
msgstr ""

#: ../../reference/guidelines.rst:654
msgid "Similarly, the system also provides a dedicated transaction during the execution of tests suites, so it can be rolled back or not depending on the server startup options."
msgstr ""

#: ../../reference/guidelines.rst:658
msgid "The consequence is that if you manually call ``cr.commit()`` anywhere there is a very high chance that you will break the system in various ways, because you will cause partial commits, and thus partial and unclean rollbacks, causing among others:"
msgstr ""

#: ../../reference/guidelines.rst:663
msgid "inconsistent business data, usually data loss"
msgstr ""

#: ../../reference/guidelines.rst:664
msgid "workflow desynchronization, documents stuck permanently"
msgstr ""

#: ../../reference/guidelines.rst:665
msgid "tests that can't be rolled back cleanly, and will start polluting the database, and triggering error (this is true even if no error occurs during the transaction)"
msgstr ""

#: ../../reference/guidelines.rst:676
msgid "Here is the very simple rule:"
msgstr ""

#: ../../reference/guidelines.rst:670
msgid "You should **NEVER** call ``cr.commit()`` yourself, **UNLESS** you have created your own database cursor explicitly! And the situations where you need to do that are exceptional!"
msgstr ""

#: ../../reference/guidelines.rst:674
msgid "And by the way if you did create your own cursor, then you need to handle error cases and proper rollback, as well as properly close the cursor when you're done with it."
msgstr ""

#: ../../reference/guidelines.rst:678
msgid ""
"And contrary to popular belief, you do not even need to call ``cr.commit()`` in the following situations: - in the ``_auto_init()`` method of an *models.Model* object: this is taken care of by the addons initialization method, or by the ORM transaction when creating custom models - in reports: the ``commit()`` is handled by the framework too, so you can update the database even from within a report - within *models.Transient* methods: these methods are called exactly like regular *models.Model* ones, "
"within a transaction and with the corresponding ``cr.commit()/rollback()`` at the end - etc. (see general rule above if you have in doubt!)"
msgstr ""

#: ../../reference/guidelines.rst:690
msgid "All ``cr.commit()`` calls outside of the server framework from now on must have an **explicit comment** explaining why they are absolutely necessary, why they are indeed correct, and why they do not break the transactions. Otherwise they can and will be removed !"
msgstr ""

#: ../../reference/guidelines.rst:697
msgid "Use translation method correctly"
msgstr "正确的使用翻译方法"

#: ../../reference/guidelines.rst:699
msgid "Odoo uses a GetText-like method named \"underscore\" ``_( )`` to indicate that a static string used in the code needs to be translated at runtime using the language of the context. This pseudo-method is accessed within your code by importing as follows:"
msgstr ""

#: ../../reference/guidelines.rst:708
msgid "A few very important rules must be followed when using it, in order for it to work and to avoid filling the translations with useless junk."
msgstr ""

#: ../../reference/guidelines.rst:711
msgid "Basically, this method should only be used for static strings written manually in the code, it will not work to translate field values, such as Product names, etc. This must be done instead using the translate flag on the corresponding field."
msgstr ""

#: ../../reference/guidelines.rst:716
msgid "The rule is very simple: calls to the underscore method should always be in the form ``_('literal string')`` and nothing else:"
msgstr ""

#: ../../reference/guidelines.rst:760
msgid "Also, keep in mind that translators will have to work with the literal values that are passed to the underscore function, so please try to make them easy to understand and keep spurious characters and formatting to a minimum. Translators must be aware that formatting patterns such as %s or %d, newlines, etc. need to be preserved, but it's important to use these in a sensible and obvious manner:"
msgstr ""

#: ../../reference/guidelines.rst:775
msgid "In general in Odoo, when manipulating strings, prefer ``%`` over ``.format()`` (when only one variable to replace in a string), and prefer ``%(varname)`` instead of position (when multiple variables have to be replaced). This makes the translation easier for the community translators."
msgstr ""

#: ../../reference/guidelines.rst:782
msgid "Symbols and Conventions"
msgstr "符号和约定"

#: ../../reference/guidelines.rst:792
msgid "Model name (using the dot notation, prefix by the module name) :"
msgstr ""

#: ../../reference/guidelines.rst:785
msgid "When defining an Odoo Model : use singular form of the name (*res.partner* and *sale.order* instead of *res.partnerS* and *saleS.orderS*)"
msgstr ""

#: ../../reference/guidelines.rst:787
msgid "When defining an Odoo Transient (wizard) : use ``<related_base_model>.<action>`` where *related_base_model* is the base model (defined in *models/*) related to the transient, and *action* is the short name of what the transient do. For instance : ``account.invoice.make``, ``project.task.delegate.batch``, ..."
msgstr ""

#: ../../reference/guidelines.rst:791
msgid "When defining *report* model (SQL views e.i.) : use ``<related_base_model>.report.<action>``, based on the Transient convention."
msgstr ""

#: ../../reference/guidelines.rst:794
msgid "Odoo Python Class : use camelcase for code in api v8 (Object-oriented style), underscore lowercase notation for old api (SQL style)."
msgstr ""

#: ../../reference/guidelines.rst:811
msgid "Variable name :"
msgstr "变量名:"

#: ../../reference/guidelines.rst:807
msgid "use camelcase for model variable"
msgstr "使用大小写混合的模型变量"

#: ../../reference/guidelines.rst:808
msgid "use underscore lowercase notation for common variable."
msgstr "用下划线为普通变量小写符号。"

#: ../../reference/guidelines.rst:809
msgid "since new API works with record or recordset instead of id list, don't suffix variable name with *_id* or *_ids* if they not contain id or list of id."
msgstr "因为新的API, 可与记录或记录, 而不是ID列表, 没有后缀的变量名 * _id * 或 * _ids * 如果他们不包含ID或ID的列表。"

#: ../../reference/guidelines.rst:819
msgid "``One2Many`` and ``Many2Many`` fields should always have *_ids* as suffix (example: sale_order_line_ids)"
msgstr " ``One2Many`` 和 ``Many2Many`` 字段应该始终有 * _ids * 作为后缀（例如:sale_order_line_ids）"

#: ../../reference/guidelines.rst:820
msgid "``Many2One`` fields should have *_id* as suffix (example : partner_id, user_id, ...)"
msgstr " ``Many2One`` 字段应该有 * _id * 作为后缀（例如:partner_id, USER_ID, ...）"

#: ../../reference/guidelines.rst:829
msgid "Method conventions"
msgstr "方法约定"

#: ../../reference/guidelines.rst:822
msgid "Compute Field : the compute method pattern is *_compute_<field_name>*"
msgstr "计算字段:计算方法模式是 *_compute_<field_name>*"

#: ../../reference/guidelines.rst:823
msgid "Search method : the search method pattern is *_search_<field_name>*"
msgstr "搜索方法:搜索方法模式是 *_search_<field_name>*"

#: ../../reference/guidelines.rst:824
msgid "Default method : the default method pattern is *_default_<field_name>*"
msgstr "默认的方法:默认的方法模式是 *_default_<field_name>*"

#: ../../reference/guidelines.rst:825
msgid "Onchange method : the onchange method pattern is *_onchange_<field_name>*"
msgstr "onchange的方法:中为onchange方法模式是 *_onchange_<field_name>*"

#: ../../reference/guidelines.rst:826
msgid "Constraint method : the constraint method pattern is *_check_<constraint_name>*"
msgstr "约束方法:约束方法模式是 *_check_<constraint_name>*"

#: ../../reference/guidelines.rst:827
msgid "Action method : an object action method is prefix with *action_*. Its decorator is ``@api.multi``, but since it use only one record, add ``self.ensure_one()`` at the beginning of the method."
msgstr "操作方法:一个对象操作方法是前缀 * action_ * 。它的装饰是 ``@ api.multi`` , 但由于它仅使用一条记录, 添加 ``self.ensure_one（）`` 在方法的开始。"

#: ../../reference/guidelines.rst:839
msgid "In a Model attribute order should be"
msgstr "模型中的属性顺序应该是"

#: ../../reference/guidelines.rst:832
msgid "Private attributes (``_name``, ``_description``, ``_inherit``, ...)"
msgstr "私有属性 ( ``_name`` , ``_description`` , ``_inherit`` , ...)"

#: ../../reference/guidelines.rst:833
msgid "Default method and ``_default_get``"
msgstr "默认的方法和 ``_default_get`` "

#: ../../reference/guidelines.rst:834
msgid "Field declarations"
msgstr "字段声明"

#: ../../reference/guidelines.rst:835
msgid "Compute and search methods in the same order as field declaration"
msgstr "计算和搜索方法, 顺序相同域声明"

#: ../../reference/guidelines.rst:836
msgid "Constrains methods (``@api.constrains``) and onchange methods (``@api.onchange``)"
msgstr "约束方法（ ``@ api.constrains`` ）和onchange的方法（ ``@ api.onchange`` ）"

#: ../../reference/guidelines.rst:837
msgid "CRUD methods (ORM overrides)"
msgstr "CRUD方法（ORM覆盖）"

#: ../../reference/guidelines.rst:838
msgid "Action methods"
msgstr "动作方法"

#: ../../reference/guidelines.rst:839
msgid "And finally, other business methods."
msgstr "最后, 其他的业务方法。"

#: ../../reference/guidelines.rst:891
msgid "Javascript and CSS"
msgstr "JavaScript和CSS"

#: ../../reference/guidelines.rst:892
msgid "**For javascript :**"
msgstr " **为Javascript:** "

#: ../../reference/guidelines.rst:894
msgid "``use strict;`` is recommended for all javascript files"
msgstr " ``使用严格的;`` 建议所有的JavaScript文件"

#: ../../reference/guidelines.rst:895
msgid "Use a linter (jshint, ...)"
msgstr "使用提示器 (jshint, ...)"

#: ../../reference/guidelines.rst:896
msgid "Never add minified Javascript Libraries"
msgstr "切勿将缩小的JavaScript库"

#: ../../reference/guidelines.rst:897
msgid "Use camelcase for class declaration"
msgstr "使用大小写混合的类声明"

#: ../../reference/guidelines.rst:898
msgid "Unless your code is supposed to run on every page, target specific pages using the ``if_dom_contains`` function of website module. Target an element which is specific to the pages your code needs to run on using JQuery."
msgstr ""

#: ../../reference/guidelines.rst:910
msgid "**For CSS :**"
msgstr " **对于CSS:** "

#: ../../reference/guidelines.rst:912
msgid "Prefix all your classes with *o_<module_name>* where *module_name* is the technical name of the module ('sale', 'im_chat', ...) or the main route reserved by the module (for website module mainly, i.e. : 'o_forum' for *website_forum* module). The only exception for this rule is the webclient: it simply uses *o_* prefix."
msgstr ""

#: ../../reference/guidelines.rst:917
msgid "Avoid using id"
msgstr "避免使用ID"

#: ../../reference/guidelines.rst:918
msgid "Use Bootstrap native classes"
msgstr ""

#: ../../reference/guidelines.rst:919
msgid "Use underscore lowercase notation to name class"
msgstr "使用下划线小写符号来命名类"

#: ../../reference/guidelines.rst:922
msgid "Git"
msgstr "git"

#: ../../reference/guidelines.rst:925
msgid "Commit message"
msgstr "提交信息"

#: ../../reference/guidelines.rst:927
msgid "Prefix your commit with"
msgstr "使用前缀"

#: ../../reference/guidelines.rst:929
msgid "**[IMP]** for improvements"
msgstr " **[IMP]** 改善"

#: ../../reference/guidelines.rst:930
msgid "**[FIX]** for bug fixes"
msgstr " **[FIX]** bug修复"

#: ../../reference/guidelines.rst:931
msgid "**[REF]** for refactoring"
msgstr " **[REF]** 重构"

#: ../../reference/guidelines.rst:932
msgid "**[ADD]** for adding new resources"
msgstr " **[ADD]** 添加新资源"

#: ../../reference/guidelines.rst:933
msgid "**[REM]** for removing of resources"
msgstr " **[REM]** 去除资源"

#: ../../reference/guidelines.rst:934
msgid "**[MOV]** for moving files (Do not change content of moved file, otherwise Git will loose track, and the history will be lost !), or simply moving code from a file to another one."
msgstr ""

#: ../../reference/guidelines.rst:937
msgid "**[MERGE]** for merge commits (only for forward/back-port)"
msgstr " **[MERGE]** 合并提交（仅适用于前进/后退端口）"

#: ../../reference/guidelines.rst:938
msgid "**[CLA]** for signing the Odoo Individual Contributor License"
msgstr " **[CLA]** 签署的Odoo独立贡献者许可"

#: ../../reference/guidelines.rst:940
msgid "Then, in the message itself, specify the part of the code impacted by your changes (module name, lib, transversal object, ...) and a description of the changes."
msgstr "然后, 消息本身, 指定由您的更改（模块名称, lib下, 横向的对象, ...）和变化的描述影响的代码的一部分。"

#: ../../reference/guidelines.rst:944
msgid "Always include a meaningful commit message: it should be self explanatory (long enough) including the name of the module that has been changed and the reason behind the change. Do not use single words like \"bugfix\" or \"improvements\"."
msgstr "始终有一个有意义的提交信息:它应该是不言而喻的（足够长）, 其中包括已被更改模块的名称和变化背后的原因。不要使用单个词汇, 如'错误修正'或'进步'。"

#: ../../reference/guidelines.rst:948
msgid "Avoid commits which simultaneously impact multiple modules. Try to split into different commits where impacted modules are different (It will be helpful if we need to revert a module separately)."
msgstr "不要提交它同时影响多个模块。尝试拆分成不同的提交, 其中受影响的模块是不同的（这将是有益的, 如果我们需要分别恢复模块）。"

#: ../../reference/guidelines.rst:969
msgid "Use the long description to explain the *why* not the *what*, the *what* can be seen in the diff"
msgstr "使用长的描述来解释为什么 **不 *什么* 中, *什么* 可以在差异中可见"

#: ../../reference/http.rst:5
msgid "Web Controllers"
msgstr "Web控制器"

#: ../../reference/http.rst:10
msgid "Routing"
msgstr "路由"

#: ../../reference/http.rst:17
msgid "Request"
msgstr "请求"

#: ../../reference/http.rst:19
msgid "The request object is automatically set on :data:`openerp.http.request` at the start of the request"
msgstr "请求对象就自动设置在 :data:`openerp.http.request` 在请求开始的时候"

#: ../../reference/http.rst:31
msgid "Response"
msgstr "响应"

#: ../../reference/http.rst:44
msgid "Controllers"
msgstr "控制器"

#: ../../reference/http.rst:46
msgid "Controllers need to provide extensibility, much like :class:`~openerp.models.Model`, but can't use the same mechanism as the pre-requisites (a database with loaded modules) may not be available yet (e.g. no database created, or no database selected)."
msgstr "控制器需要提供可扩展性, 很像 :class:`~openerp.models.Model` , 但不能使用相同的机制为先决条件（与加载的模块数据库）可能无法使用, 但（如没有数据库创建或者没有数据库选择）。"

#: ../../reference/http.rst:51
msgid "Controllers thus provide their own extension mechanism, separate from that of models:"
msgstr "控制器从而提供自己的扩展机制, 独立于模型:"

#: ../../reference/http.rst:54
msgid "Controllers are created by :ref:`inheriting <python:tut-inheritance>` from"
msgstr "Controllers are created by :ref:`inheriting <python :tut-inheritance>` from"

#: ../../reference/http.rst:58
msgid "and defining methods decorated with :func:`~openerp.http.route`::"
msgstr "和定义方法装饰有 :func:`~openerp.http.route` ::"

#: ../../reference/http.rst:65
msgid "To *override* a controller, :ref:`inherit <python:tut-inheritance>` from its class and override relevant methods, re-exposing them if necessary::"
msgstr "To *override* a controller, :ref:`inherit <python :tut-inheritance>` from its class and override relevant methods, re-exposing them if necessary: :"

#: ../../reference/http.rst:74
msgid "decorating with :func:`~openerp.http.route` is necessary to keep the method (and route) visible: if the method is redefined without decorating, it will be \"unpublished\""
msgstr "装潢用 :func:`~openerp.http.route` 是需要保持方法（和航线）可见:如果该方法被重新定义, 而不装潢, 将'未发表'"

#: ../../reference/http.rst:77
msgid "the decorators of all methods are combined, if the overriding method's decorator has no argument all previous ones will be kept, any provided argument will override previously defined ones e.g.::"
msgstr "所有方法的装饰相结合, 如果上位法的装饰没有参数所有以前的将被保留, 任何提供的参数将替代先前定义的人, 例如 ::"

#: ../../reference/http.rst:86
msgid "will change ``/some_url`` from public authentication to user (requiring a log-in)"
msgstr "将来自于公共验证更改 ``/ some_url`` 用户（需要登录）"

#: ../../reference/javascript.rst:9 ../../reference/qweb.rst:418
msgid "Javascript"
msgstr "Javascript"

#: ../../reference/javascript.rst:12
msgid "Widgets"
msgstr "挂件"

#: ../../reference/javascript.rst:16
msgid "Exported in ``web.Widget``, the base class for all visual components. It corresponds to an MVC view, and provides a number of service to simplify handling of a section of a page:"
msgstr "在出口 ``web.Widget`` , 所有可视组件的基类。它对应于MVC视图, 并提供了许多服务来简化一个网页的部分的处理:"

#: ../../reference/javascript.rst:20
msgid "Handles parent/child relationships between widgets"
msgstr "手柄部件之间的父/子关系"

#: ../../reference/javascript.rst:21
msgid "Provides extensive lifecycle management with safety features (e.g. automatically destroying children widgets during the destruction of a parent)"
msgstr "提供广泛的生命周期管理与安全功能（如自动摧毁孩子父母的破坏过程部件）"

#: ../../reference/javascript.rst:24
msgid "Automatic rendering with :ref:`qweb <reference/qweb>`"
msgstr "自动渲染有 :ref:`qweb <reference/qweb>` "

#: ../../reference/javascript.rst:25
msgid "Backbone-compatible shortcuts"
msgstr "Backbone兼容的捷径"

#: ../../reference/javascript.rst:28
msgid "DOM Root"
msgstr "DOM根"

#: ../../reference/javascript.rst:30
msgid "A :class:`~Widget` is responsible for a section of the page materialized by the DOM root of the widget."
msgstr "答 :class:`~Widget` 负责物化小部件的DOM根页面的一部分。"

#: ../../reference/javascript.rst:33
msgid "A widget's DOM root is available via two attributes:"
msgstr "小部件的DOM根通过两个属性可用:"

#: ../../reference/javascript.rst:37
msgid "raw DOM element set as root to the widget"
msgstr "设置为根小部件的原始DOM元素"

#: ../../reference/javascript.rst:41
msgid "jQuery wrapper around :attr:`~Widget.el`"
msgstr "jQuery的包装器 :attr:`~Widget.el` "

#: ../../reference/javascript.rst:43
msgid "There are two main ways to define and generate this DOM root:"
msgstr "有定义和生成此根DOM主要有两种方法:"

#: ../../reference/javascript.rst:47
msgid "Should be set to the name of a :ref:`QWeb template <reference/qweb>`. If set, the template will be rendered after the widget has been initialized but before it has been started. The root element generated by the template will be set as the DOM root of the widget."
msgstr "应设置为一个名字 :ref:`QWeb模板<reference/qweb>` 。如果设置, 该模板将被渲染的插件已初始化之后, 但它已被启动之前。由模板产生的根元素将被设置为小部件的DOM的根。"

#: ../../reference/javascript.rst:54
msgid "Used if the widget has no template defined. Defaults to ``div``, will be used as the tag name to create the DOM element to set as the widget's DOM root. It is possible to further customize this generated DOM root with the following attributes:"
msgstr "如果使用的部件没有定义的模板。默认为 ``div`` , 将被用来作为变量名称来创建DOM元素设置为小部件的DOM根。它可以进一步自主生成的DOM根具有以下属性:"

#: ../../reference/javascript.rst:61
msgid "Used to generate an ``id`` attribute on the generated DOM root."
msgstr "用于生成所产生的DOM根的 ``id`` 属性。"

#: ../../reference/javascript.rst:66
msgid "Used to generate a ``class`` attribute on the generated DOM root."
msgstr "用于生成生成的DOM根 ``class`` 属性。"

#: ../../reference/javascript.rst:70
msgid "Mapping (object literal) of attribute names to attribute values. Each of these k:v pairs will be set as a DOM attribute on the generated DOM root."
msgstr "属性名称映射（对象文本）, 以属性值。每个这k个权:v对将被设置为对所生成的DOM根一个DOM属性。"

#: ../../reference/javascript.rst:74
msgid "None of these is used in case a template is specified on the widget."
msgstr "所有这些情况下使用一个模板上的插件指定。"

#: ../../reference/javascript.rst:76
msgid "The DOM root can also be defined programmatically by overridding"
msgstr "DOM的根也可以通过overridding编程定义"

#: ../../reference/javascript.rst:80
msgid "Renders the widget's DOM root and sets it. The default implementation will render a set template or generate an element as described above, and will call :func:`~Widget.setElement` on the result."
msgstr "呈现小部件的DOM根, 并设置它。默认的实现将呈现一组模板或如上所述生成的元素, 并会拨打 :func:`~Widget.setElement` 的结果。"

#: ../../reference/javascript.rst:85
msgid "Any override to :func:`~Widget.renderElement` which does not call its ``_super`` **must** call :func:`~Widget.setElement` with whatever it generated or the widget's behavior is undefined."
msgstr "任何覆盖到 :func:`~Widget.renderElement` 不调用它的 ``_super`` **必须** 电话 :func: 有什么它产生或控件的行为是不确定的 `~Widget.setElement` 。"

#: ../../reference/javascript.rst:92
msgid "The default :func:`~Widget.renderElement` can be called repeatedly, it will *replace* the previous DOM root (using ``replaceWith``). However, this requires that the widget correctly sets and unsets its events (and children widgets). Generally, :func:`~Widget.renderElement` should not be called repeatedly unless the widget advertizes this feature."
msgstr "默认 :func:`~Widget.renderElement` 可以反复调用, 它将取代 **先前的DOM根（使用 ``replaceWith`` ）。然而, 这要求微件正确设置和取消设置其事件（孩子和挂件）。通常情况下, :func:`~Widget.renderElement` 不应该被重复调用, 除非小部件advertizes此功能。"

#: ../../reference/javascript.rst:100
msgid "Using a widget"
msgstr "使用挂件"

#: ../../reference/javascript.rst:102
msgid "A widget's lifecycle has 3 main phases:"
msgstr "小部件的生命周期有3个主要阶段:"

#: ../../reference/javascript.rst:104
msgid "creation and initialization of the widget instance"
msgstr "创建和小部件的实例的初始化"

#: ../../reference/javascript.rst:108
msgid "initialization method of widgets, synchronous, can be overridden to take more parameters from the widget's creator/parent"
msgstr "挂件, 同步的初始化方法, 可以覆盖从挂件的创建者/家长需要更多的参数"

#: ../../reference/javascript.rst:111
msgid "the new widget's parent, used to handle automatic destruction and event propagation. Can be ``null`` for the widget to have no parent."
msgstr "新的小部件的父, 用来处理自动销毁和事件传播。可 ``null`` 以供小窗口没有父。"

#: ../../reference/javascript.rst:116
msgid "DOM injection and startup, this is done by calling one of:"
msgstr "DOM注入和启动, 这样做是通过调用之一:"

#: ../../reference/javascript.rst:120
msgid "Renders the widget and inserts it as the last child of the target, uses `.appendTo()`_"
msgstr "呈现小部件, 并将其插入作为目标的最后一个孩子, 使用 `.appendTo（）` _"

#: ../../reference/javascript.rst:125
msgid "Renders the widget and inserts it as the first child of the target, uses `.prependTo()`_"
msgstr "呈现小部件, 并将其插入为目标的第一个孩子, 使用 `.prependTo（）` _"

#: ../../reference/javascript.rst:130
msgid "Renders the widget and inserts it as the preceding sibling of the target, uses `.insertAfter()`_"
msgstr "呈现小部件, 并将其插入作为目标的前面的兄弟, 使用 `.insertAfter（）` _"

#: ../../reference/javascript.rst:135
msgid "Renders the widget and inserts it as the following sibling of the target, uses `.insertBefore()`_"
msgstr "呈现小部件, 并将其插入作为目标的后续兄弟, 使用 `.insertBefore（）` _"

#: ../../reference/javascript.rst:138
msgid "All of these methods accept whatever the corresponding jQuery method accepts (CSS selectors, DOM nodes or jQuery objects). They all return a deferred_ and are charged with three tasks:"
msgstr "所有这些方法都照单全收相应的jQuery方法接受（CSS选择器, DOM节点或jQuery的对象）。他们都返回deferred_, 并被控犯有三项任务:"

#: ../../reference/javascript.rst:142
msgid "rendering the widget's root element via :func:`~Widget.renderElement`"
msgstr "通过 :func:`~Widget.renderElement` 渲染挂件的根元素"

#: ../../reference/javascript.rst:144
msgid "inserting the widget's root element in the DOM using whichever jQuery method they match"
msgstr "插入使用任何它们匹配的jQuery方法在DOM挂件的根元素"

#: ../../reference/javascript.rst:146
msgid "starting the widget, and returning the result of starting it"
msgstr "开始小部件, 并返回启动它的结果"

#: ../../reference/javascript.rst:150
msgid "asynchronous startup of the widget once it's been injected in the DOM, generally used to perform asynchronous RPC calls to fetch whatever remote data is necessary for the widget to do its work."
msgstr "widget的异步启动, 一旦它在DOM被注入, 通常用于执行异步RPC调用获取任何远程数据所必需的部件, 以完成其工作。"

#: ../../reference/javascript.rst:154
msgid "Must return a deferred_ to indicate when its work is done."
msgstr "必须返回一个deferred_以指示其工作已经完成。"

#: ../../reference/javascript.rst:156
msgid "A widget is *not guaranteed* to work correctly until its :func:`~Widget.start` method has finished executing. The widget's parent/creator must wait for a widget to be fully started before interacting with it"
msgstr "小部件是 *不* 保证正常工作, 直到其 :func:`~Widget.start` 方法执行结束。挂件的父/创建者必须等待一个小部件与它交互之前全面打响"

#: ../../reference/javascript.rst:161 ../../reference/javascript.rst:202
msgid "deferred_ object"
msgstr "deferred_ object"

#: ../../reference/javascript.rst:163
msgid "widget destruction and cleanup"
msgstr "挂件的破坏和清理"

#: ../../reference/javascript.rst:167
msgid "destroys the widget's children, unbinds its events and removes its root from the DOM. Automatically called when the widget's parent is destroyed, must be called explicitly if the widget has no parents or if it is removed but its parent remains."
msgstr "破坏了widget的儿童, 解除绑定的事件, 并从DOM删除其根。自动调用时, 小部件的父被销毁, 必须显式调用, 如果该部件有没有父母, 或者如果它被删除, 但其父仍然存在。"

#: ../../reference/javascript.rst:172
msgid "A widget being destroyed is automatically unlinked from its parent."
msgstr "小部件被破坏是从它的父自动解除链接。"

#: ../../reference/javascript.rst:174
msgid "Related to widget destruction is an important utility method:"
msgstr "挂件破坏相关的一个重要工具的方法:"

#: ../../reference/javascript.rst:178
msgid "A significant issue with RPC and destruction is that an RPC call may take a long time to execute and return while a widget is being destroyed or after it has been destroyed, trying to execute its operations on a widget in a broken/invalid state."
msgstr "与RPC和销毁显著的问题是, 一个RPC调用可能需要很长的时间来执行, 而小部件被销毁, 或者被摧毁后, 试图在一个破碎/无效状态的一个小部件执行其操作返回。"

#: ../../reference/javascript.rst:183
msgid "This is a frequent source of errors or strange behaviors."
msgstr "这是错误或怪异的行为的一个常见来源。"

#: ../../reference/javascript.rst:185
msgid ":func:`~Widget.alive` can be used to wrap an RPC call, ensuring that whatever operations should be executed when the call ends are only executed if the widget is still alive::"
msgstr ":func:`~Widget.alive` 可以用来包装一个RPC调用, 确保一切行动应被执行时, 通话结束后才会执行, 如果小部件还活着 ::"

#: ../../reference/javascript.rst:197
msgid "a deferred_ object to wrap"
msgstr "包装一个deferred_对象"

#: ../../reference/javascript.rst:198
msgid "by default, if the RPC call returns after the widget has been destroyed the returned deferred_ is left in limbo (neither resolved nor rejected). If ``reject`` is set to ``true``, the deferred_ will be rejected instead."
msgstr "默认情况下, 如果小部件后, RPC调用返回被摧毁返回deferred_留在无人过问（没有解决, 也没有拒绝）。如果 ``reject`` 设置为 ``True`` , 那么该deferred_将被拒绝代替。"

#: ../../reference/javascript.rst:206
msgid "``true`` if the widget is being or has been destroyed, ``false`` otherwise"
msgstr "值为 ``True`` 如果挂件正在或已经被破坏了, ``false`` 否则"

#: ../../reference/javascript.rst:210
msgid "Accessing DOM content"
msgstr "访问DOM内容"

#: ../../reference/javascript.rst:213
msgid "Because a widget is only responsible for the content below its DOM root, there"
msgstr "因为一个小部件只负责低于其DOM的根的内容, 有"

#: ../../reference/javascript.rst:213
msgid "is a shortcut for selecting sub-sections of a widget's DOM:"
msgstr "是选择一个小部件的DOM子区的捷径:"

#: ../../reference/javascript.rst:217
msgid "Applies the CSS selector specified as parameter to the widget's DOM root::"
msgstr "适用于指定为参数widget的DOM根的CSS选择器 ::"

#: ../../reference/javascript.rst:222
msgid "is functionally identical to::"
msgstr "在功能上等同 ::"

#: ../../reference/javascript.rst:226
msgid "CSS selector"
msgstr "CSS选择器"

#: ../../reference/javascript.rst:227
msgid "jQuery object"
msgstr "jQuery对象"

#: ../../reference/javascript.rst:229
msgid "this helper method is similar to ``Backbone.View.$``"
msgstr "这个辅助方法类似于 ``Backbone.View。$`` "

#: ../../reference/javascript.rst:232
msgid "Resetting the DOM root"
msgstr "重置DOM根"

#: ../../reference/javascript.rst:236
msgid "Re-sets the widget's DOM root to the provided element, also handles re-setting the various aliases of the DOM root as well as unsetting and re-setting delegated events."
msgstr "重新设置挂件的DOM根提供的元素, 也处理重新设定的DOM根的各种别名以及解封, 重新设定授权事件。"

#: ../../reference/javascript.rst:240
msgid "a DOM element or jQuery object to set as the widget's DOM root"
msgstr "DOM元素或jQuery对象设置为小部件的DOM根"

#: ../../reference/javascript.rst:243
msgid "should be mostly compatible with `Backbone's setElement`_"
msgstr "应与 `骨干setElement` _基本上兼容"

#: ../../reference/javascript.rst:247
msgid "DOM events handling"
msgstr "DOM事件处理"

#: ../../reference/javascript.rst:249
msgid "A widget will generally need to respond to user action within its section of the page. This entails binding events to DOM elements."
msgstr "甲插件通常需要以内的页面的其部分响应用户行动。这需要结合事件的DOM元素。"

#: ../../reference/javascript.rst:252
msgid "To this end, :class:`~Widget` provides a shortcut:"
msgstr "为此, :class:`~Widget` 提供了一条捷径:"

#: ../../reference/javascript.rst:256
msgid "Events are a mapping of an event selector (an event name and an optional CSS selector separated by a space) to a callback. The callback can be the name of a widget's method or a function object. In either case, the ``this`` will be set to the widget::"
msgstr "事件是一个事件选择器（事件名称和一个可选的CSS选择器由一个空格隔开）回调的映射。回调可能是一个小部件的方法的名称或函数对象。在两种情况下, ``this`` 将被设定为小部件 ::"

#: ../../reference/javascript.rst:268
msgid "The selector is used for jQuery's `event delegation`_, the callback will only be triggered for descendants of the DOM root matching the selector\\ [#eventsdelegation]_. If the selector is left out (only an event name is specified), the event will be set directly on the widget's DOM root."
msgstr "用于jQuery的'事件delegation `_的选择, 回调只会触发的DOM根的后代选择器匹配的\\ [#eventsdelegation] _。如果选择留出（仅事件名称指定）, 该事件将直接在小部件的DOM根设置。"

#: ../../reference/javascript.rst:276
msgid "This method is in charge of binding :attr:`~Widget.events` to the DOM. It is automatically called after setting the widget's DOM root."
msgstr "这种方法是负责绑定 :attr:`~Widget.events` 到DOM。它是设置widget的DOM根后自动调用。"

#: ../../reference/javascript.rst:279
msgid "It can be overridden to set up more complex events than the :attr:`~Widget.events` map allows, but the parent should always be called (or :attr:`~Widget.events` won't be handled correctly)."
msgstr "它可以覆盖设置比更复杂的事件 :attr:`~Widget.events` 映射允许的, 但家长应始终调用（或 :attr:`~Widget.events` 不会被正确处理）。"

#: ../../reference/javascript.rst:285
msgid "This method is in charge of unbinding :attr:`~Widget.events` from the DOM root when the widget is destroyed or the DOM root is reset, in order to avoid leaving \"phantom\" events."
msgstr "这种方法是负责解除绑定 :attr:`~Widget.events` 从DOM根当小部件被销毁或DOM根复位, 以免留下'幻影'事件。"

#: ../../reference/javascript.rst:289
msgid "It should be overridden to un-set any event set in an override of :func:`~Widget.delegateEvents`."
msgstr "应该覆盖到未设置的覆盖设置的任何事件 :func:`~Widget.delegateEvents` 。"

#: ../../reference/javascript.rst:292
msgid "this behavior should be compatible with `Backbone's delegateEvents`_, apart from not accepting any argument."
msgstr "这种行为应该与'骨干delegateEvents `_兼容, 除了不接受任何参数。"

#: ../../reference/javascript.rst:296
msgid "Subclassing Widget"
msgstr "子类化的widget"

#: ../../reference/javascript.rst:298
msgid ":class:`~Widget` is subclassed in the standard manner (via the :func:`~Class.extend` method), and provides a number of abstract properties and concrete methods (which you may or may not want to override). Creating a subclass looks like this::"
msgstr ":class:`~Widget` 的子类以标准方式（通过 :func:`~Class.extend` 方法）, 并提供了一​​些抽象属性和具体方法（您可能会或可能不希望重写）了。创建一个子类看起来像这样 ::"

#: ../../reference/javascript.rst:329
msgid "The new class can then be used in the following manner::"
msgstr "新的类然后可以以下面的方式被使用 ::"

#: ../../reference/javascript.rst:336
msgid "After these two lines have executed (and any promise returned by :func:`~Widget.appendTo` has been resolved if needed), the widget is ready to be used."
msgstr "经过这两条线已经执行（和返回的任何承诺 :func:`~Widget.appendTo` 已如果需要解决）, 小部件就可以使用了。"

#: ../../reference/javascript.rst:340
msgid "the insertion methods will start the widget themselves, and will return the result of :func:`~Widget.start()`."
msgstr "插入方法将开始小部件本身, 并将返回的结果 :func:`~Widget.start（）` 。"

#: ../../reference/javascript.rst:343
msgid "If for some reason you do not want to call these methods, you will have to first call :func:`~Widget.render()` on the widget, then insert it into your DOM and start it."
msgstr "如果由于某种原因, 你不想调用这些方法, 你将不得不第一次调用 :func:`~Widget.render（）` 的小部件, 然后将其插入到DOM并启动它。"

#: ../../reference/javascript.rst:347
msgid "If the widget is not needed anymore (because it's transient), simply terminate it::"
msgstr "如果小部件不再需要（因为它是短暂的）, 只是终止 ::"

#: ../../reference/javascript.rst:352
msgid "will unbind all DOM events, remove the widget's content from the DOM and destroy all widget data."
msgstr "将解除所有的DOM事件, 从DOM中删除widget的内容并销毁所有部件的数据。"

#: ../../reference/javascript.rst:356
msgid "Development Guidelines"
msgstr "开发指南"

#: ../../reference/javascript.rst:358
msgid "Identifiers (``id`` attribute) should be avoided. In generic applications and modules, ``id`` limits the re-usability of components and tends to make code more brittle. Most of the time, they can be replaced with nothing, classes or keeping a reference to a DOM node or jQuery element."
msgstr "（ ``id`` 属性）应避免标识符。在一般的应用程序和模块, ``id`` 限制了可重用性组件, 并容易使代码更脆。大多数时候, 它们可以被替换为空, 类或保持参考DOM节点或jQuery的元素。"

#: ../../reference/javascript.rst:363
msgid "If an ``id`` is absolutely necessary (because a third-party library requires one), the id should be partially generated using ``_.uniqueId()`` e.g.::"
msgstr "如果 ``id`` 是绝对必要的（由于第三方库需要一个）, ID应该是部分使用 ``_.uniqueId（）`` 例如 :: 生成"

#: ../../reference/javascript.rst:367
msgid "Avoid predictable/common CSS class names. Class names such as \"content\" or \"navigation\" might match the desired meaning/semantics, but it is likely an other developer will have the same need, creating a naming conflict and unintended behavior. Generic class names should be prefixed with e.g. the name of the component they belong to (creating \"informal\" namespaces, much as in C or Objective-C)."
msgstr "避免可预见/常见CSS类名。类的名称, 如'内容'或'导航'可能匹配所需的意义/语义, 但它可能是一个其他的开发者也会有同样的需要, 创造一个命名冲突和意外情况。通用类名称的前缀应该与他们属于（创建'非正式'的命名空间, 就像在C或Objective-C的）的组件, 例如名称。"

#: ../../reference/javascript.rst:373
msgid "Global selectors should be avoided. Because a component may be used several times in a single page (an example in Odoo is dashboards), queries should be restricted to a given component's scope. Unfiltered selections such as ``$(selector)`` or ``document.querySelectorAll(selector)`` will generally lead to unintended or incorrect behavior.  Odoo Web's :class:`~Widget` has an attribute providing its DOM root (:attr:`~Widget.$el`), and a shortcut to select nodes directly (:func:`~Widget.$`)."
msgstr ""
"Global selectors should be avoided. Because a component may be used several times in a single page (an example in Odoo is dashboards)， queries should be restricted to a given component 's scope. Unfiltered selections such as `` $(selector) `` or `` document.querySelectorAll(selector) `` will generally lead to unintended or incorrect behavior. Odoo Web' s :class:`~Widget` has an attribute providing its DOM root ( :attr:`~Widget.$el` )， and a shortcut to select nodes directly ( :func:`~Widget.$` )."

#: ../../reference/javascript.rst:381
msgid "More generally, never assume your components own or controls anything beyond its own personal :attr:`~Widget.$el`"
msgstr "More generally, never assume your components own or controls anything beyond its own personal :attr:`~Widget.$el` "

#: ../../reference/javascript.rst:383
msgid "html templating/rendering should use QWeb unless absolutely trivial."
msgstr "HTML模板/渲染应该使用QWeb, 除非绝对微不足道。"

#: ../../reference/javascript.rst:384
msgid "All interactive components (components displaying information to the screen or intercepting DOM events) must inherit from :class:`~Widget` and correctly implement and use its API and life cycle."
msgstr "所有交互式组件（组件的信息显示在屏幕或拦截DOM事件）都必须继承 :class:`~Widget` , 正确实施和使用其API和生命周期。"

#: ../../reference/javascript.rst:412 ../../reference/javascript.rst:1142
msgid "RPC"
msgstr "RPC"

#: ../../reference/javascript.rst:414
msgid "To display and interact with data, calls to the Odoo server are necessary. This is performed using :abbr:`RPC <Remote Procedure Call>`."
msgstr "要显示与数据进行交互, 则调用Odoo服务器是必要的。这是使用执行 :abbr:`RPC <远程过程调用>` 。"

#: ../../reference/javascript.rst:417
msgid "Odoo Web provides two primary APIs to handle this: a low-level JSON-RPC based API communicating with the Python section of Odoo Web (and of your module, if you have a Python part) and a high-level API above that allowing your code to talk directly to high-level Odoo models."
msgstr "Odoo网站提供了两个主要的API来处理这个问题:用Odoo网站的Python的第一个低级别的JSON-RPC的API通信（和你的模块, 如果你有一个Python部分）及以上的高层次的API, 允许你代码直接与高层Odoo车型。"

#: ../../reference/javascript.rst:422
msgid "All networking APIs are :ref:`asynchronous <reference/async>`. As a result, all of them will return Deferred_ objects (whether they resolve those with values or not). Understanding how those work before before moving on is probably necessary."
msgstr "所有的网络API有 :ref:`异步<reference/async>` 。其结果是, 所有的人都将返回Deferred_对象（无论它们解决那些值或者不是）。了解如何在继续之前以前的那些工作, 可能是必要的。"

#: ../../reference/javascript.rst:428
msgid "High-level API: calling into Odoo models"
msgstr "高层API:调用Odoo模型"

#: ../../reference/javascript.rst:430
msgid "Access to Odoo object methods (made available through XML-RPC from the server) is done via :class:`Model` (exported in ``web.Model``). It maps onto the Odoo server objects via two primary methods, :func:`~Model.call` and :func:`~Model.query`."
msgstr ":class:`Model` （在 ``web.Model`` 出口）进入Odoo对象的方法（通过XML-RPC从服务器上可用）通过完成的。它映射到Odoo服务对象主要通过两种方法 :func:`~Model.call` 和 :func:`~Model.query` 。"

#: ../../reference/javascript.rst:435
msgid ":func:`~Model.call` is a direct mapping to the corresponding method of the Odoo server object. Its usage is similar to that of the Odoo Model API, with three differences:"
msgstr ":func:`~Model.call` 是直接映射到Odoo服务器对象的相应方法。其用法是类似于Odoo模型的API, 有三个不同之处:"

#: ../../reference/javascript.rst:439
msgid "The interface is :ref:`asynchronous <reference/async>`, so instead of returning results directly RPC method calls will return Deferred_ instances, which will themselves resolve to the result of the matching RPC call."
msgstr "该接口是 :ref:`异步<reference/async>` , 所以不是返回结果直接RPC方法调用返回Deferred_情况下, 将自己想办法解决, 以匹配的RPC调用的结果。"

#: ../../reference/javascript.rst:444
msgid "Because ECMAScript 3/Javascript 1.5 doesnt feature any equivalent to ``__getattr__`` or ``method_missing``, there needs to be an explicit method to dispatch RPC methods."
msgstr "由于ECMAScript的3 / Javascript的1.5犯规特征的任何等同于 ``__getattr__`` 或 ``method_missing`` , 需要有一个明确的方法来调度RPC方法。"

#: ../../reference/javascript.rst:448
msgid "No notion of pooler, the model proxy is instantiated where needed, not fetched from an other (somewhat global) object::"
msgstr "普勒没有概念, 模型代理实例在需要的地方, 从其他（有点全局）对象 :: 不取"

#: ../../reference/javascript.rst:458
msgid ":func:`~Model.query` is a shortcut for a builder-style interface to searches (``search`` + ``read`` in Odoo RPC terms). It returns a :class:`~openerp.web.Query` object which is immutable but allows building new :class:`~openerp.web.Query` instances from the first one, adding new properties or modifiying the parent object's::"
msgstr ":func:`~Model.query` 是一个建设者风格的界面, 搜索快捷键（ ``在Odoo RPC方面search`` + ``read`` ）。它返回一个 :class:`~openerp.web.Query` 对象, 它是不可变的, 但允许建立新的 :class:`从第一个~openerp.web.Query` 情况下, 增加新的属性或modifiying父对象的 ::"

#: ../../reference/javascript.rst:471
msgid "The query is only actually performed when calling one of the query serialization methods, :func:`~openerp.web.Query.all` and :func:`~openerp.web.Query.first`. These methods will perform a new RPC call every time they are called."
msgstr "只是实际执行的查询要求之一的查询序列化方法, 当 :func:`~openerp.web.Query.all` 和 :func:`~openerp.web.Query.first` 。这些方法将执行新的RPC调用每一个他们被称为时间。"

#: ../../reference/javascript.rst:476
msgid "For that reason, it's actually possible to keep \"intermediate\" queries around and use them differently/add new specifications on them."
msgstr "出于这个原因, 它实际上可以保持'中间'查询周围, 并利用它们不同的/它们添加新的规格。"

#: ../../reference/javascript.rst:483
msgid "name of the model this object is bound to"
msgstr "模型的这个对象绑定到名字"

#: ../../reference/javascript.rst:487
msgid "Calls the ``method`` method of the current model, with the provided positional and keyword arguments."
msgstr "调用当前模型的 ``method`` 方法, 与提供位置和关键字参数。"

#: ../../reference/javascript.rst:490
msgid "method to call over rpc on the :attr:`~Model.name`"
msgstr "方法来调用通过RPC的 :attr:`~Model.name` "

#: ../../reference/javascript.rst:492
msgid "positional arguments to pass to the method, optional"
msgstr "位置参数传递给方法, 可选"

#: ../../reference/javascript.rst:494
msgid "keyword arguments to pass to the method, optional"
msgstr "关键字参数传递给方法, 可选"

#: ../../reference/javascript.rst:496
msgid "Deferred<>"
msgstr "递延<>"

#: ../../reference/javascript.rst:500
msgid "list of fields to fetch during the search"
msgstr "字段列表的搜索过程中获取"

#: ../../reference/javascript.rst:502
msgid "a :class:`~openerp.web.Query` object representing the search to perform"
msgstr "答 :class:`~openerp.web.Query` 对象, 表示搜索执行"

#: ../../reference/javascript.rst:507
msgid "The first set of methods is the \"fetching\" methods. They perform RPC queries using the internal data of the object they're called on."
msgstr "第一组的方法是'抓取'的方法。他们的表现用他们呼吁对象的内部数据RPC查询。"

#: ../../reference/javascript.rst:513
msgid "Fetches the result of the current :class:`~openerp.web.Query` object's search."
msgstr "获取当前的结果 :class:`~openerp.web.Query` 对象的搜索。"

#: ../../reference/javascript.rst:516
msgid "Deferred<Array<>>"
msgstr "递延<Array<>>"

#: ../../reference/javascript.rst:520
msgid "Fetches the **first** result of the current :class:`~openerp.web.Query`, or ``null`` if the current :class:`~openerp.web.Query` does have any result."
msgstr "获取当前的 **第** 结果 :class:`~openerp.web.Query` , 或 ``null`` 如果当前的 :class:`~openerp.web.Query` 不会有任何结果。"

#: ../../reference/javascript.rst:524
msgid "Deferred<Object | null>"
msgstr "递延<Object | null>"

#: ../../reference/javascript.rst:528
msgid "Fetches the number of records the current :class:`~openerp.web.Query` would retrieve."
msgstr "获取的记录数当前 :class:`~openerp.web.Query` 将检索。"

#: ../../reference/javascript.rst:531
msgid "Deferred<Number>"
msgstr "递延<Number>"

#: ../../reference/javascript.rst:535
msgid "Fetches the groups for the query, using the first specified grouping parameter"
msgstr "取出的组进行查询, 使用所述第一指定的分组参数"

#: ../../reference/javascript.rst:538
msgid "Lists the levels of grouping asked of the server. Grouping can actually be an array or varargs."
msgstr "列出的分组问的服务器的水平。分组实际上可以是一个数组或可变参数。"

#: ../../reference/javascript.rst:542
msgid "Deferred<Array<openerp.web.QueryGroup>> | null"
msgstr "递延<Array<openerp.web.QueryGroup>> | null"

#: ../../reference/javascript.rst:544
msgid "The second set of methods is the \"mutator\" methods, they create a **new** :class:`~openerp.web.Query` object with the relevant (internal) attribute either augmented or replaced."
msgstr "第二组方法是'突变'的方法, 他们创造一个新的 ****: class:`~相关（内部）openerp.web.Query` 对象的属性或者增加或更换。"

#: ../../reference/javascript.rst:550
msgid "Adds the provided ``ctx`` to the query, on top of any existing context"
msgstr "将提供的 ``ctx`` 的查询, 对现有环境的顶部"

#: ../../reference/javascript.rst:555
msgid "Adds the provided domain to the query, this domain is ``AND``-ed to the existing query domain."
msgstr "将提供的域名查询, 该域名是 ``AND`` -ED现有的查询域。"

#: ../../reference/javascript.rst:560
msgid "Sets the provided offset on the query. The new offset *replaces* the old one."
msgstr "设置在查询所提供的补偿。新的偏移量 **替换旧的。"

#: ../../reference/javascript.rst:565
msgid "Sets the provided limit on the query. The new limit *replaces* the old one."
msgstr "设置在查询所提供的极限。新限制 **替换旧的。"

#: ../../reference/javascript.rst:570
msgid "Overrides the model's natural order with the provided field specifications. Behaves much like Django's :py:meth:`QuerySet.order_by <django.db.models.query.QuerySet.order_by>`:"
msgstr "覆盖模型的自然秩序与所提供的字段规范。行为很像Django的:PY :meth:`QuerySet.order_by <django.db.models.query.QuerySet.order_by>` :"

#: ../../reference/javascript.rst:574
msgid "Takes 1..n field names, in order of most to least importance (the first field is the first sorting key). Fields are provided as strings."
msgstr "注意到1..N字段名, 以最到最重要的（第一场是第一个排序键）。字段提供字符串。"

#: ../../reference/javascript.rst:578
msgid "A field specifies an ascending order, unless it is prefixed with the minus sign \"``-``\" in which case the field is used in the descending order"
msgstr "字段指定了一个升序排列, 除非它前面加上减号' ``-`` '在这种情况下字段用于降序排序"

#: ../../reference/javascript.rst:582
msgid "Divergences from Django's sorting include a lack of random sort (``?`` field) and the inability to \"drill down\" into relations for sorting."
msgstr "从Django的排序分歧包括缺乏随机排序（ ``？`` 场）, 并不能为'向下钻取'成关系进行排序。"

#: ../../reference/javascript.rst:587
msgid "Aggregation (grouping)"
msgstr "聚合（分组）"

#: ../../reference/javascript.rst:589
msgid "Odoo has powerful grouping capacities, but they are kind-of strange in that they're recursive, and level n+1 relies on data provided directly by the grouping at level n. As a result, while :py:meth:`openerp.models.Model.read_group` works it's not a very intuitive API."
msgstr "Odoo具有强大的分组的能力, 但它们是奇怪的, 因为它们是递归形式的-, 和电平n + 1个依赖于通过在级n分组直接提供的数据。其结果是, 虽然:PY :meth:`openerp.models.Model.read_group` 作品这不是一个很直观的API。"

#: ../../reference/javascript.rst:595
msgid "Odoo Web eschews direct calls to :py:meth:`~openerp.models.Model.read_group` in favor of calling a method of :class:`~openerp.web.Query`, :py:meth:`much in the way it is one in SQLAlchemy <sqlalchemy.orm.query.Query.group_by>` [#terminal]_::"
msgstr "Odoo Web eschews direct calls to :py: meth :`~openerp.models.Model.read_group` in favor of calling a method of : class :`~openerp.web.Query` , : py :meth:`much in the way it is one in SQLAlchemy <sqlalchemy.orm.query.Query.group_by>` [#terminal]_ ::"

#: ../../reference/javascript.rst:604
msgid "This method is asynchronous when provided with 1..n fields (to group on) as argument, but it can also be called without any field (empty fields collection or nothing at all). In this case, instead of returning a Deferred object it will return ``null``."
msgstr "这种方法是异步的, 当有1..1字段（以组）作为参数提供的, 但它也可以被称为无任何字段（空字段集合或者什么都没有）。而不是返回一个Deferred对象在这种情况下, 它会返回 ``null`` 。"

#: ../../reference/javascript.rst:609
msgid "When grouping criterion come from a third-party and may or may not list fields (e.g. could be an empty list), this provides two ways to test the presence of actual subgroups (versus the need to perform a regular query for records):"
msgstr "当分组标准来自第三方并且可以或可以不列出的字段（例如, 可能是一个空的列表）, 这提供了两种方法来测试实际子组的存在（相对于需要执行用于记录常规查询）:"

#: ../../reference/javascript.rst:614
msgid "A check on ``group_by``'s result and two completely separate code paths::"
msgstr "对 ``group_by`` 的结果和两个完全不同的代码路径进行检查 ::"

#: ../../reference/javascript.rst:625
msgid "Or a more coherent code path using :func:`when`'s ability to coerce values into deferreds::"
msgstr "或者更连贯的代码路径使用 :func:`when` 的强迫值到deferreds能力 ::"

#: ../../reference/javascript.rst:637
msgid "The result of a (successful) :func:`~openerp.web.Query.group_by` is an array of :class:`~openerp.web.QueryGroup`:"
msgstr ":func: 一个（成功）结果 `~openerp.web.Query.group_by` 是一个数组 :class:`~openerp.web.QueryGroup` :"

#: ../../reference/javascript.rst:644
msgid "returns the group's attribute ``key``. Known attributes are:"
msgstr "返回组的属性 ``key`` 。已知的属性有:"

#: ../../reference/javascript.rst:646
msgid "``grouped_on``"
msgstr " ``grouped_on`` "

#: ../../reference/javascript.rst:647
msgid "which grouping field resulted from this group"
msgstr "其中分组字段是由于该组"

#: ../../reference/javascript.rst:649
msgid "``grouped_on``'s value for this group"
msgstr "这组 ``grouped_on`` 的价值"

#: ../../reference/javascript.rst:650
msgid "``length``"
msgstr " ``length`` "

#: ../../reference/javascript.rst:651
msgid "the number of records in the group"
msgstr "记录的组中的号"

#: ../../reference/javascript.rst:652
msgid "``aggregates``"
msgstr " ``aggregates`` "

#: ../../reference/javascript.rst:653
msgid "a {field: value} mapping of aggregations for the group"
msgstr "一个{字段:值}聚合为组映射"

#: ../../reference/javascript.rst:657
msgid "equivalent to :func:`Model.query` but pre-filtered to only include the records within this group. Returns a :class:`~openerp.web.Query` which can be further manipulated as usual."
msgstr "相当于 :func:`Model.query` 但预过滤, 只包括该组中的记录。返回 :class:`~openerp.web.Query` 可以进一步操纵如常。"

#: ../../reference/javascript.rst:664
msgid "returns a deferred to an array of :class:`~openerp.web.QueryGroup` below this one"
msgstr "返回一个推迟到数组 :class:`~下面这一个openerp.web.QueryGroup` "

#: ../../reference/javascript.rst:668
msgid "Low-level API: RPC calls to Python side"
msgstr "低级API:RPC调用到Python方"

#: ../../reference/javascript.rst:670
msgid "While the previous section is great for calling core OpenERP code (models code), it does not work if you want to call the Python side of Odoo Web."
msgstr "虽然上一节是伟大的调用核心的OpenERP代码（机型代码）, 它并不重要, 如果你想打电话Odoo网络的Python端的工作。"

#: ../../reference/javascript.rst:674
msgid "For this, a lower-level API exists on on :class:`~Session` objects (the class is exported in ``web.Session``, but an instance isusually available through ``web.session``): the ``rpc`` method."
msgstr "对于这一点, 较低级别的API存在上 :class:`~Session` 对象（类出口在 ``web.Session`` , 但一个实例isusually可以通过 ``web.session`` ）:在 ``rpc`` 方法。"

#: ../../reference/javascript.rst:678
msgid "This method simply takes an absolute path (the absolute URL of the JSON :ref:`route <reference/http/routing>` to call) and a mapping of attributes to values (passed as keyword arguments to the Python method). This function fetches the return value of the Python methods, converted to JSON."
msgstr "这种方法只需要一个绝对路径（JSON的绝对URL :ref:`航线<reference/http/routing>` 调用）和属性的映射值（传递关键字参数到Python的方法）。该功能获取的Python的方法的返回值, 转换成JSON。"

#: ../../reference/javascript.rst:683
msgid "For instance, to call the ``resequence`` of the :class:`~web.controllers.main.DataSet` controller::"
msgstr "例如, 要调用的的 ``resequence`` :class:`~web.controllers.main.DataSet` 控制器 ::"

#: ../../reference/javascript.rst:699
msgid "Web Client"
msgstr "Web客户端"

#: ../../reference/javascript.rst:702
msgid "Javascript module system overview"
msgstr "Javascript的模块系统概述"

#: ../../reference/javascript.rst:704
msgid "A new module system (inspired from requirejs) has now been deployed. It has many advantages over the Odoo version 8 system."
msgstr "一个新的模块系统（从requirejs启发）现在已经部署。它拥有超过Odoo版本8系统的许多优点。"

#: ../../reference/javascript.rst:707
msgid "loading order: dependencies are guaranteed to be loaded first, even if files are not loaded in the correct order in the bundle files."
msgstr "加载顺序:依赖关系, 保证先加载, 即使没有按照正确的顺序在包文件加载的文件。"

#: ../../reference/javascript.rst:709
msgid "easier to split a file into smaller logical units."
msgstr "更容易文件分割成更小的逻辑单元。"

#: ../../reference/javascript.rst:710
msgid "no global variables: easier to reason."
msgstr "没有全局变量:容易理由。"

#: ../../reference/javascript.rst:711
msgid "it is possible to examine every dependencies and dependants.  This makes refactoring much simpler, and less risky."
msgstr "它可以检查每个依赖和家属。这使得重构简单得多, 而且风险较小。"

#: ../../reference/javascript.rst:714
msgid "It has also some disadvantages:"
msgstr "它也有一些缺点:"

#: ../../reference/javascript.rst:716
msgid "files are required to use the module system if they want to interact with odoo, since the various objects are only available in the module system, and not in global variables"
msgstr "文件需要使用模块的系统, 如果他们想与odoo交互, 因为各种对象仅在模块系统中可用的, 并没有在全局变量"

#: ../../reference/javascript.rst:719
msgid "circular dependencies are not supported.  It makes sense, but it means that one needs to be careful."
msgstr "不支持循环依赖。这是有道理的, 但它意味着一个人需要小心。"

#: ../../reference/javascript.rst:722
msgid "This is obviously a very large change and will require everyone to adopt new habits.  For example, the variable openerp does not exist anymore.  The new way of doing things is to import explicitely the module you need, and declaring explicitely the objects you export.  Here is a simple example::"
msgstr "这显然​​是一个非常大的变化, 并要求大家采用新的习惯。例如, 该变量的OpenERP不存在了。做事情的新方式是明确地输入你所需要的模块, 并宣布明确地导出的对象。下面是一个简单的例子 ::"

#: ../../reference/javascript.rst:739
msgid "This snippet shows a module named ``addon_name.service``.  It is defined with the ``odoo.define`` function.  ``odoo.define`` takes a name and a function for arguments:"
msgstr "这片段显示了一个名为 ``addon_name.service`` 模块。它被定义的 ``odoo.define`` 功能。 ``odoo.define`` 需要一个名称和功能参数:"

#: ../../reference/javascript.rst:743
msgid "The name is the concatenation of the name of the addon it is defined in and a name describing its purpose."
msgstr "名称是它是在定义的插件并描述其用途的名称的名称的串联。"

#: ../../reference/javascript.rst:745
msgid "The function is the place where the javascript module is actually defined.  It takes a function ``require`` as first argument, and returns something (or not, depending if it needs to export something). The ``require`` function is used to get a handle on the dependencies. In this case, it gives a handle on two javascript modules from the ``web`` addon, namely ``web.utils`` and ``web.Model``."
msgstr "该功能是其中的javascript模块实际上是定义的地方。它需要一个函数 ``require`` 作为第一个参数, 返回的东西（或没有, 这取决于是否需要出口的东西）。该 ``require`` 功能是用来获得相关性信息的处理。在这种情况下, 它提供了在两个JavaScript的模块的把手从 ``web`` 插件, 即 ``web.utils`` 和 ``web.Model`` 。"

#: ../../reference/javascript.rst:752
msgid "The idea is that you define what you need to import (by using the ``require`` function) and declare what you export (by returning something).  The web client will then make sure that your code is loaded properly."
msgstr "我们的想法是, 你确定你所需要导入（使用 ``require`` 功能）, 并声明一下你出口（通过返回的东西）。那么Web客户端将确保您的代码加载正确。"

#: ../../reference/javascript.rst:757
msgid "Modules are contained in a file, but a file can define several modules (however, it is better to keep them in separate files)."
msgstr "模块都包含在一个文件, 而是一个文件可以定义多个模块（然而, 最好将其保存在单独的文件）。"

#: ../../reference/javascript.rst:760
msgid "Each module can return a deferred. In that case, the module is marked as loaded only when the deferred is resolved, and its value is equal to the resolved value. The module can be rejected (unloaded). This will be logged in the console as info."
msgstr "每个模块都可以返回一个延迟。在这种情况下, 该模块被标记为装载仅当延迟得以解决, 并且其值等于解析值。该模块可被拒绝（卸载）。这将在控制台的信息被记录。"

#: ../../reference/javascript.rst:764
msgid "``Missing dependencies``: These modules do not appear in the page. It is possible that the JavaScript file is not in the page or that the module name is wrong"
msgstr " ``缺少dependencies`` :这些模块没有出现在该页面。这是可能的JavaScript文件是不是在页面或模块名称是错"

#: ../../reference/javascript.rst:767
msgid "``Failed modules``: A javascript error is detected"
msgstr " ``失败modules`` :检测JavaScript错误"

#: ../../reference/javascript.rst:769
msgid "``Rejected modules``: The module returns a rejected deferred. It (and its dependent modules) is not loaded."
msgstr " ``拒绝modules`` :该模块返回一个被拒绝延期。它（及其相关模块）未加载。"

#: ../../reference/javascript.rst:772
msgid "``Rejected linked modules``: Modules who depend on a rejected module"
msgstr " ``拒绝联modules`` :模块靠谁被拒绝模块"

#: ../../reference/javascript.rst:774
msgid "``Non loaded modules``: Modules who depend on a missing or a failed module"
msgstr " ``不装modules`` :谁的模块依赖于丢失或发生故障的模块"

#: ../../reference/javascript.rst:779
msgid "Web client structure"
msgstr "Web客户端结构"

#: ../../reference/javascript.rst:781
msgid "The web client files have been refactored into smaller and simpler files. Here is a description of the current file structure:"
msgstr "Web客户端文件已被重构为更小的, 更简单的文件。这里是当前文件结构的描述:"

#: ../../reference/javascript.rst:784
msgid "the ``framework/`` folder contains all basic low level modules.  The modules here are supposed to be generic.  Some of them are:"
msgstr "在 ``框架/`` 文件夹包含所有基本低水平模块。这里的模块应该是通用的。其中一些是:"

#: ../../reference/javascript.rst:787
msgid "``web.ajax`` implements rpc calls"
msgstr " ``web.ajax`` 实现RPC调用"

#: ../../reference/javascript.rst:788
msgid "``web.core`` is a generic modules.  It exports various useful objects and functions, such as ``qweb``, ``_t`` or the main bus."
msgstr " ``web.core`` 是一个通用模块。它出口各种有用的对象和功能, 如 ``qweb`` , ``_t`` 或主总线。"

#: ../../reference/javascript.rst:790
msgid "``web.Widget`` contains the widget class"
msgstr " ``web.Widget`` 包含挂件类"

#: ../../reference/javascript.rst:791
msgid "``web.Model`` is an abstraction over ``web.ajax`` to make calls to the server model methods"
msgstr " ``web.Model`` 是一个抽象的概念了 ``web.ajax`` 打电话到该服务器模型的方法"

#: ../../reference/javascript.rst:793
msgid "``web.session`` is the former ``openerp.session``"
msgstr " ``web.session`` 是前者 ``openerp.session`` "

#: ../../reference/javascript.rst:794
msgid "``web.utils`` for useful code snippets"
msgstr " ``web.utils`` 有用的代码片段"

#: ../../reference/javascript.rst:795
msgid "``web.time`` for every time-related generic functions"
msgstr " ``web.time`` 每一个与时间相关的通用功能,"

#: ../../reference/javascript.rst:796
msgid "the ``views/`` folder contains all view definitions"
msgstr "在 ``视图/`` 文件夹包含所有视图定义"

#: ../../reference/javascript.rst:797
msgid "``widgets/`` is for standalone widgets"
msgstr " ``部件/`` 是独立的部件"

#: ../../reference/javascript.rst:799
msgid "The ``js/`` folder also contains some important files:"
msgstr "该 ``JS /`` 文件夹还包含一些重要的文件:"

#: ../../reference/javascript.rst:801
msgid "``action_manager.js`` is the ActionManager class"
msgstr " ``action_manager.js`` 是ActionManager类"

#: ../../reference/javascript.rst:802
msgid "``boot.js`` is the file actually implementing the module system"
msgstr " ``boot.js`` 是实际执行的模块系统中的文件"

#: ../../reference/javascript.rst:803
msgid "``menu.js`` is the definition of the top menu"
msgstr " ``menu.js`` 是顶部菜单的定义"

#: ../../reference/javascript.rst:804
msgid "``web_client.js`` is for the root widget WebClient"
msgstr " ``web_client.js`` 是根小部件的WebClient"

#: ../../reference/javascript.rst:805
msgid "``view_manager.js`` contains the ViewManager"
msgstr " ``view_manager.js`` 包含ViewManager"

#: ../../reference/javascript.rst:807
msgid "The two other files are ``tour.js`` for the tours and ``compatibility.js``. The latter file is a compatibility layer bridging the old system to the new module system.  This is where every module names are exported to the global variable ``openerp``.  In theory, our addons should work without ever using the variable ``openerp``, and the compatibility module can be disabled safely."
msgstr "其他两个文件是 ``tour.js`` 的旅游和 ``compatibility.js`` 。后者文件是一个兼容层桥接旧体制到新的模块系统。这是每一个模块名称远销全局变量 ``openerp`` 。从理论上讲, 我们的插件应该工作而没有使用可变 ``openerp`` , 并兼容模块, 可以安全地禁用。"

#: ../../reference/javascript.rst:815
msgid "Javascript conventions"
msgstr "Javascript的约定"

#: ../../reference/javascript.rst:817
msgid "Here are some basic conventions for the javascript code:"
msgstr "下面是JavaScript代码的一些基本规则:"

#: ../../reference/javascript.rst:819
msgid "declare all your dependencies at the top of the module.  Also, they should be sorted alphabetically by module name.  This makes it easier to understand your module."
msgstr "声明你的依赖在模块的顶部。此外, 他们应该按字母顺序模块名称排序。这使得它更容易理解你的模块。"

#: ../../reference/javascript.rst:822
msgid "declare all exports at the end."
msgstr "声明所有出口在年底。"

#: ../../reference/javascript.rst:823
msgid "add the ``use strict`` statement at the beginning of every module"
msgstr "加上 ``使用strict`` 声明在每个模块开始"

#: ../../reference/javascript.rst:824
msgid "always name your module properly: ``addon_name.description``."
msgstr "始终正确命名的模块:``addon_name.description`` 。"

#: ../../reference/javascript.rst:825
msgid "use capital letters for classes (for example, ``ActionManager`` is defined in the module ``web.ActionManager``), and lowercase for everything else (for example, ``ajax`` is defined in ``web.ajax``)."
msgstr "使用大写字母类（例如, ``ActionManager`` 在模块 ``web.ActionManager`` 中定义）, 和小写的一切（例如, ``ajax`` 在 ``定义web.ajax`` ）。"

#: ../../reference/javascript.rst:828
msgid "declare one module per file"
msgstr "每个申报文件的一个模块"

#: ../../reference/javascript.rst:835
msgid "Testing in Odoo Web Client"
msgstr "Odoo Web客户端的测试"

#: ../../reference/javascript.rst:838
msgid "Javascript Unit Testing"
msgstr "Javascript的单元测试"

#: ../../reference/javascript.rst:840
msgid "Odoo Web includes means to unit-test both the core code of Odoo Web and your own javascript modules. On the javascript side, unit-testing is based on QUnit_ with a number of helpers and extensions for better integration with Odoo."
msgstr "Odoo网络包括手段, 单元测试既Odoo Web和自己的JavaScript模块的核心代码。在JavaScript端, 单元测试是基于QUnit_与一些助手和扩展与Odoo更好的整合。"

#: ../../reference/javascript.rst:845
msgid "To see what the runner looks like, find (or start) an Odoo server with the web client enabled, and navigate to ``/web/tests`` This will show the runner selector, which lists all modules with javascript unit tests, and allows starting any of them (or all javascript tests in all modules at once)."
msgstr "要查看亚军的样子, 找到（或启动）的Odoo服务器与Web客户端启用, 并导航到 ``/网络/ tests`` 这将显示跑步者选择, 其中列出了所有模块的JavaScript单元测试, 允许启动其中的任何（或所有模块的所有的JavaScript测试一次）。"

#: ../../reference/javascript.rst:854
msgid "Clicking any runner button will launch the corresponding tests in the bundled QUnit_ runner:"
msgstr "点击任何按钮, 亚军将推出捆绑QUnit_亚军相应的测试:"

#: ../../reference/javascript.rst:861
msgid "Writing a test case"
msgstr "编写测试用例"

#: ../../reference/javascript.rst:863
msgid "The first step is to list the test file(s). This is done through the ``test`` key of the Odoo manifest, by adding javascript files to it:"
msgstr "第一步是列出测试文件（多个）。这是通过Odoo清单的 ``test`` 键完成, 通过添加JavaScript文件吧:"

#: ../../reference/javascript.rst:875
msgid "and to create the corresponding test file(s)"
msgstr "并建立相应的测试文件（S）"

#: ../../reference/javascript.rst:879
msgid "Test files which do not exist will be ignored, if all test files of a module are ignored (can not be found), the test runner will consider that the module has no javascript tests."
msgstr "其中不存在测试文件将被忽略, 如果一个模块的所有测试文件被忽略（无法找到）, 测试运行会认为模块没有JavaScript的测试。"

#: ../../reference/javascript.rst:883
msgid "After that, refreshing the runner selector will display the new module and allow running all of its (0 so far) tests:"
msgstr "在此之后, 刷新亚军选择器将显示新的模块, 并允许运行其所有（0）测试:"

#: ../../reference/javascript.rst:889
msgid "The next step is to create a test case::"
msgstr "下一步是创建一个测试用例 ::"

#: ../../reference/javascript.rst:897
msgid "All testing helpers and structures live in the ``openerp.testing`` module. Odoo tests live in a :func:`~openerp.testing.section`, which is itself part of a module. The first argument to a section is the name of the section, the second one is the section body."
msgstr "所有的测试助手和结构生活 ``openerp.testing`` 模块内。 Odoo测试住在 :func:`~openerp.testing.section` , 这本身就是一个模块的一部分。的第一个参数的截面是段的名称, 所述第二个是部分身体。"

#: ../../reference/javascript.rst:902
msgid ":func:`test <openerp.testing.case>`, provided by the :func:`~openerp.testing.section` to the callback, is used to register a given test case which will be run whenever the test runner actually does its job. Odoo Web test case use standard `QUnit assertions`_ within them."
msgstr ":func:`测试<openerp.testing.case>` , 由提供 :func:`~openerp.testing.section` 回调, 用于注册一个给定的测试用例每当测试运行实际上做这将运行它的工作。 Odoo Web测试的情况下使用标准的 `QUnit assertions` _在其中。"

#: ../../reference/javascript.rst:908
msgid "Launching the test runner at this point will run the test and display the corresponding assertion message, with red colors indicating the test failed:"
msgstr "启动测试运行在此时将运行测试, 并显示相应的断言消息, 以红颜色显示测试失败:"

#: ../../reference/javascript.rst:915
msgid "Fixing the test (by replacing ``false`` to ``true`` in the assertion) will make it pass:"
msgstr "固定测试（通过更换 ``false`` 到值为 ``True`` 的说法）, 将它传递:"

#: ../../reference/javascript.rst:922
msgid "Assertions"
msgstr "断言"

#: ../../reference/javascript.rst:924
msgid "As noted above, Odoo Web's tests use `qunit assertions`_. They are available globally (so they can just be called without references to anything). The following list is available:"
msgstr "如上所述, Odoo网络的测试使用 `qunit assertions` _。他们可在全球范围（这样他们可以在没有引用调用任何东西）。下面的列表是可用:"

#: ../../reference/javascript.rst:930
msgid "checks that ``state`` is truthy (in the javascript sense)"
msgstr "将检查 ``state`` 是truthy（在JavaScript的意义上）"

#: ../../reference/javascript.rst:934
msgid "checks that the actual (produced by a method being tested) and expected values are identical (roughly equivalent to ``ok(actual === expected, message)``)"
msgstr "将检查的实际（通过一个方法制造所测试）和预期值是相同的（大致相当于 ``预期确定（实际===, 消息）`` ）"

#: ../../reference/javascript.rst:940
msgid "checks that the actual and expected values are *not* identical (roughly equivalent to ``ok(actual !== expected, message)``)"
msgstr "检查实际值和预期值是 *不* 相同（大致相当于 ``OK（实际！==预期, 消息）`` ）"

#: ../../reference/javascript.rst:945
msgid "deep comparison between actual and expected: recurse into containers (objects and arrays) to ensure that they have the same keys/number of elements, and the values match."
msgstr "之间的实际和预期的深比较:递归到容器（对象和数组）, 以确保它们具有相同的键/元件的数目, 以及值匹配。"

#: ../../reference/javascript.rst:951
msgid "inverse operation to :func:`deepEqual`"
msgstr "反向操作 :func:`deepEqual` "

#: ../../reference/javascript.rst:955
msgid "checks that, when called, the ``block`` throws an error. Optionally validates that error against ``expected``."
msgstr "检查, 调用它时, 在 ``block`` 抛出一个错误。可选验证对 ``expected`` 的错误。"

#: ../../reference/javascript.rst:959
msgid "if a regexp, checks that the thrown error's message matches the regular expression. If an error type, checks that the thrown error is of that type."
msgstr "如果一个正则表达式, 检查, 抛出的错误的信息的正则表达式匹配。如果错误类型, 检查, 抛出的错误是类型。"

#: ../../reference/javascript.rst:967
msgid "checks that ``actual`` and ``expected`` are loosely equal, using the ``==`` operator and its coercion rules."
msgstr "将检查 ``actual`` 和 ``expected`` 松散相等, 使用 ``==`` 运营商和它的强制规则。"

#: ../../reference/javascript.rst:972
msgid "inverse operation to :func:`equal`"
msgstr "反向操作 :func:`equal` "

#: ../../reference/javascript.rst:975
msgid "Getting an Odoo instance"
msgstr "获得一个Odoo实例"

#: ../../reference/javascript.rst:977
msgid "The Odoo instance is the base through which most Odoo Web modules behaviors (functions, objects, …) are accessed. As a result, the test framework automatically builds one, and loads the module being tested and all of its dependencies inside it. This new instance is provided as the first positional parameter to your test cases. Let's observe by adding javascript code (not test code) to the test module:"
msgstr "该Odoo实例是通过它最Odoo Web模块的行为（函数, 对象, ...）进行访问的基础。其结果是, 在测试的框架自动建立的, 并加载被测试的模块和所有其它里面的依赖关系。这个新的实例被提供作为第一位置参数测试用例。我们观察到通过添加JavaScript代码（不是测试代码）, 以测试模块:"

#: ../../reference/javascript.rst:1009
msgid "and then adding a new test case, which simply checks that the ``instance`` contains all the expected stuff we created in the module::"
msgstr "然后添加一个新的测试用例, 它只是检查了 ``instance`` 包含了我们在模块中创建的所有期望的东西 ::"

#: ../../reference/javascript.rst:1021
msgid "DOM Scratchpad"
msgstr "DOM便签"

#: ../../reference/javascript.rst:1023
msgid "As in the wider client, arbitrarily accessing document content is strongly discouraged during tests. But DOM access is still needed to e.g. fully initialize :class:`widgets <~openerp.Widget>` before testing them."
msgstr "由于在更广泛的客户端, 任意访问文档内容强烈测试期间劝阻。但访问DOM仍然需要如完全初始化 :class:`小部件<~openerp.Widget>` 测试之前。"

#: ../../reference/javascript.rst:1028
msgid "Thus, a test case gets a DOM scratchpad as its second positional parameter, in a jQuery instance. That scratchpad is fully cleaned up before each test, and as long as it doesn't do anything outside the scratchpad your code can do whatever it wants::"
msgstr "因此, 一个测试用例得到一个DOM暂存器作为其第二个位置参数, 在jQuery的实例。这暂存器完全清理每次测试前, 只要它不暂存器外界做任何你的代码可以为所欲为 ::"

#: ../../reference/javascript.rst:1046
msgid "The top-level element of the scratchpad is not cleaned up, test cases can add text or DOM children but shoud not alter ``$scratchpad`` itself."
msgstr "The top-level element of the scratchpad is not cleaned up, test cases can add text or DOM children but shoud not alter ``$scratchpad`` itself."

#: ../../reference/javascript.rst:1051
msgid "Loading templates"
msgstr "加载模板"

#: ../../reference/javascript.rst:1053
msgid "To avoid the corresponding processing costs, by default templates are not loaded into QWeb. If you need to render e.g. widgets making use of QWeb templates, you can request their loading through the :attr:`~TestOptions.templates` option to the :func:`test case function <openerp.testing.case>`."
msgstr "为了避免相应的处理成本, 默认模板不加载到QWeb。 :attr: 如果您需要渲染, 例如部件利用QWeb模板, 可以通过要求其装载 `~TestOptions.templates` 选项到 :func:`测试用例功能<openerp.testing.case>` 。"

#: ../../reference/javascript.rst:1059
msgid "This will automatically load all relevant templates in the instance's qweb before running the test case:"
msgstr "这将自动加载该实例的qweb所有相关的模板运行测试用例之前:"

#: ../../reference/javascript.rst:1097
msgid "Asynchronous cases"
msgstr "异步的情况下"

#: ../../reference/javascript.rst:1099
msgid "The test case examples so far are all synchronous, they execute from the first to the last line and once the last line has executed the test is done. But the web client is full of :ref:`asynchronous code <reference/async>`, and thus test cases need to be async-aware."
msgstr "测试用例例子到目前为止都是同步的, 它们从第一个到最后一个行执行一次最后一行已经执行了测试完成。但Web客户端充满了 :ref:`异步代码<reference/async>` , 因而测试用例需要是异步感知。"

#: ../../reference/javascript.rst:1104
msgid "This is done by returning a :class:`deferred <Deferred>` from the case callback::"
msgstr ":class: 这是通过返回一个完成的情况下, 回调 `递延<递延>` ::"

#: ../../reference/javascript.rst:1119
msgid "This example also uses the :class:`options parameter <TestOptions>` to specify the number of assertions the case should expect, if less or more assertions are specified the case will count as failed."
msgstr "这个例子也使用了 :class:`选项参数<TestOptions>` 指定断言的情况下应该想到, 如果少了以上断言规定的情况下, 将算作失败的次数。"

#: ../../reference/javascript.rst:1123
msgid "Asynchronous test cases *must* specify the number of assertions they will run. This allows more easily catching situations where e.g. the test architecture was not warned about asynchronous operations."
msgstr "异步测试例 *必须* 指定断言他们将运行的次数。这使得更容易捕捉的地方, 例如测试架构是不会警告异步操作的情况。"

#: ../../reference/javascript.rst:1129
msgid "Asynchronous test cases also have a 2 seconds timeout: if the test does not finish within 2 seconds, it will be considered failed. This pretty much always means the test will not resolve. This timeout *only* applies to the test itself, not to the setup and teardown processes."
msgstr "异步测试例也有一个2秒超时:如果测试没有在2秒内完成, 这将被认为是失败的。这几乎总是意味着该测试将无法解决。此超时 **只适用于测试本身, 而不是建立和拆除过程。"

#: ../../reference/javascript.rst:1137
msgid "If the returned deferred is rejected, the test will be failed unless :attr:`~TestOptions.fail_on_rejection` is set to ``false``."
msgstr "如果返回的延期被拒绝, 测试将失败, 除非 :attr:`~TestOptions.fail_on_rejection` 设置为 ``false`` 。"

#: ../../reference/javascript.rst:1144
msgid "An important subset of asynchronous test cases is test cases which need to perform (and chain, to an extent) RPC calls."
msgstr "异步测试案例的一个重要子集试验案件需要执行（和链, 在一定程度上）RPC调用。"

#: ../../reference/javascript.rst:1149
msgid "Because they are a subset of asynchronous cases, RPC cases must also provide a valid :attr:`assertions count <TestOptions.asserts>`."
msgstr "因为它们是异步的情况下的一个子集, RPC案件还必须提供有效的 :attr:`断言计数<TestOptions.asserts>` 。"

#: ../../reference/javascript.rst:1153
msgid "To enable mock RPC, set the :attr:`rpc option <TestOptions.rpc>` to ``mock``. This will add a third parameter to the test case callback:"
msgstr "为了使模拟RPC, 设置 :attr:`RPC选项<TestOptions.rpc>` 来 ``mock`` 。这将第三个参数添加到测试用例回调:"

#: ../../reference/javascript.rst:1158
msgid "Can be used in two different ways depending on the shape of the first parameter:"
msgstr "可以在根据第一个参数的形状的两个不同的方式使用:"

#: ../../reference/javascript.rst:1161
msgid "If it matches the pattern ``model:method`` (if it contains a colon, essentially) the call will set up the mocking of an RPC call straight to the Odoo server (through XMLRPC) as performed via e.g. :func:`openerp.web.Model.call`."
msgstr "如果匹配模式 ``型号:method`` （如果它包含一个冒号, 本质上）的调用将建立一个RPC调用直奔Odoo服务器（通过XMLRPC）的嘲弄通过例如为执行 :func:`的OpenERP .web.Model.call` 。"

#: ../../reference/javascript.rst:1166
msgid "In that case, ``handler`` should be a function taking two arguments ``args`` and ``kwargs``, matching the corresponding arguments on the server side and should simply return the value as if it were returned by the Python XMLRPC handler::"
msgstr "在这种情况下, ``handler`` 应该采取两个参数 ``args`` 和'功能'kwargs ``, 在服务器端匹配相应的参数, 就好像它是由Python返回应该简单地返回值XMLRPC处理器 ::"

#: ../../reference/javascript.rst:1191
msgid "Otherwise, if it matches an absolute path (e.g. ``/a/b/c``) it will mock a JSON-RPC call to a web client controller, such as ``/web/webclient/translations``. In that case, the handler takes a single ``params`` argument holding all of the parameters provided over JSON-RPC."
msgstr "否则, 如果它的绝对路径（如 ``/ A / B / c`` ）匹配, 将模拟的JSON-RPC调用的Web客户端控制器, 如 ``/网络/ Web客户端/ translations`` 。在这种情况下, 处理器只需要一个 ``params`` 参数保存所有设置在JSON-RPC的参数。"

#: ../../reference/javascript.rst:1197
msgid "As previously, the handler should simply return the result value as if returned by the original JSON-RPC handler::"
msgstr "正如前面, 仿佛又回到了原来的JSON-RPC处理程序的处理程序应该简单地返回结果值 ::"

#: ../../reference/javascript.rst:1223
msgid "Mock handlers can contain assertions, these assertions should be part of the assertions count (and if multiple calls are made to a handler containing assertions, it multiplies the effective number of assertions)."
msgstr "模拟处理程序可以包含断言, 这些断言应该是断言的一部分计数（如果通过多次调用包含断言的处理程序, 它乘以断言的有效数字）。"

#: ../../reference/javascript.rst:1229
msgid "Testing API"
msgstr "测试API"

#: ../../reference/javascript.rst:1233
msgid "A test section, serves as shared namespace for related tests (for constants or values to only set up once). The ``body`` function should contain the tests themselves."
msgstr "试验段, 用作相关测试共享命名空间（常量或值只设置一次）。该 ``body`` 功能应包括测试本身。"

#: ../../reference/javascript.rst:1237
msgid "Note that the order in which tests are run is essentially undefined, do *not* rely on it."
msgstr "需要注意的是在测试运行的顺序是不确定的, 不要 *不* 依赖于它。"

#: ../../reference/javascript.rst:1247
msgid "Registers a test case callback in the test runner, the callback will only be run once the runner is started (or maybe not at all, if the test is filtered out)."
msgstr "注册在测试运行测试用例的回调, 回调将只能使用一次亚军开始运行（或者根本没有, 如果测试过滤掉）。"

#: ../../reference/javascript.rst:1258
msgid "the various options which can be passed to :func:`~openerp.testing.section` or :func:`~openerp.testing.case`. Except for :attr:`~TestOptions.setup` and :attr:`~TestOptions.teardown`, an option on :func:`~openerp.testing.case` will overwrite the corresponding option on :func:`~openerp.testing.section` so e.g. :attr:`~TestOptions.rpc` can be set for a :func:`~openerp.testing.section` and then differently set for some :func:`~openerp.testing.case` of that :func:`~openerp.testing.section`"
msgstr ":func: 它可以传递到各个选项 `~openerp.testing.section` 或 :func:`~openerp.testing.case` 。不测 :attr:`~TestOptions.setup` 和 :attr:`~TestOptions.teardown` , 上一个选项 :func:`~openerp.testing.case` 将覆盖在相应的选项 :func:`~openerp.testing .section` 因此如:ATTR :func:`~openerp.testing.section` , 然后不同的一些设置 :func:`~那openerp.testing.case ``~TestOptions.rpc` 可以为设置: :func:`~openerp.testing.section` "

#: ../../reference/javascript.rst:1272
msgid "An integer, the number of assertions which should run during a normal execution of the test. Mandatory for asynchronous tests."
msgstr "一个整数, 这应该试验的正常执行期间运行声明的数目。强制性异步测试。"

#: ../../reference/javascript.rst:1277
msgid "Test case setup, run right before each test case. A section's :func:`~TestOptions.setup` is run before the case's own, if both are specified."
msgstr "测试案例设置, 每个测试用例前正确运行。 A节的 :func:`~TestOptions.setup` 之前运行的情况下自己, 如果两者都指定。"

#: ../../reference/javascript.rst:1283
msgid "Test case teardown, a case's :func:`~TestOptions.teardown` is run before the corresponding section if both are present."
msgstr "测试用例拆解, 案件的 :func:`~TestOptions.teardown` 的相应部分之前运行, 如果两者都存在。"

#: ../../reference/javascript.rst:1288
msgid "If the test is asynchronous and its resulting promise is rejected, fail the test. Defaults to ``true``, set to ``false`` to not fail the test in case of rejection::"
msgstr "如果测试是异步的, 其产生的承诺被拒绝, 失败的考验。默认为 ``True`` , 那么设置为 ``false`` 不未通过测试的情况下拒绝 ::"

#: ../../reference/javascript.rst:1307
msgid "RPC method to use during tests, one of ``\"mock\"`` or ``\"rpc\"``. Any other value will disable RPC for the test (if they were enabled by the suite for instance)."
msgstr "RPC方法在测试过程中使用, 对 ``'模拟'`` 或 ``'RPC'`` 之一。任何其他值将禁用RPC的测试（如果他们的套件, 例如启用）。"

#: ../../reference/javascript.rst:1313
msgid "Whether the current module (and its dependencies)'s templates should be loaded into QWeb before starting the test. A boolean, ``false`` by default."
msgstr "无论是当前模块（及其附属）的模板应该被装入QWeb开始测试之前。一个布尔值, ``默认false`` 。"

#: ../../reference/javascript.rst:1317
msgid "The test runner can also use two global configuration values set directly on the ``window`` object:"
msgstr "测试运行也可以将 ``window`` 对象上直接使用设置两个全局配置值:"

#: ../../reference/javascript.rst:1320
msgid "``oe_all_dependencies`` is an ``Array`` of all modules with a web component, ordered by dependency (for a module ``A`` with dependencies ``A'``, any module of ``A'`` must come before ``A`` in the array)"
msgstr " ``oe_all_dependencies`` 是 ``Array`` 与Web组件的所有模块, 订购的相关性（对于一个模块 ``有依赖性A````A'`` 中, ``A'`` 任何模块必须A ``前`` 都在阵列中）"

#: ../../reference/javascript.rst:1326
msgid "Running through Python"
msgstr "通过Python的运行"

#: ../../reference/javascript.rst:1328
msgid "The web client includes the means to run these tests on the command-line (or in a CI system), but while actually running it is pretty simple the setup of the pre-requisite parts has some complexities."
msgstr "Web客户端包括在其上运行命令行（或在CI系统）这些测试的手段, 但在实际运行它是非常简单的先决条件部分的设置有一定的复杂性。"

#: ../../reference/javascript.rst:1333
msgid "Install PhantomJS_. It is a headless browser which allows automating running and testing web pages. QUnitSuite_ uses it to actually run the qunit_ test suite."
msgstr "安装PhantomJS_。这是它允许自动运行和测试网页的无头的浏览器。 QUnitSuite_用它来实际运行qunit_测试套件。"

#: ../../reference/javascript.rst:1337
msgid "The PhantomJS_ website provides pre-built binaries for some platforms, and your OS's package management probably provides it as well."
msgstr "该PhantomJS_网站提供预先生成的二进制文件, 一些平台, 和你的操作系统的包管理可能提供它。"

#: ../../reference/javascript.rst:1341
msgid "If you're building PhantomJS_ from source, I recommend preparing for some knitting time as it's not exactly fast (it needs to compile both `Qt <http://qt-project.org/>`_ and `Webkit <http://www.webkit.org/>`_, both being pretty big projects)."
msgstr "If you're building PhantomJS_ from source, I recommend preparing for some knitting time as it's not exactly fast (it needs to compile both `Qt <http ://qt-project.org/>` _ and `Webkit <http: //www.webkit.org/>` _, both being pretty big projects)."

#: ../../reference/javascript.rst:1348
msgid "Because PhantomJS_ is webkit-based, it will not be able to test if Firefox, Opera or Internet Explorer can correctly run the test suite (and it is only an approximation for Safari and Chrome). It is therefore recommended to *also* run the test suites in actual browsers once in a while."
msgstr "由于PhantomJS_是基于WebKit的, 它无法测试, 如果火狐, 歌剧或Internet Explorer可以正确运行测试套件（这只是一个近似值的Safari和Chrome）。因此, 建议为 *也* 运行在实际的浏览器测试套件曾经在一段时间。"

#: ../../reference/javascript.rst:1356
msgid "The version of PhantomJS_ this was build through is 1.7, previous versions *should* work but are not actually supported (and tend to just segfault when something goes wrong in PhantomJS_ itself so they're a pain to debug)."
msgstr "PhantomJS_的版本, 这是通过构建是1.7, 以前的版本 *应* 工作, 但实际上并没有支持（而且往往只是段错误的时候出现错误的PhantomJS_本身, 以便他们是一个痛苦的调试）。"

#: ../../reference/javascript.rst:1361
msgid "Install a new database with all relevant modules (all modules with a web component at least), then restart the server"
msgstr "安装与所有相关的模块, 一个新的数据库（至少一个网络组件的所有模块）, 然后重新启动服务器"

#: ../../reference/javascript.rst:1366
msgid "For some tests, a source database needs to be duplicated. This operation requires that there be no connection to the database being duplicated, but Odoo doesn't currently break existing/outstanding connections, so restarting the server is the simplest way to ensure everything is in the right state."
msgstr "对于一些测试, 源数据库需要被复制。此操作要求有与数据库连接不被复制, 但Odoo目前不破坏现有/未完成的连接, 所以重新启动服务器, 以确保一切都在正确的状态, 最简单的方法。"

#: ../../reference/javascript.rst:1372
msgid "Launch ``oe run-tests -d $DATABASE -mweb`` with the correct addons-path specified (and replacing ``$DATABASE`` by the source database you created above)"
msgstr "Launch ``oe run-tests -d $DATABASE -mweb`` with the correct addons-path specified (and replacing ``$DATABASE`` by the source database you created above)"

#: ../../reference/javascript.rst:1378
msgid "If you leave out ``-mweb``, the runner will attempt to run all the tests in all the modules, which may or may not work."
msgstr "如果你离开了 ``-mweb`` , 亚军将尝试在所有的模块, 这可能会或可能无法正常工作运行所有测试。"

#: ../../reference/javascript.rst:1381
msgid "If everything went correctly, you should now see a list of tests with (hopefully) ``ok`` next to their names, closing with a report of the number of tests run and the time it took:"
msgstr "如果一切正常, 你现在应该看到的测试与列表（希望） ``ok`` 他们的名字旁边, 缩小与试验次数的报告运行, 并花时间:"

#: ../../reference/javascript.rst:1388
msgid "Congratulation, you have just performed a successful \"offline\" run of the OpenERP Web test suite."
msgstr "恭喜你, 你刚刚成功执行了'离线'的OpenERP的Web测试套件的运行。"

#: ../../reference/javascript.rst:1393
msgid "Note that this runs all the Python tests for the ``web`` module, but all the web tests for all of Odoo. This can be surprising."
msgstr "请注意, 此运行所有的Python测试的 ``web`` 模块, 但所有的Web测试所有Odoo的。这可能是令人惊讶的。"

#: ../../reference/javascript.rst:1404
msgid "not all DOM events are compatible with events delegation"
msgstr "不是所有的DOM事件与事件代表团兼容"

#: ../../reference/javascript.rst:1407
msgid "with a small twist: :py:meth:`sqlalchemy.orm.query.Query.group_by` is not terminal, it returns a query which can still be altered."
msgstr "与一小搓::PY :meth:`sqlalchem​​y.orm.query.Query.group_by` 不是终端, 它返回它仍然可以改变的查询。"

#: ../../reference/module.rst:5
msgid "Modules"
msgstr "模块"

#: ../../reference/module.rst:12
msgid "Manifest"
msgstr "Manifest"

#: ../../reference/module.rst:14
msgid "The manifest file serves to declare a python package as an Odoo module and to specify module metadata."
msgstr "清单文件用于声明一个Python包作为Odoo模块, 并指定模块的元数据。"

#: ../../reference/module.rst:17
msgid "It is a file called ``__openerp__.py`` and contains a single Python dictionary, where each key specifies module metadatum."
msgstr "这是一个被称为 ``__openerp __。py`` 文件, 并包含一个Python字典, 其中每个键指定模块metadatum。"

#: ../../reference/module.rst:41
msgid "Available manifest fields are:"
msgstr "可用清单字段有:"

#: ../../reference/module.rst:43
msgid "``name`` (``str``, required)"
msgstr " ``name`` （ ``str`` , 必需）"

#: ../../reference/module.rst:44
msgid "the human-readable name of the module"
msgstr "模块的人类可读名称"

#: ../../reference/module.rst:45
msgid "``version`` (``str``)"
msgstr " ``version`` （ ``str`` ）"

#: ../../reference/module.rst:46
msgid "this module's version, should follow `semantic versioning`_ rules"
msgstr "该模块的版本, 应该遵循 `语义versioning` _规则"

#: ../../reference/module.rst:47
msgid "``description`` (``str``)"
msgstr " ``description`` （ ``str`` ）"

#: ../../reference/module.rst:48
msgid "extended description for the module, in reStructuredText"
msgstr "扩展描述为模块, 在reStructuredText的"

#: ../../reference/module.rst:49
msgid "``author`` (``str``)"
msgstr " ``author`` （ ``str`` ）"

#: ../../reference/module.rst:50
msgid "name of the module author"
msgstr "的模块作者姓名"

#: ../../reference/module.rst:51
msgid "``website`` (``str``)"
msgstr " ``website`` （ ``str`` ）"

#: ../../reference/module.rst:52
msgid "website URL for the module author"
msgstr "网站的网址为模块作者"

#: ../../reference/module.rst:53
msgid "``license`` (``str``, defaults: ``LGPL-3``)"
msgstr " ``license`` ( ``str`` , 默认 :``LGPL-3`` )"

#: ../../reference/module.rst:54
msgid "distribution license for the module"
msgstr "该模块分发许可证"

#: ../../reference/module.rst:61
msgid "``category`` (``str``, default: ``Uncategorized``)"
msgstr " ``category`` （ ``str`` , 默认:``Uncategorized`` ）"

#: ../../reference/module.rst:56
msgid "classification category within Odoo, rough business domain for the module."
msgstr "在Odoo分类类别, 该模块粗糙的业务字段。"

#: ../../reference/module.rst:58
msgid "Although using `existing categories`_ is recommended, the field is freeform and unknown categories are created on-the-fly. Category hierarchies can be created using the separator ``/`` e.g. ``Foo / Bar`` will create a category ``Foo``, a category ``Bar`` as child category of ``Foo``, and will set ``Bar`` as the module's category."
msgstr "虽然使用 `现有categories` _建议, 该字段为自由和未知类别的即时创建。可以使用分离器 ``创建类别层次结构/`` 如 ``美孚/ Bar`` 将创建类 ``Foo`` , 一类 ``Bar`` 为 ``Foo`` 子类, 并将设置 ``Bar`` 作为模块的类别。"

#: ../../reference/module.rst:68
msgid "``depends`` (``list(str)``)"
msgstr " ``depends`` （ ``名单（STR）`` ）"

#: ../../reference/module.rst:64
msgid "Odoo modules which must be loaded before this one, either because this module uses features they create or because it alters resources they define."
msgstr "必须这个之前加载, 或者是因为该模块使用他们所创造的功能或者是因为它改变了资源, 他们定义Odoo模块。"

#: ../../reference/module.rst:68
msgid "When a module is installed, all of its dependencies are installed before it. Likewise dependencies are loaded before a module is loaded."
msgstr "当安装一个模块, 其所有相关之前安装。同样地, 一个模块被加载之前, 依赖被加载。"

#: ../../reference/module.rst:71
msgid "``data`` (``list(str)``)"
msgstr " ``data`` ( ``list(str)`` )"

#: ../../reference/module.rst:71
msgid "List of data files which must always be installed or updated with the module. A list of paths from the module root directory"
msgstr "的必须始终安装或更新与模块数据文件列表。路径从模块根目录清单"

#: ../../reference/module.rst:74
msgid "``demo`` (``list(str)``)"
msgstr " ``demo`` （ ``名单（STR）`` ）"

#: ../../reference/module.rst:74
msgid "List of data files which are only installed or updated in *demonstration mode*"
msgstr "哪只安装或 *演示模式更新的数据文件列表*"

#: ../../reference/module.rst:86
msgid "``auto_install`` (``bool``, default: ``False``)"
msgstr " ``auto_install`` （ ``bool`` , 默认:``False`` ）"

#: ../../reference/module.rst:77
msgid "If ``True``, this module will automatically be installed if all of its dependencies are installed."
msgstr "如果 ``True`` , 那么这个模块将被自动如果所有的依赖也都安装安装。"

#: ../../reference/module.rst:80
msgid "It is generally used for \"link modules\" implementing synergic integration between two otherwise independent modules."
msgstr "它一般用于'链接模块'执行两个原本独立模块之间协同集成。"

#: ../../reference/module.rst:83
msgid "For instance ``sale_crm`` depends on both ``sale`` and ``crm`` and is set to ``auto_install``. When both ``sale`` and ``crm`` are installed, it automatically adds CRM campaigns tracking to sale orders without either ``sale`` or ``crm`` being aware of one another"
msgstr "例如 ``sale_crm`` 取决于双方 ``sale`` 和 ``crm`` 并设置为 ``auto_install`` 。当两个 ``sale`` 和 ``安装crm`` , 它会自动将客户关系管理的运动跟踪到销售订单没有任何 ``sa​​le`` 或 ``crm`` 意识到彼此"

#: ../../reference/orm.rst:7
msgid "ORM API"
msgstr "ORM API"

#: ../../reference/orm.rst:10
msgid "Recordsets"
msgstr "记录集"

#: ../../reference/orm.rst:14
msgid "This page documents the New API added in Odoo 8.0 which should be the primary development API going forward. It also provides information about porting from or bridging with the \"old API\" of versions 7 and earlier, but does not explicitly document that API. See the old documentation for that."
msgstr "这页记录了新的API中Odoo 8.0加入这应该是主要的开发API前进。它也提供了有关从早期移植或与版本7的'旧的API'桥接和信息, 但没有明确记载该API。看到老文档的。"

#: ../../reference/orm.rst:19
msgid "Interaction with models and records is performed through recordsets, a sorted set of records of the same model."
msgstr "模型和记录的交互是通过记录集执行的, 记录集是同一模型的记录的有序集合。"

#: ../../reference/orm.rst:22
msgid "contrary to what the name implies, it is currently possible for recordsets to contain duplicates. This may change in the future."
msgstr "相反的是顾名思义, 它是目前可能的记录包含重复。这可能会改变未来。"

#: ../../reference/orm.rst:25
msgid "Methods defined on a model are executed on a recordset, and their ``self`` is a recordset::"
msgstr "在模型中定义的方法是在一个记录执行的, 他们的 ``self`` 是一个记录 ::"

#: ../../reference/orm.rst:35
msgid "Iterating on a recordset will yield new sets of *a single record* (\"singletons\"), much like iterating on a Python string yields strings of a single characters::"
msgstr "在迭代的记录将产生的 *单个记录* 新集（'单身'）, 很像迭代在Python字符串的单个字符的字符串收益率 ::"

#: ../../reference/orm.rst:45
msgid "Field access"
msgstr "字段访问"

#: ../../reference/orm.rst:47
msgid "Recordsets provide an \"Active Record\" interface: model fields can be read and written directly from the record, but only on singletons (single-record recordsets). Setting a field's value triggers an update to the database::"
msgstr "记录集提供了一个'活动记录'界面:示范田可以读取并直接从记录写的, 但仅限于单件（单记录的记录）。设置字段的值触发更新到数据库 ::"

#: ../../reference/orm.rst:57
msgid "Trying to read or write a field on multiple records will raise an error."
msgstr "尝试在多个记录读或写一个字段将产生一个错误。"

#: ../../reference/orm.rst:59
msgid "Accessing a relational field (:class:`~openerp.fields.Many2one`, :class:`~openerp.fields.One2many`, :class:`~openerp.fields.Many2many`) *always* returns a recordset, empty if the field is not set."
msgstr "访问关系字段（ :class:`~openerp.fields.Many2one` , :class:`~openerp.fields.One2many` , :class:`~openerp.fields.Many2many` ） *总* 返回记录集, 空if现场未设置。"

#: ../../reference/orm.rst:65
msgid "each assignment to a field triggers a database update, when setting multiple fields at the same time or setting fields on multiple records (to the same value), use :meth:`~openerp.models.Model.write`::"
msgstr "每个分配到一个场触发数据库更新, 设置多个字段同时时或设置在多个记录中的字段（为相同的值）, 使用 :meth:`~openerp.models.Model.write` ::"

#: ../../reference/orm.rst:83
msgid "Set operations"
msgstr "集合操作"

#: ../../reference/orm.rst:85
msgid "Recordsets are immutable, but sets of the same model can be combined using various set operations, returning new recordsets. Set operations do *not* preserve order."
msgstr "记录集是不可变的, 但台同型号的可以使用各种集合运算结合起来, 返回新的记录集。 Set操作 *不* 维持秩序。"

#: ../../reference/orm.rst:91
msgid "``record in set`` returns whether ``record`` (which must be a 1-element recordset) is present in ``set``. ``record not in set`` is the inverse operation"
msgstr " ``在set`` 记录返回是否 ``record`` （必须是1元的记录）出现在 ``set`` 。 ``不set`` 记录是反向操作"

#: ../../reference/orm.rst:94
msgid "``set1 | set2`` returns the union of the two recordsets, a new recordset containing all records present in either source"
msgstr " ``set1 | set2`` 返回两个记录集的合集, 包含目前在这两个源的所有记录的新记录"

#: ../../reference/orm.rst:96
msgid "``set1 & set2`` returns the intersection of two recordsets, a new recordset containing only records present in both sources"
msgstr " ``set1 & set2`` 返回两个记录集的交集, 包括存在于所有源中的记录的新记录集"

#: ../../reference/orm.rst:98
msgid "``set1 - set2`` returns a new recordset containing only records of ``set1`` which are *not* in ``set2``"
msgstr " ``集1 - set2`` 返回包含 ``set1`` 只有那些 *没有 `* 记录的新记录` set2 ``"

#: ../../reference/orm.rst:102
msgid "Other recordset operations"
msgstr "其他记录集操作"

#: ../../reference/orm.rst:104
msgid "Recordsets are iterable so the usual Python tools are available for transformation (:func:`python:map`, :func:`python:sorted`, :func:`~python:itertools.ifilter`, ...) however these return either a :class:`python:list` or an :term:`python:iterator`, removing the ability to call methods on their result, or to use set operations."
msgstr "记录集是可迭代所以平时Python的工具可用于改造（ :func:`Python:map` , :func:`Python:sorted` , :func:`~Python:itertools.ifilter` , ...）, 但这些收益或者是 :class:`Python:list` 或 :term:`Python:iterator` , 除去调用他们的结果的方法, 或者采用集合运算的能力。"

#: ../../reference/orm.rst:110
msgid "Recordsets therefore provide these operations returning recordsets themselves (when possible):"
msgstr "因此, 记录集提供这些操作返回记录本身（如果可能）:"

#: ../../reference/orm.rst:122
msgid ":meth:`~openerp.models.Model.filtered`"
msgstr ":meth:`~openerp.models.Model.filtered` "

#: ../../reference/orm.rst:114
msgid "returns a recordset containing only records satisfying the provided predicate function. The predicate can also be a string to filter by a field being true or false::"
msgstr "返回一个包含只记录满足谓词提供的功能的记录。谓词也可以是一个字符串由场筛选为真或假的 ::"

#: ../../reference/orm.rst:129
msgid ":meth:`~openerp.models.Model.sorted`"
msgstr ":meth:`~openerp.models.Model.sorted` "

#: ../../reference/orm.rst:125
msgid "returns a recordset sorted by the provided key function. If no key is provided, use the model's default sort order::"
msgstr "返回记录集排序所提供的关键功能。如果不提供密钥, 使用模型的默认排序次序 ::"

#: ../../reference/orm.rst:147
msgid ":meth:`~openerp.models.Model.mapped`"
msgstr ":meth:`~openerp.models.Model.mapped` "

#: ../../reference/orm.rst:132
msgid "applies the provided function to each record in the recordset, returns a recordset if the results are recordsets::"
msgstr "应用所提供的功能, 在记录每个记录, 返回记录集, 如果结果记录集 ::"

#: ../../reference/orm.rst:138
msgid "The provided function can be a string to get field values::"
msgstr "所提供的功能可以是一个字符串, 以获取字段值 ::"

#: ../../reference/orm.rst:150
msgid "Environment"
msgstr "环境"

#: ../../reference/orm.rst:152
msgid "The :class:`~openerp.api.Environment` stores various contextual data used by the ORM: the database cursor (for database queries), the current user (for access rights checking) and the current context (storing arbitrary metadata). The environment also stores caches."
msgstr "的 :class:`~所使用的ORM openerp.api.Environment` 存储各种上下文数据:数据库光标（数据库查询）, 当前用户（用于访问权限检查）, 当前的上下文（存储任意元数据）。环境还存储高速缓存。"

#: ../../reference/orm.rst:157
msgid "All recordsets have an environment, which is immutable, can be accessed using :attr:`~openerp.models.Model.env` and gives access to the current user (:attr:`~openerp.api.Environment.user`), the cursor (:attr:`~openerp.api.Environment.cr`) or the context (:attr:`~openerp.api.Environment.context`)::"
msgstr "所有记录集有一个环境, 这是不可改变的, 可以使用访问 :attr:`~openerp.models.Model.env` 并允许访问当前用户（ :attr:`~openerp.api.Environment.user` ）光标（ :attr:`~openerp.api.Environment.cr` ）或上下文（ :attr:`~openerp.api.Environment.context` ） ::"

#: ../../reference/orm.rst:170
msgid "When creating a recordset from an other recordset, the environment is inherited. The environment can be used to get an empty recordset in an other model, and query that model::"
msgstr "当创建从其他记录的记录, 环境被继承。环境还可以用于获取在其他模型中一个空的记录, 并查询该型号 ::"

#: ../../reference/orm.rst:180
msgid "Altering the environment"
msgstr "改变环境"

#: ../../reference/orm.rst:182
msgid "The environment can be customized from a recordset. This returns a new version of the recordset using the altered environment."
msgstr "环境可以从一个记录进行定制。这将返回使用改变环境记录的新版本。"

#: ../../reference/orm.rst:196
msgid ":meth:`~openerp.models.Model.sudo`"
msgstr ":meth:`~openerp.models.Model.sudo` "

#: ../../reference/orm.rst:186
msgid "creates a new environment with the provided user set, uses the administrator if none is provided (to bypass access rights/rules in safe contexts), returns a copy of the recordset it is called on using the new environment::"
msgstr "创建与所提供的用户设置一个新的环境, 使用系统管理员如果没有提供（旁路存取权限/在安全上下文中的规则）, 返回它被称为使用新的环境记录的副本 ::"

#: ../../reference/orm.rst:208
msgid ":meth:`~openerp.models.Model.with_context`"
msgstr ":meth:`~openerp.models.Model.with_context` "

#: ../../reference/orm.rst:199
msgid "can take a single positional parameter, which replaces the current environment's context"
msgstr "可以采取一个位置参数, 它取代了当前环境的上下文"

#: ../../reference/orm.rst:201
msgid "can take any number of parameters by keyword, which are added to either the current environment's context or the context set during step 1"
msgstr "可以采取任何数量的按关键词参数, 它们被加入到任何当前环境的上下文或上下文在步骤1设置"

#: ../../reference/orm.rst:211
msgid ":meth:`~openerp.models.Model.with_env`"
msgstr ":meth:`~openerp.models.Model.with_env` "

#: ../../reference/orm.rst:211
msgid "replaces the existing environment entirely"
msgstr "取代了现有的环境完全"

#: ../../reference/orm.rst:214
msgid "Common ORM methods"
msgstr "常见的ORM方法"

#: ../../reference/orm.rst:230
msgid ":meth:`~openerp.models.Model.search`"
msgstr ":meth:`~openerp.models.Model.search` "

#: ../../reference/orm.rst:219
msgid "Takes a :ref:`search domain <reference/orm/domains>`, returns a recordset of matching records. Can return a subset of matching records (``offset`` and ``limit`` parameters) and be ordered (``order`` parameter)::"
msgstr "需要 :ref:`搜索域<reference/orm/domains>` , 返回匹配记录的记录。可以返回匹配记录的一个子集（ ``offset`` 和 ``limit`` 参数）并责令（ ``order`` 参数） ::"

#: ../../reference/orm.rst:229
msgid "to just check if any record matches a domain, or count the number of records which do, use :meth:`~openerp.models.Model.search_count`"
msgstr "只是检查是否有任何记录中域相匹配, 或计数的记录里面做数量, 用途 :meth:`~openerp.models.Model.search_count` "

#: ../../reference/orm.rst:237
msgid ":meth:`~openerp.models.Model.create`"
msgstr ":meth:`~openerp.models.Model.create` "

#: ../../reference/orm.rst:233
msgid "Takes a number of field values, and returns a recordset containing the record created::"
msgstr "采用数字字段的值, 然后返回一个包含创建的记录的记录集 ::"

#: ../../reference/orm.rst:243
msgid ":meth:`~openerp.models.Model.write`"
msgstr ":meth:`~openerp.models.Model.write` "

#: ../../reference/orm.rst:240
msgid "Takes a number of field values, writes them to all the records in its recordset. Does not return anything::"
msgstr "采用数字字段的值, 并将其写入到其记录的所有记录。不返回任何东西 ::"

#: ../../reference/orm.rst:252
msgid ":meth:`~openerp.models.Model.browse`"
msgstr ":meth:`~openerp.models.Model.browse` "

#: ../../reference/orm.rst:246
msgid "Takes a database id or a list of ids and returns a recordset, useful when record ids are obtained from outside Odoo (e.g. round-trip through external system) or :ref:`when calling methods in the old API <reference/orm/oldapi>`::"
msgstr "采用的是数据库ID或ID的列表, 并返回一个记录, 用时记录ID从获得Odoo外（例如, 通过外部系统往返）或 :ref:`调用旧的API <reference/orm/oldapi>` ::"

#: ../../reference/orm.rst:266
msgid ":meth:`~openerp.models.Model.exists`"
msgstr ":meth:`~openerp.models.Model.exists` "

#: ../../reference/orm.rst:255
msgid "Returns a new recordset containing only the records which exist in the database. Can be used to check whether a record (e.g. obtained externally) still exists::"
msgstr "返回一个只包含在数据库中存在的记录的新记录。可用于检查记录（如外部获得）是否仍然存在 ::"

#: ../../reference/orm.rst:262
msgid "or after calling a method which could have removed some records::"
msgstr "或者调用一个方法可能已删除了部分记录后 ::"

#: ../../reference/orm.rst:273
msgid ":meth:`~openerp.api.Environment.ref`"
msgstr ":meth:`~openerp.api.Environment.ref` "

#: ../../reference/orm.rst:269
msgid "Environment method returning the record matching a provided :term:`external id`::"
msgstr "环境方法返回的记录匹配提供 :term:`外部ID` ::"

#: ../../reference/orm.rst:281
msgid ":meth:`~openerp.models.Model.ensure_one`"
msgstr ":meth:`~openerp.models.Model.ensure_one` "

#: ../../reference/orm.rst:276
msgid "checks that the recordset is a singleton (only contains a single record), raises an error otherwise::"
msgstr "检查该记录是单（只包含一个记录）, 否则会引发错误 ::"

#: ../../reference/orm.rst:284
msgid "Creating Models"
msgstr "创建模型"

#: ../../reference/orm.rst:286
msgid "Model fields are defined as attributes on the model itself::"
msgstr "模型字段被定义为在模型本身的属性 ::"

#: ../../reference/orm.rst:294
msgid "this means you can not define a field and a method with the same name, they will conflict"
msgstr "这意味着你不能定义一个字段, 并使用相同的名称的方法, 他们会发生冲突"

#: ../../reference/orm.rst:297
msgid "By default, the field's label (user-visible name) is a capitalized version of the field name, this can be overridden with the ``string`` parameter::"
msgstr "默认情况下, 该字段的标签（用户可见的名字）是字段名称的大写版本, 这可以用 ``string`` 参数覆盖 ::"

#: ../../reference/orm.rst:302
msgid "For the various field types and parameters, see :ref:`the fields reference <reference/orm/fields>`."
msgstr "对于这些不同的字段类型和参数, 请参阅 :ref:`字段的参考<reference/orm/fields>` 。"

#: ../../reference/orm.rst:305
msgid "Default values are defined as parameters on fields, either a value::"
msgstr "缺省值被定义为在字段参数, 一个值 ::"

#: ../../reference/orm.rst:309
msgid "or a function called to compute the default value, which should return that value::"
msgstr "或称为一个函数来计算的默认值, 这应该返回值 ::"

#: ../../reference/orm.rst:317
msgid "Computed fields"
msgstr "计算字段"

#: ../../reference/orm.rst:319
msgid "Fields can be computed (instead of read straight from the database) using the ``compute`` parameter. **It must assign the computed value to the field**. If it uses the values of other *fields*, it should specify those fields using :func:`~openerp.api.depends`::"
msgstr "字段可以计算（而不是直接来自于数据库读取）使用 ``compute`` 参数。 **必须的计算值分配给现场** 。如果使用其他 *字段* 的值, 就应该使用指定的字段 :func:`~openerp.api.depends` ::"

#: ../../reference/orm.rst:332
msgid "dependencies can be dotted paths when using sub-fields::"
msgstr "依赖关系可以使用子字段时加以点缀路径 ::"

#: ../../reference/orm.rst:339
msgid "computed fields are not stored by default, they are computed and returned when requested. Setting ``store=True`` will store them in the database and automatically enable searching"
msgstr "计算字段不默认存储, 它们计算时要求返回。设置 ``店= True`` 将它们存储在数据库中, 自动启用搜索"

#: ../../reference/orm.rst:342
msgid "searching on a computed field can also be enabled by setting the ``search`` parameter. The value is a method name returning a :ref:`reference/orm/domains`::"
msgstr "搜索上一计算字段也可以通过设置 ``search`` 参数启用。该值是一个方法名返回 :ref:`reference/orm/domains` ::"

#: ../../reference/orm.rst:353
msgid "to allow *setting* values on a computed field, use the ``inverse`` parameter. It is the name of a function reversing the computation and setting the relevant fields::"
msgstr "让 *设置* 上的计算字段的值, 使用 ``inverse`` 参数。它是一个函数的名称反转的计算和设定相关字段 ::"

#: ../../reference/orm.rst:369
msgid "multiple fields can be computed at the same time by the same method, just use the same method on all fields and set all of them::"
msgstr "多个字段可以在同一时间通过相同的方法来计算, 只要使用相同的方法在所有的字段, 设置所有这些 ::"

#: ../../reference/orm.rst:384
msgid "Related fields"
msgstr "相关字段"

#: ../../reference/orm.rst:386
msgid "A special case of computed fields are *related* (proxy) fields, which provide the value of a sub-field on the current record. They are defined by setting the ``related`` parameter and like regular computed fields they can be stored::"
msgstr "计算字段的特殊情况是 **相关（代理）字段, 其提供的子场对当前记录的值。它们通过将 ``related`` 参数和类似的定期计算的字段中定义, 它们可以存储 ::"

#: ../../reference/orm.rst:394
msgid "onchange: updating UI on the fly"
msgstr "onchange:快速更新UI"

#: ../../reference/orm.rst:396
msgid "When a user changes a field's value in a form (but hasn't saved the form yet), it can be useful to automatically update other fields based on that value e.g. updating a final total when the tax is changed or a new invoice line is added."
msgstr "当用户在表单中改变字段的值（但还没有保存形式还）, 它可能是有用的基于该值, 例如更新最后总当税收被更改或新的发票行是自动更新等字段添加。"

#: ../../reference/orm.rst:401
msgid "computed fields are automatically checked and recomputed, they do not need an ``onchange``"
msgstr "计算字段自动检查并重新计算, 他们并不需要一个 ``onchange`` "

#: ../../reference/orm.rst:403
msgid "for non-computed fields, the :func:`~openerp.api.onchange` decorator is used to provide new field values::"
msgstr "对于非计算字段, :func:`~openerp.api.onchange` 装饰器用于提供新的字段值 ::"

#: ../../reference/orm.rst:411
msgid "the changes performed during the method are then sent to the client program and become visible to the user"
msgstr "该方法的过程中进行的变化, 然后发送到客户端程序, 并成为对用户可见"

#: ../../reference/orm.rst:414
msgid "Both computed fields and new-API onchanges are automatically called by the client without having to add them in views"
msgstr "这两种计算字段和新的API onchanges是由客户端自动调用, 而无需添加他们的意见"

#: ../../reference/orm.rst:416
msgid "It is possible to suppress the trigger from a specific field by adding ``on_change=\"0\"`` in a view::"
msgstr "有可能通过在视图中加入 ``on_change ='0'`` 抑制从一个特定字段触发 ::"

#: ../../reference/orm.rst:421
msgid "will not trigger any interface update when the field is edited by the user, even if there are function fields or explicit onchange depending on that field."
msgstr "将不触发任何界面更新时的电场是由用户编​​辑, 即使有功能字段或显式的onchange取决于该字段。"

#: ../../reference/orm.rst:427
msgid "``onchange`` methods work on virtual records assignment on these records is not written to the database, just used to know which value to send back to the client"
msgstr " ``onchange`` 方法对转让对这些记录不会被写入到数据库虚拟的记录工作, 只用了才知道要发送的值返回给客户端"

#: ../../reference/orm.rst:432
msgid "Low-level SQL"
msgstr "低级别的SQL"

#: ../../reference/orm.rst:434
msgid "The :attr:`~openerp.api.Environment.cr` attribute on environments is the cursor for the current database transaction and allows executing SQL directly, either for queries which are difficult to express using the ORM (e.g. complex joins) or for performance reasons::"
msgstr "本 :attr:`~openerp.api.Environment.cr` 对环境属性是光标用于当前数据库事务, 并允许直接执行SQL语句, 无论是查询这是很难用ORM来表达（如复杂的连接）或性能原因 ::"

#: ../../reference/orm.rst:441
msgid "Because models use the same cursor and the :class:`~openerp.api.Environment` holds various caches, these caches must be invalidated when *altering* the database in raw SQL, or further uses of models may become incoherent. It is necessary to clear caches when using ``CREATE``, ``UPDATE`` or ``DELETE`` in SQL, but not ``SELECT`` (which simply reads the database)."
msgstr "由于车型使用相同的光标和 :class:`~openerp.api.Environment` 拥有多项高速缓存, 这些缓存必须失效时, *改变* 原始SQL或模型进一步使用的数据库可能会变得语无伦次。它在使用 ``CREATE`` , ``UPDATE`` 或 ``DELETE`` 在SQL, 而不是 ``SELECT`` （只读取数据库）必须清除缓存。"

#: ../../reference/orm.rst:447
msgid "Clearing caches can be performed using the :meth:`~openerp.api.Environment.invalidate_all` method of the :class:`~openerp.api.Environment` object."
msgstr "甲 :class: 的 `~openerp.api.Environment.invalidate_all` 方法 `~openerp.api.Environment` 对象清除缓存可以使用进行。"

#: ../../reference/orm.rst:455
msgid "Compatibility between new API and old API"
msgstr "新API和旧API之间的兼容性"

#: ../../reference/orm.rst:457
msgid "Odoo is currently transitioning from an older (less regular) API, it can be necessary to manually bridge from one to the other manually:"
msgstr "Odoo目前从旧（以下常）的API进行转换, 也可以是需要从一个手动的其它手动桥:"

#: ../../reference/orm.rst:460
msgid "RPC layers (both XML-RPC and JSON-RPC) are expressed in terms of the old API, methods expressed purely in the new API are not available over RPC"
msgstr "RPC层（既XML-RPC和JSON-RPC）表达于旧的API而言, 方法表示纯粹在新的API不可通过RPC"

#: ../../reference/orm.rst:462
msgid "overridable methods may be called from older pieces of code still written in the old API style"
msgstr "重写的方法可以从旧的代码块仍然写在旧的​​API的风格被称为"

#: ../../reference/orm.rst:465
msgid "The big differences between the old and new APIs are:"
msgstr "旧的和新的API之间最大的区别是:"

#: ../../reference/orm.rst:467
msgid "values of the :class:`~openerp.api.Environment` (cursor, user id and context) are passed explicitly to methods instead"
msgstr ":class: 值​​ `~openerp.api.Environment` （光标, 用户ID和上下文）明确传递给方法, 而不是"

#: ../../reference/orm.rst:469
msgid "record data (:attr:`~openerp.models.Model.ids`) are passed explicitly to methods, and possibly not passed at all"
msgstr "记录数据（ :attr:`~openerp.models.Model.ids` ）明确地传递给方法, 并有可能不通过所有"

#: ../../reference/orm.rst:471
msgid "methods tend to work on lists of ids instead of recordsets"
msgstr "方法往往工作的ID, 而不是记录集列表"

#: ../../reference/orm.rst:473
msgid "By default, methods are assumed to use the new API style and are not callable from the old API style."
msgstr "默认情况下, 方法假定使用新的API风格, 并没有从旧的API风格调用。"

#: ../../reference/orm.rst:476
msgid "calls from the new API to the old API are bridged"
msgstr "从新的API将旧的API调用桥"

#: ../../reference/orm.rst:479
msgid "when using the new API style, calls to methods defined using the old API are automatically converted on-the-fly, there should be no need to do anything special::"
msgstr "在使用新的API的风格, 调用定义使用旧的API将被自动转换在即时方法, 应该没有必要做什么特别的事情 ::"

#: ../../reference/orm.rst:496
msgid "Two decorators can expose a new-style method to the old API:"
msgstr "两个装饰可以公开一种新型的方法将旧的API:"

#: ../../reference/orm.rst:506
msgid ":func:`~openerp.api.model`"
msgstr ":func:`~openerp.api.model` "

#: ../../reference/orm.rst:499
msgid "the method is exposed as not using ids, its recordset will generally be empty. Its \"old API\" signature is ``cr, uid, *arguments, context``::"
msgstr "该方法作为不使用的ID暴露出来, 它的记录集将通常为空。它的'旧的API'签名是 ``CR, UID, *参数, context`` ::"

#: ../../reference/orm.rst:516
msgid ":func:`~openerp.api.multi`"
msgstr ":func:`~openerp.api.multi` "

#: ../../reference/orm.rst:509
msgid "the method is exposed as taking a list of ids (possibly empty), its \"old API\" signature is ``cr, uid, ids, *arguments, context``::"
msgstr "该方法公开采取IDS（可能为空）的列表, 它的'旧的API'签名是 ``CR, UID, IDS, *参数, context`` ::"

#: ../../reference/orm.rst:518
msgid "Because new-style APIs tend to return recordsets and old-style APIs tend to return lists of ids, there is also a decorator managing this:"
msgstr "因为新的风格​​的API趋于返回的记录和旧式的API趋于返回id的列表, 也有一个装饰管理此:"

#: ../../reference/orm.rst:537
msgid ":func:`~openerp.api.returns`"
msgstr ":func:`~openerp.api.returns` "

#: ../../reference/orm.rst:522
msgid "the function is assumed to return a recordset, the first parameter should be the name of the recordset's model or ``self`` (for the current model)."
msgstr "该功能被假定为返回记录集, 第一个参数应该是记录的模型或 ``self`` （当前模型）的名称。"

#: ../../reference/orm.rst:525
msgid "No effect if the method is called in new API style, but transforms the recordset into a list of ids when called from the old API style::"
msgstr "没有, 如果该方法被称为新的API的风格, 但是转换记录成ID列表从旧风​​格的API调用时的效果 ::"

#: ../../reference/orm.rst:542
msgid "Model Reference"
msgstr "模型参考"

#: ../../reference/orm.rst:767
msgid "Method decorators"
msgstr "方法装饰"

#: ../../reference/orm.rst:776
msgid "Fields"
msgstr "字段"

#: ../../reference/orm.rst:781
msgid "Basic fields"
msgstr "基础字段"

#: ../../reference/orm.rst:823
msgid "Relational fields"
msgstr "关系字段"

#: ../../reference/orm.rst:840
msgid "Inheritance and extension"
msgstr "继承和扩展"

#: ../../reference/orm.rst:842
msgid "Odoo provides three different mechanisms to extend models in a modular way:"
msgstr "Odoo提供了三种不同的机制来扩展模型以模块化方式:"

#: ../../reference/orm.rst:844
msgid "creating a new model from an existing one, adding new information to the copy but leaving the original module as-is"
msgstr "创建从现有的新模式, 增加新的信息的副本, 但离开原来的模块, 是"

#: ../../reference/orm.rst:846
msgid "extending models defined in other modules in-place, replacing the previous version"
msgstr "延伸在就地其它模块定义的模型, 取代以前版本"

#: ../../reference/orm.rst:848
msgid "delegating some of the model's fields to records it contains"
msgstr "委托一些模型的字段, 以它包含的记录"

#: ../../reference/orm.rst:854
msgid "Classical inheritance"
msgstr "经典继承"

#: ../../reference/orm.rst:856
msgid "When using the :attr:`~openerp.models.Model._inherit` and :attr:`~openerp.models.Model._name` attributes together, Odoo creates a new model using the existing one (provided via :attr:`~openerp.models.Model._inherit`) as a base. The new model gets all the fields, methods and meta-information (defaults & al) from its base."
msgstr "当使用 :attr:`~openerp.models.Model._inherit` 和 :attr:`~openerp.models.Model._name` 共同属性, Odoo创建一个使用新模式的现有（通过提供 :attr:`~ openerp.models.Model._inherit` ）的魅力。新的模式得到所有从基地字段, 方法和元信息（默认与人）。"

#: ../../reference/orm.rst:866
msgid "and using them:"
msgstr "并使用它们:"

#: ../../reference/orm.rst:872 ../../reference/orm.rst:899
msgid "will yield:"
msgstr "将产生:"

#: ../../reference/orm.rst:878
msgid "the second model has inherited from the first model's ``check`` method and its ``name`` field, but overridden the ``call`` method, as when using standard :ref:`Python inheritance <python:tut-inheritance>`."
msgstr "the second model has inherited from the first model's ``check`` method and its ``name`` field, but overridden the ``call`` method, as when using standard :ref:`Python inheritance <python :tut-inheritance>` ."

#: ../../reference/orm.rst:883
msgid "Extension"
msgstr "扩展"

#: ../../reference/orm.rst:885
msgid "When using :attr:`~openerp.models.Model._inherit` but leaving out :attr:`~openerp.models.Model._name`, the new model replaces the existing one, essentially extending it in-place. This is useful to add new fields or methods to existing models (created in other modules), or to customize or reconfigure them (e.g. to change their default sort order):"
msgstr "当使用 :attr:`~openerp.models.Model._inherit` 但离开了 :attr:`~openerp.models.Model._name` , 新的模式取代现有的, 从根本上扩大其就地。这是有益的补充新的字段或方法, 以现有的模式（在其他模块中创建）, 或自定义或重新配置（例如改变其默认的排序顺序）:"

#: ../../reference/orm.rst:905
msgid "it will also yield the various :ref:`automatic fields <reference/orm/model/automatic>` unless they've been disabled"
msgstr "it will also yield the various :ref:`automatic fields <reference/orm/model/automatic>` unless they've been disabled"

#: ../../reference/orm.rst:909
msgid "Delegation"
msgstr "委托"

#: ../../reference/orm.rst:911
msgid "The third inheritance mechanism provides more flexibility (it can be altered at runtime) but less power: using the :attr:`~openerp.models.Model._inherits` a model *delegates* the lookup of any field not found on the current model to \"children\" models. The delegation is performed via :class:`~openerp.fields.Reference` fields automatically set up on the parent model:"
msgstr "第三继承机制提供了更多的灵活性（可以在运行时改变）, 但更省电:采用 :attr:`~openerp.models.Model._inherits` 模型 *代表* 任何字段的当前模型没有找到查找到'孩子'模式。 :class: 代表团通过执行 `~openerp.fields.Reference` 字段的自动设置上父模型:"

#: ../../reference/orm.rst:926
msgid "will result in:"
msgstr "将导致:"

#: ../../reference/orm.rst:932
msgid "and it's possible to write directly on the delegated field:"
msgstr "并有可能在委托外地直接写:"

#: ../../reference/orm.rst:938
msgid "when using delegation inheritance, methods are *not* inherited, only fields"
msgstr "使用委派继承时, 方法是 *不* 继承, 只有场"

#: ../../reference/orm.rst:944
msgid "Domains"
msgstr "域"

#: ../../reference/orm.rst:946
msgid "A domain is a list of criteria, each criterion being a triple (either a ``list`` or a ``tuple``) of ``(field_name, operator, value)`` where:"
msgstr "域是一个标准列表, 每个标准是一个三元组（或者是 ``list`` 或 ``tuple`` ） ``的（FIELD_NAME, 运营商, 值）`` 其中:"

#: ../../reference/orm.rst:951
msgid "``field_name`` (``str``)"
msgstr " ``field_name`` （ ``str`` ）"

#: ../../reference/orm.rst:950
msgid "a field name of the current model, or a relationship traversal through a :class:`~openerp.fields.Many2one` using dot-notation e.g. ``'street'`` or ``'partner_id.country'``"
msgstr ":class: 当前模型, 或通过关系遍历的字段名'使用点符号, 例如 ``'street'`` 或 ``'partner_id.country'`` ~openerp.fields.Many2one `"

#: ../../reference/orm.rst:997
msgid "``operator`` (``str``)"
msgstr " ``operator`` （ ``str`` ）"

#: ../../reference/orm.rst:954
msgid "an operator used to compare the ``field_name`` with the ``value``. Valid operators are:"
msgstr "运营商用于比较 ``field_name`` 与 ``value`` 。有效的运营商:"

#: ../../reference/orm.rst:957
msgid "``=``"
msgstr " ``=`` "

#: ../../reference/orm.rst:958
msgid "equals to"
msgstr "等于"

#: ../../reference/orm.rst:959
msgid "``!=``"
msgstr " ``！=`` "

#: ../../reference/orm.rst:960
msgid "not equals to"
msgstr "不等于"

#: ../../reference/orm.rst:961
msgid "``>``"
msgstr " ``>`` "

#: ../../reference/orm.rst:962
msgid "greater than"
msgstr "比...更棒"

#: ../../reference/orm.rst:963
msgid "``>=``"
msgstr " ``> =`` "

#: ../../reference/orm.rst:964
msgid "greater than or equal to"
msgstr "大于或等于"

#: ../../reference/orm.rst:965
msgid "``<``"
msgstr " ``<`` "

#: ../../reference/orm.rst:966
msgid "less than"
msgstr "少于"

#: ../../reference/orm.rst:967
msgid "``<=``"
msgstr " ``<=`` "

#: ../../reference/orm.rst:968
msgid "less than or equal to"
msgstr "小于或等于"

#: ../../reference/orm.rst:970
msgid "``=?``"
msgstr " ``=？`` "

#: ../../reference/orm.rst:970
msgid "unset or equals to (returns true if ``value`` is either ``None`` or ``False``, otherwise behaves like ``=``)"
msgstr "未设置或等于（如果 ``value`` 要么是 ``None`` 或 ``False`` 返回true, 否则的行为就像 ``=`` ）"

#: ../../reference/orm.rst:974
msgid "``=like``"
msgstr " ``= like`` "

#: ../../reference/orm.rst:973
msgid "matches ``field_name`` against the ``value`` pattern. An underscore ``_`` in the pattern stands for (matches) any single character; a percent sign ``%`` matches any string of zero or more characters."
msgstr "比赛 ``field_name`` 对 ``value`` 模式。在pattern里的下划线 ``_`` 代表（匹配）任何单个字符;百分号 ``％`` 匹配的零个或多个字符的字符串。"

#: ../../reference/orm.rst:977
msgid "``like``"
msgstr " ``like`` "

#: ../../reference/orm.rst:977
msgid "matches ``field_name`` against the ``%value%`` pattern. Similar to ``=like`` but wraps ``value`` with '%' before matching"
msgstr "matches ``field_name`` against the ``%value%`` pattern. Similar to ``=like`` but wraps ``value`` with'%'before matching"

#: ../../reference/orm.rst:979
msgid "``not like``"
msgstr " ``not like`` "

#: ../../reference/orm.rst:980
msgid "doesn't match against the ``%value%`` pattern"
msgstr "doesn't match against the ``%value%`` pattern"

#: ../../reference/orm.rst:981
msgid "``ilike``"
msgstr " ``ilike`` "

#: ../../reference/orm.rst:982
msgid "case insensitive ``like``"
msgstr "不区分大小写 ``like`` "

#: ../../reference/orm.rst:983
msgid "``not ilike``"
msgstr " ``not ilike`` "

#: ../../reference/orm.rst:984
msgid "case insensitive ``not like``"
msgstr "不区分大小写 ``不like`` "

#: ../../reference/orm.rst:985
msgid "``=ilike``"
msgstr " ``= ilike`` "

#: ../../reference/orm.rst:986
msgid "case insensitive ``=like``"
msgstr "不区分大小写 ``= like`` "

#: ../../reference/orm.rst:988
msgid "``in``"
msgstr " ``in`` "

#: ../../reference/orm.rst:988
msgid "is equal to any of the items from ``value``, ``value`` should be a list of items"
msgstr "等于任何从 ``value`` 中的项目, ``value`` 应的项目列表"

#: ../../reference/orm.rst:990
msgid "``not in``"
msgstr " ``not in`` "

#: ../../reference/orm.rst:991
msgid "is unequal to all of the items from ``value``"
msgstr "不等于所有的项目从 ``value`` "

#: ../../reference/orm.rst:997
msgid "``child_of``"
msgstr " ``child_of`` "

#: ../../reference/orm.rst:993
msgid "is a child (descendant) of a ``value`` record."
msgstr "是 ``value`` 记录的孩子（后代）。"

#: ../../reference/orm.rst:995
msgid "Takes the semantics of the model into account (i.e following the relationship field named by :attr:`~openerp.models.Model._parent_name`)."
msgstr "注意到模型的语义考虑（也就是后续命名的关系字段 :attr:`~openerp.models.Model._parent_name` ）。"

#: ../../reference/orm.rst:1000
msgid "variable type, must be comparable (through ``operator``) to the named field"
msgstr "变量类型, 必须与（通过 ``operator`` ）到指定字段"

#: ../../reference/orm.rst:1003
msgid "Domain criteria can be combined using logical operators in *prefix* form:"
msgstr "域标准, 可以使用 *前缀* 形式逻辑运算符组合:"

#: ../../reference/orm.rst:1006
msgid "``'&'``"
msgstr " ``'和'`` "

#: ../../reference/orm.rst:1006
msgid "logical *AND*, default operation to combine criteria following one another. Arity 2 (uses the next 2 criteria or combinations)."
msgstr "逻辑 *和* , 默认操作要结合以下另一个标准。元数2（使用未来2标准或组合）。"

#: ../../reference/orm.rst:1008
msgid "``'|'``"
msgstr " ``'|'`` "

#: ../../reference/orm.rst:1009
msgid "logical *OR*, arity 2."
msgstr "逻辑 *或* , 元数2。"

#: ../../reference/orm.rst:1017
msgid "``'!'``"
msgstr " ``'！'`` "

#: ../../reference/orm.rst:1011
msgid "logical *NOT*, arity 1."
msgstr "逻辑 *不* , 元数1。"

#: ../../reference/orm.rst:1013
msgid "Mostly to negate combinations of criteria"
msgstr "主要是否定的标准组合"

#: ../../reference/orm.rst:1016
msgid "Individual criterion generally have a negative form (e.g. ``=`` -> ``!=``, ``<`` -> ``>=``) which is simpler than negating the positive."
msgstr "个别的标准一般有否定形式（如 ``=`` - > ``=````<`` - > ``> =`` ）比否定了积极的简单。"

#: ../../reference/orm.rst:1019
msgid "Example"
msgstr "示例"

#: ../../reference/orm.rst:1021
msgid "To search for partners named *ABC*, from belgium or germany, whose language is not english::"
msgstr "要搜索名为 * ABC * 合作伙伴, 来自比利时和德国, 他们的母语不是英语 ::"

#: ../../reference/orm.rst:1029
msgid "This domain is interpreted as:"
msgstr "此域名被解释为:"

#: ../../reference/orm.rst:1038
msgid "Porting from the old API to the new API"
msgstr "从旧的API移植到新的API"

#: ../../reference/orm.rst:1040
msgid "bare lists of ids are to be avoided in the new API, use recordsets instead"
msgstr "id的裸列表是要避免在新的API中, 使用记录集代替"

#: ../../reference/orm.rst:1041
msgid "methods still written in the old API should be automatically bridged by the ORM, no need to switch to the old API, just call them as if they were a new API method. See :ref:`reference/orm/oldapi/bridging` for more details."
msgstr "仍然写在旧的​​API方法应该由ORM自动桥接, 无需切换到旧的API, 就打电话给他们, 好像他们是一个新的API方法。请参阅 :ref:`参考/ ORM / oldapi / bridging` 了解更多详情。"

#: ../../reference/orm.rst:1044
msgid ":meth:`~openerp.models.Model.search` returns a recordset, no point in e.g. browsing its result"
msgstr ":meth:`~openerp.models.Model.search` 返回记录集, 在如不点浏览其结果"

#: ../../reference/orm.rst:1046
msgid "``fields.related`` and ``fields.function`` are replaced by using a normal field type with either a ``related=`` or a ``compute=`` parameter"
msgstr " ``fields.related`` 和 ``fields.function`` 通过使用普通的字段类型与任何一个 ``相关=`` 或 ``计算取代=`` 参数"

#: ../../reference/orm.rst:1048
msgid ":func:`~openerp.api.depends` on ``compute=`` methods **must be complete**, it must list **all** the fields and sub-fields which the compute method uses. It is better to have too many dependencies (will recompute the field in cases where that is not needed) than not enough (will forget to recompute the field and then values will be incorrect)"
msgstr ":func:`~openerp.api.depends` 上 ``计算=`` 方法 **必须是完整的** , 就必须列出所有 **** 字段和子字段该计算方法使用。最好是有太多的依赖（将重新计算在这不需要情况下, 场）比没有足够的（会忘记重新计算字段, 然后值将是不正确的）"

#: ../../reference/orm.rst:1053
msgid "**remove** all ``onchange`` methods on computed fields. Computed fields are automatically re-computed when one of their dependencies is changed, and that is used to auto-generate ``onchange`` by the client"
msgstr " **** 删除所有 ``onchange`` 在计算字段的方法。计算字段自动重新计算时, 他们的相关性中的一个被改变, 并且用于自动产生 ``由客户端onchange`` "

#: ../../reference/orm.rst:1056
msgid "the decorators :func:`~openerp.api.model` and :func:`~openerp.api.multi` are for bridging *when calling from the old API context*, for internal or pure new-api (e.g. compute) they are useless"
msgstr "在装饰 :func:`~openerp.api.model` 和 :func:`~openerp.api.multi` 是桥接 *从旧的API中* 打电话时, 内部或纯粹的新API（如计算）, 他们也没用"

#: ../../reference/orm.rst:1059
msgid "remove :attr:`~openerp.models.Model._default`, replace by ``default=`` parameter on corresponding fields"
msgstr "删除 :attr:`~openerp.models.Model._default` , 通过 ``默认值=`` 参数替换相应字段"

#: ../../reference/orm.rst:1061
msgid "if a field's ``string=`` is the titlecased version of the field name::"
msgstr "如果一个字段的 ``字符串=`` 是字段名的titlecased版本 ::"

#: ../../reference/orm.rst:1065
msgid "it is useless and should be removed"
msgstr "它是无用的, 应被删除"

#: ../../reference/orm.rst:1066
msgid "the ``multi=`` parameter does not do anything on new API fields use the same ``compute=`` methods on all relevant fields for the same result"
msgstr "在 ``多=`` 参数并不做新的API字段使用相同的 ``计算=`` 在所有相关字段的方法相同的结果什么"

#: ../../reference/orm.rst:1068
msgid "provide ``compute=``, ``inverse=`` and ``search=`` methods by name (as a string), this makes them overridable (removes the need for an intermediate \"trampoline\" function)"
msgstr "提供 ``计算=````逆=`` 和 ``搜索=`` 按名称方法（字符串）, 这使得它们覆盖的（不再需要中间'蹦床'功能）"

#: ../../reference/orm.rst:1071
msgid "double check that all fields and methods have different names, there is no warning in case of collision (because Python handles it before Odoo sees anything)"
msgstr "仔细检查所有字段和方法有不同的名称, 但在碰撞的情况下没有警告（因为Python处理它Odoo看到任何东西之前）"

#: ../../reference/orm.rst:1074
msgid "the normal new-api import is ``from openerp import fields, models``. If compatibility decorators are necessary, use ``from openerp import api, fields, models``"
msgstr "正常的新API导入 ``从OpenERP的进口字段, models`` 。如果兼容性装饰是必要的, 使用 ``从OpenERP的进口API, 字段, models`` "

#: ../../reference/orm.rst:1077
msgid "avoid the :func:`~openerp.api.one` decorator, it probably does not do what you expect"
msgstr "避免 :func:`~openerp.api.one` 装饰, 它可能不会做你所期望的"

#: ../../reference/orm.rst:1079
msgid "remove explicit definition of :attr:`~openerp.models.Model.create_uid`, :attr:`~openerp.models.Model.create_date`, :attr:`~openerp.models.Model.write_uid` and :attr:`~openerp.models.Model.write_date` fields: they are now created as regular \"legitimate\" fields, and can be read and written like any other field out-of-the-box"
msgstr "除去明确的定义 :attr:`~openerp.models.Model.create_uid` , :attr:`~openerp.models.Model.create_date` , :attr:`~openerp.models.Model.write_uid` 和 :attr: 属性 `~openerp.models.Model.write_date` 字段:他们现在创建为常规'合法'字段, 可以读取和写入像任何其他字段外的开箱"

#: ../../reference/orm.rst:1085
msgid ""
"when straight conversion is impossible (semantics can not be bridged) or the \"old API\" version is not desirable and could be improved for the new API, it is possible to use completely different \"old API\" and \"new API\" implementations for the same method name using :func:`~openerp.api.v7` and :func:`~openerp.api.v8`. The method should first be defined using the old-API style and decorated with :func:`~openerp.api.v7`, it should then be re-defined using the exact same name but the new-API style and "
"decorated with :func:`~openerp.api.v8`. Calls from an old-API context will be dispatched to the first implementation and calls from a new-API context will be dispatched to the second implementation. One implementation can call (and frequently does) call the other by switching context."
msgstr "当直的转换是不可能的（语义不能桥接）或'旧的API'版本是不理想的, 并为新的API可以改进, 有可能使用完全不同的'旧的API'和'新API'的实现用同样的方法名称 :func:`~openerp.api.v7` 和 :func:`~openerp.api.v8` 。该方法首先应使用旧的API样式定义, 并装饰有 :func:`~openerp.api.v7` , 它应该被重新定义使用完全相同的名称, 但新的API的风格和装饰着:FUNC :`~openerp.api.v8` 。从旧的API方面的电话将被分派到第一次执行, 并从一个新的API调用方面将派出第二个执行。一个实现可以调用（并且经常确实）拨打对方通过切换上下文。"

#: ../../reference/orm.rst:1097
msgid "using these decorators makes methods extremely difficult to override and harder to understand and document"
msgstr "使用这些装饰使得方法极难覆盖, 更难理解和文档"

#: ../../reference/orm.rst:1099
msgid "uses of :attr:`~openerp.models.Model._columns` or :attr:`~openerp.models.Model._all_columns` should be replaced by :attr:`~openerp.models.Model._fields`, which provides access to instances of new-style :class:`openerp.fields.Field` instances (rather than old-style :class:`openerp.osv.fields._column`)."
msgstr "使用的 :attr:`~openerp.models.Model._columns` 或 :attr: 属性:`~openerp.models.Model._all_columns` 应改为 `~openerp.models.Model._fields` , 它提供了访问对新风格的实例 :class:`openerp.fields.Field` 实例（而不是旧式的 :class:`openerp.osv.fields._column` ）。"

#: ../../reference/orm.rst:1105
msgid "Non-stored computed fields created using the new API style are *not* available in :attr:`~openerp.models.Model._columns` and can only be inspected through :attr:`~openerp.models.Model._fields`"
msgstr ":attr:`~openerp.models.Model._columns` , 只能通过检查 :attr: 使用新的API的风格是 *不* 可用在非存储计算字段的 `~openerp.models.Model._fields` "

#: ../../reference/orm.rst:1108
msgid "reassigning ``self`` in a method is probably unnecessary and may break translation introspection"
msgstr "重新分配 ``的方法self`` 可能是不必要的, 可能会破坏翻译内省"

#: ../../reference/orm.rst:1110
msgid ":class:`~openerp.api.Environment` objects rely on some threadlocal state, which has to be set up before using them. It is necessary to do so using the :meth:`openerp.api.Environment.manage` context manager when trying to use the new API in contexts where it hasn't been set up yet, such as new threads or a Python interactive environment::"
msgstr ":class:`~openerp.api.Environment` 对象依靠一些ThreadLocal的状态, 已被设置为使用它们之前。有必要做这样使用:尝试使用在上下文中它没有被建立, 而且, 如新的线程或Python交互环境, 新的API时 `openerp.api.Environment.manage` 上下文管理者:甲基 ::"

#: ../../reference/orm.rst:1132
msgid "Automatic bridging of old API methods"
msgstr "旧的API方法自动桥接"

#: ../../reference/orm.rst:1134
msgid "When models are initialized, all methods are automatically scanned and bridged if they look like models declared in the old API style. This bridging makes them transparently callable from new-API-style methods."
msgstr "当模型被初始化, 所有的方法都自动扫描, 如果他们看起来像旧风格的API声明车型桥接。这桥接使他们从透明的新API风格的方法调用。"

#: ../../reference/orm.rst:1138
msgid "Methods are matched as \"old-API style\" if their second positional parameter (after ``self``) is called either ``cr`` or ``cursor``. The system also recognizes the third positional parameter being called ``uid`` or ``user`` and the fourth being called ``id`` or ``ids``. It also recognizes the presence of any parameter called ``context``."
msgstr "方法进行匹配'老风格的API', 如果他们的第二个位置参数（后 ``self`` ）被称为是 ``cr`` 或 ``cursor`` 。该系统还可以识别第三个位置参数被称为 ``uid`` 或 ``user`` 和第四被称为 ``id`` 或 ``ids`` 。它还承认所谓的 ``context`` 任何参数的存在。"

#: ../../reference/orm.rst:1144
msgid "When calling such methods from a new API context, the system will automatically fill matched parameters from the current :class:`~openerp.api.Environment` (for :attr:`~openerp.api.Environment.cr`, :attr:`~openerp.api.Environment.user` and :attr:`~openerp.api.Environment.context`) or the current recordset (for ``id`` and ``ids``)."
msgstr ":class: 当调用从一个新的API环境这样的方法, 系统将自动从目前填补匹配的参数 `~openerp.api.Environment` （适用于 :attr:`~openerp.api.Environment.cr` , :attr:`~openerp.api.Environment.user` 和 :attr:`~openerp.api.Environment.context` ）或当前记录（用于 ``id`` 和 ``ids`` ）。"

#: ../../reference/orm.rst:1151
msgid "In the rare cases where it is necessary, the bridging can be customized by decorating the old-style method:"
msgstr "在极少数情况下, 这是必要的, 桥接, 都可以通过装修旧式方法:"

#: ../../reference/orm.rst:1154
msgid "disabling it entirely, by decorating a method with :func:`~openerp.api.noguess` there will be no bridging and methods will be called the exact same way from the new and old API styles"
msgstr "禁用它完全由装饰方法 :func:`~openerp.api.noguess` 不会有桥接和方法将被调用的新老API风格完全相同的方式"

#: ../../reference/orm.rst:1157
msgid "defining the bridge explicitly, this is mostly for methods which are matched incorrectly (because parameters are named in unexpected ways):"
msgstr "明确界定的桥梁, 这主要是为这是正确匹配（因为参数以意想不到的方式命名）方法:"

#: ../../reference/orm.rst:1161
msgid ":func:`~openerp.api.cr`"
msgstr ":func:`~openerp.api.cr` "

#: ../../reference/orm.rst:1161
msgid "will automatically prepend the current cursor to explicitly provided parameters, positionally"
msgstr "会自动在前面加上当前光标有明确规定的参数, 在位置"

#: ../../reference/orm.rst:1164
msgid ":func:`~openerp.api.cr_uid`"
msgstr ":func:`~openerp.api.cr_uid` "

#: ../../reference/orm.rst:1164
msgid "will automatically prepend the current cursor and user's id to explictly provided parameters"
msgstr "会自动在前面加上显式地提供当前光标和用户ID参数"

#: ../../reference/orm.rst:1167
msgid ":func:`~openerp.api.cr_uid_ids`"
msgstr ":func:`~openerp.api.cr_uid_ids` "

#: ../../reference/orm.rst:1167
msgid "will automatically prepend the current cursor, user's id and recordset's ids to explicitly provided parameters"
msgstr "会自动预先设置当前光标, 用户的ID和记录的ID, 以明确规定的参数"

#: ../../reference/orm.rst:1175
msgid ":func:`~openerp.api.cr_uid_id`"
msgstr ":func:`~openerp.api.cr_uid_id` "

#: ../../reference/orm.rst:1170
msgid "will loop over the current recordset and call the method once for each record, prepending the current cursor, user's id and record's id to explicitly provided parameters."
msgstr "会遍历当前记录并调用该方法一次每个记录, 在前面加上当前光标, 用户的ID和记录的ID明确提供的参数。"

#: ../../reference/orm.rst:1174
msgid "the result of this wrapper is *always a list* when calling from a new-API context"
msgstr "此包装的结果是 *总是一个列表* 从一个新的API调用的上下文时,"

#: ../../reference/orm.rst:1177
msgid "All of these methods have a ``_context``-suffixed version (e.g. :func:`~openerp.api.cr_uid_context`) which also passes the current context *by keyword*."
msgstr "所有这些方法都有一个 ``_context`` -后缀版本（例如 :func:`~openerp.api.cr_uid_context` ）, 这也传递了当前上下文 *按关键字* 。"

#: ../../reference/orm.rst:1180
msgid "dual implementations using :func:`~openerp.api.v7` and :func:`~openerp.api.v8` will be ignored as they provide their own \"bridging\""
msgstr "使用双实现 :func:`~openerp.api.v7` 和 :func:`~openerp.api.v8` 将被忽略, 因为它们提供自己的'架桥'"

#: ../../reference/qweb.rst:9 ../../reference/views.rst:1247
msgid "QWeb"
msgstr "QWeb"

#: ../../reference/qweb.rst:11
msgid "QWeb is the primary templating_ engine used by Odoo\\ [#othertemplates]_. It is an XML templating engine\\ [#genshif]_ and used mostly to generate HTML_ fragments and pages."
msgstr "QWeb是由Odoo \\ [#othertemplates]主templating_引擎_。这是一个XML模板引擎\\ [#genshif] _和使用主要是为了产生HTML_片段和页面。"

#: ../../reference/qweb.rst:15
msgid "Template directives are specified as XML attributes prefixed with ``t-``, for instance ``t-if`` for :ref:`reference/qweb/conditionals`, with elements and other attributes being rendered directly."
msgstr "模板指令指定为前缀 ``T-`` , 例如 ``T-if`` 的XML属性 :ref:`参考/ qweb / conditionals` , 包含元素和其他属性被直接呈现。"

#: ../../reference/qweb.rst:19
msgid "To avoid element rendering, a placeholder element ``<t>`` is also available, which executes its directive but doesn't generate any output in and of itself::"
msgstr "To avoid element rendering, a placeholder element ``<t>`` is also available, which executes its directive but doesn't generate any output in and of itself ::"

#: ../../reference/qweb.rst:27 ../../reference/qweb.rst:37 ../../reference/qweb.rst:311
msgid "will result in::"
msgstr "将导致 ::"

#: ../../reference/qweb.rst:31
msgid "if ``condition`` is true, but::"
msgstr "如果 ``condition`` 是真实的, 但 ::"

#: ../../reference/qweb.rst:46
msgid "data output"
msgstr "数据输出"

#: ../../reference/qweb.rst:48
msgid "QWeb has a primary output directive which automatically HTML-escape its content limiting XSS_ risks when displaying user-provided content: ``esc``."
msgstr "QWeb有一个主输出指令, 自动HTML转义其内容限制XSS_显示用户提供的内容时, 风险:``esc`` 。"

#: ../../reference/qweb.rst:51
msgid "``esc`` takes an expression, evaluates it and prints the content::"
msgstr " ``esc`` 需要一个表达式, 计算它, 并打印内容 ::"

#: ../../reference/qweb.rst:55
msgid "rendered with the value ``value`` set to ``42`` yields::"
msgstr "与值 ``呈现value`` 设置为 ``42`` 产量 ::"

#: ../../reference/qweb.rst:59
msgid "There is one other output directive ``raw`` which behaves the same as respectively ``esc`` but *does not HTML-escape its output*. It can be useful to display separately constructed markup (e.g. from functions) or already sanitized user-provided markup."
msgstr "还有另外一个输出指令 ``raw`` 其行为同样分别 ``esc`` 但 *不HTML-逃脱它的输出* 。它可以是有用的, 以显示单独构造的标记（例如, 从功能）或已消毒用户提供的标记。"

#: ../../reference/qweb.rst:67
msgid "conditionals"
msgstr "条件语句"

#: ../../reference/qweb.rst:69
msgid "QWeb has a conditional directive ``if``, which evaluates an expression given as attribute value::"
msgstr "QWeb有一个条件指令 ``if`` , 它计算给定的属性值表达式 ::"

#: ../../reference/qweb.rst:78
msgid "The element is rendered if the condition is true::"
msgstr "如果条件为真元素呈现 ::"

#: ../../reference/qweb.rst:84
msgid "but if the condition is false it is removed from the result::"
msgstr "但如果条件为假它从结果中删除 ::"

#: ../../reference/qweb.rst:89
msgid "The conditional rendering applies to the bearer of the directive, which does not have to be ``<t>``::"
msgstr "The conditional rendering applies to the bearer of the directive, which does not have to be ``<t>`` ::"

#: ../../reference/qweb.rst:96
msgid "will give the same results as the previous example."
msgstr "将给出相同的结果的前面的例子。"

#: ../../reference/qweb.rst:101
msgid "loops"
msgstr "回环"

#: ../../reference/qweb.rst:103
msgid "QWeb has an iteration directive ``foreach`` which take an expression returning the collection to iterate on, and a second parameter ``t-as`` providing the name to use for the \"current item\" of the iteration::"
msgstr "QWeb有一个迭代指令 ``foreach`` 这需要一个表达式返回集合迭代上, 而第二个参数 ``T-as`` 提供迭代的名称, 用于在'当前项目'::"

#: ../../reference/qweb.rst:111 ../../reference/qweb.rst:198 ../../reference/qweb.rst:210 ../../reference/qweb.rst:221 ../../reference/qweb.rst:231
msgid "will be rendered as::"
msgstr "将呈现为 ::"

#: ../../reference/qweb.rst:117
msgid "Like conditions, ``foreach`` applies to the element bearing the directive's attribute, and"
msgstr "像条件, ``foreach`` 适用于承载指令的属性的元素, 和"

#: ../../reference/qweb.rst:126
msgid "is equivalent to the previous example."
msgstr "等同于前面的例子。"

#: ../../reference/qweb.rst:128
msgid "``foreach`` can iterate on an array (the current item will be the current value), a mapping (the current item will be the current key) or an integer (equivalent to iterating on an array between 0 inclusive and the provided integer exclusive)."
msgstr " ``foreach`` 可以在阵列上迭代（当前项目将是当前值）, 映射（当前项目将是当前键）或一个整数（相当于遍历数组0包容性和所提供的整数值之间独家）。"

#: ../../reference/qweb.rst:133
msgid "In addition to the name passed via ``t-as``, ``foreach`` provides a few other variables for various data points:"
msgstr "除了经由 ``叔as`` 通过名称, ``foreach`` 提供了一些其他变量关于各种数据点:"

#: ../../reference/qweb.rst:136
msgid "``$as`` will be replaced by the name passed to ``t-as``"
msgstr " ``$as`` will be replaced by the name passed to ``t-as`` "

#: ../../reference/qweb.rst:138
msgid ":samp:`{$as}_all`"
msgstr ":samp:`{$as}_all` "

#: ../../reference/qweb.rst:139
msgid "the object being iterated over"
msgstr "该对象被迭代"

#: ../../reference/qweb.rst:141
msgid ":samp:`{$as}_value`"
msgstr ":samp:`{$as}_value` "

#: ../../reference/qweb.rst:141
msgid "the current iteration value, identical to ``$as`` for lists and integers, but for mappings it provides the value (where ``$as`` provides the key)"
msgstr "the current iteration value, identical to ``$as`` for lists and integers, but for mappings it provides the value (where ``$as`` provides the key)"

#: ../../reference/qweb.rst:143
msgid ":samp:`{$as}_index`"
msgstr ":samp:`{$as}_index` "

#: ../../reference/qweb.rst:144
msgid "the current iteration index (the first item of the iteration has index 0)"
msgstr "当前迭代指数（迭代的第一个项目的索引0）"

#: ../../reference/qweb.rst:145
msgid ":samp:`{$as}_size`"
msgstr ":samp:`{$as}_size` "

#: ../../reference/qweb.rst:146
msgid "the size of the collection if it is available"
msgstr "集合的大小, 如果它是可用的"

#: ../../reference/qweb.rst:148
msgid ":samp:`{$as}_first`"
msgstr ":samp:`{$as}_first` "

#: ../../reference/qweb.rst:148
msgid "whether the current item is the first of the iteration (equivalent to :samp:`{$as}_index == 0`)"
msgstr "whether the current item is the first of the iteration (equivalent to :samp:`{$as}_index == 0` )"

#: ../../reference/qweb.rst:152
msgid ":samp:`{$as}_last`"
msgstr ":samp:`{$as}_last` "

#: ../../reference/qweb.rst:151
msgid "whether the current item is the last of the iteration (equivalent to :samp:`{$as}_index + 1 == {$as}_size`), requires the iteratee's size be available"
msgstr "whether the current item is the last of the iteration (equivalent to :samp:`{$as}_index + 1 == {$as}_size` ), requires the iteratee's size be available"

#: ../../reference/qweb.rst:154
msgid ":samp:`{$as}_parity`"
msgstr ":samp:`{$as}_parity` "

#: ../../reference/qweb.rst:155
msgid "either ``\"even\"`` or ``\"odd\"``, the parity of the current iteration round"
msgstr "无论是 ``'即使'`` 或 ``'奇'`` , 当前迭代的奇偶轮"

#: ../../reference/qweb.rst:157
msgid ":samp:`{$as}_even`"
msgstr ":samp:`{$as}_even` "

#: ../../reference/qweb.rst:157
msgid "a boolean flag indicating that the current iteration round is on an even index"
msgstr "一个布尔标志, 指示当前迭代轮是偶数指数"

#: ../../reference/qweb.rst:162
msgid ":samp:`{$as}_odd`"
msgstr ":samp:`{$as}_odd` "

#: ../../reference/qweb.rst:160
msgid "a boolean flag indicating that the current iteration round is on an odd index"
msgstr "一个布尔标志, 指示当前迭代轮是奇数指数"

#: ../../reference/qweb.rst:164
msgid "These extra variables provided and all new variables created into the ``foreach`` are only available in the scope of the``foreach``. If the variable exists outside the context of the ``foreach``, the value is copied at the end of the foreach into the global context."
msgstr "仅在the ``foreach`` 范围可提供这些额外的变量, 并创建成 ``foreach`` 所有新的变数。如果变量存在的范围之外的 ``foreach`` , 该值被复制在foreach年底到全球范围内。"

#: ../../reference/qweb.rst:186
msgid "attributes"
msgstr "属性"

#: ../../reference/qweb.rst:188
msgid "QWeb can compute attributes on-the-fly and set the result of the computation on the output node. This is done via the ``t-att`` (attribute) directive which exists in 3 different forms:"
msgstr "QWeb可以计算上即时属性和设置在输出节点上的计算的结果。这是通过 ``叔att`` （属性）指示存在于3个不同形式进行:"

#: ../../reference/qweb.rst:199
msgid ":samp:`t-att-{$name}`"
msgstr ":samp:`t-att-{$name}` "

#: ../../reference/qweb.rst:193
msgid "an attribute called ``$name`` is created, the attribute value is evaluated and the result is set as the attribute's value::"
msgstr "an attribute called ``$name`` is created, the attribute value is evaluated and the result is set as the attribute's value ::"

#: ../../reference/qweb.rst:213
msgid ":samp:`t-attf-{$name}`"
msgstr ":samp:`t-attf-{$name}` "

#: ../../reference/qweb.rst:202
msgid "same as previous, but the parameter is a :term:`format string` instead of just an expression, often useful to mix literal and non-literal string (e.g. classes)::"
msgstr "同以前的, 但参数是 :term:`格式string` 而不只是一种表达, 通常是有用的混合文字和非文字字符串（如类） ::"

#: ../../reference/qweb.rst:222
msgid ":samp:`t-att=mapping`"
msgstr ":samp:`T-ATT = mapping` "

#: ../../reference/qweb.rst:216
msgid "if the parameter is a mapping, each (key, value) pair generates a new attribute and its value::"
msgstr "如果该参数是一个映射, 每一个（键, 值）对生成一个新的属性和它的值 ::"

#: ../../reference/qweb.rst:233
msgid ":samp:`t-att=pair`"
msgstr ":samp:`T-ATT = pair` "

#: ../../reference/qweb.rst:225
msgid "if the parameter is a pair (tuple or array of 2 element), the first item of the pair is the name of the attribute and the second item is the value::"
msgstr "如果该参数是一对（元组或2元件的阵列）, 该对中的第一项是该属性的名称, 第二项是值 ::"

#: ../../reference/qweb.rst:236
msgid "setting variables"
msgstr "设置变量"

#: ../../reference/qweb.rst:238
msgid "QWeb allows creating variables from within the template, to memoize a computation (to use it multiple times), give a piece of data a clearer name, ..."
msgstr "QWeb允许从模板中创建变量, 以memoize的运算（使用它多次）, 得到一块数据更清晰名称, ..."

#: ../../reference/qweb.rst:242
msgid "This is done via the ``set`` directive, which takes the name of the variable to create. The value to set can be provided in two ways:"
msgstr "这是通过 ``set`` 指令, 这需要创建变量的名称做了。设置该值可以通过两种方式提供:"

#: ../../reference/qweb.rst:245
msgid "a ``t-value`` attribute containing an expression, and the result of its evaluation will be set::"
msgstr "一个 ``T-value`` 属性包含一个表达式, 其评价结果将被设置 ::"

#: ../../reference/qweb.rst:251
msgid "will print ``3``"
msgstr "将打印 ``3`` "

#: ../../reference/qweb.rst:252
msgid "if there is no ``t-value`` attribute, the node's body is rendered and set as the variable's value::"
msgstr "如果没有 ``叔value`` 属性, 节点的体渲染, 并设置作为变量的值 ::"

#: ../../reference/qweb.rst:260
msgid "will generate ``&lt;li&gt;ok&lt;/li&gt;`` (the content is escaped as we used the ``esc`` directive)"
msgstr "会产生 ``＆LT;李＆GT;确定＆LT; /李＆GT;`` （内容为我们所用的 ``esc`` 指令转义）"

#: ../../reference/qweb.rst:263
msgid "using the result of this operation is a significant use-case for the ``raw`` directive."
msgstr "使用此操作的结果是一个显著用例为 ``raw`` 指令。"

#: ../../reference/qweb.rst:267
msgid "calling sub-templates"
msgstr "调用子模板"

#: ../../reference/qweb.rst:269
msgid "QWeb templates can be used for top-level rendering, but they can also be used from within another template (to avoid duplication or give names to parts of templates) using the ``t-call`` directive::"
msgstr "QWeb模板可用于顶层的渲染, 但它们也可以从另一个模板用于使用 ``叔call`` 指令（以避免重复或模板零件给名称） ::"

#: ../../reference/qweb.rst:275
msgid "This calls the named template with the execution context of the parent, if ``other_template`` is defined as::"
msgstr "这需要与母公司的执行上下文的命名模板, 如果 ``other_template`` 被定义为 ::"

#: ../../reference/qweb.rst:280
msgid "the call above will be rendered as ``<p/>`` (no content), but::"
msgstr "the call above will be rendered as ``<p/>`` (no content), but ::"

#: ../../reference/qweb.rst:285
msgid "will be rendered as ``<p>1</p>``."
msgstr "will be rendered as ``<p>1</p>`` ."

#: ../../reference/qweb.rst:287
msgid "However this has the problem of being visible from outside the ``t-call``. Alternatively, content set in the body of the ``call`` directive will be evaluated *before* calling the sub-template, and can alter a local context::"
msgstr "然而, 这有被从 ``T-call`` 外面看到的问题。可替代地, 在 ``call`` 指令的主体设定内容将被评估 **前调用子模板, 并且可以改变本地上下文 ::"

#: ../../reference/qweb.rst:296
msgid "The body of the ``call`` directive can be arbitrarily complex (not just ``set`` directives), and its rendered form will be available within the called template as a magical ``0`` variable::"
msgstr "在 ``call`` 指令的主体可以是任意复杂的（不只是 ``set`` 指令）, 其呈现形式会被调用模板, 一个神奇的 ``内可0`` 可变 ::"

#: ../../reference/qweb.rst:305
msgid "being called thus::"
msgstr "因此被称为 ::"

#: ../../reference/qweb.rst:322 ../../reference/qweb.rst:421
msgid "Exclusive directives"
msgstr "独家指令"

#: ../../reference/qweb.rst:325
msgid "asset bundles"
msgstr "asset包"

#: ../../reference/qweb.rst:330
msgid "\"smart records\" fields formatting"
msgstr " ``smart records`` 字段格式化"

#: ../../reference/qweb.rst:332
msgid "The ``t-field`` directive can only be used when performing field access (``a.b``) on a \"smart\" record (result of the ``browse`` method). It is able to automatically format based on field type, and is integrated in the website's rich text edition."
msgstr "进行现场访问（ ``ab`` ）在'智能'记录（ ``browse`` 方法的结果）时, ``T-field`` 指令只能用。它能够根据字段类型, 自动格式化, 并集成在网站的富文本编辑。"

#: ../../reference/qweb.rst:337
msgid "``t-field-options`` can be used to customize fields, the most common option is ``widget``, other options are field- or widget-dependent."
msgstr " ``叔场options`` 可以用来定制字段, 最常见的方法是 ``widget`` , 其他选项是现场或插件依赖性。"

#: ../../reference/qweb.rst:341 ../../reference/qweb.rst:487
msgid "debugging"
msgstr "调试"

#: ../../reference/qweb.rst:349 ../../reference/qweb.rst:506
msgid "``t-debug``"
msgstr " ``T-debug`` "

#: ../../reference/qweb.rst:344
msgid "invokes a debugger using PDB's ``set_trace`` API. The parameter should be the name of a module, on which a ``set_trace`` method is called::"
msgstr "调用使用PDB的 ``set_trace`` API调试器。参数应该是一个模块, 在其上 ``set_trace`` 方法被调用的名字 ::"

#: ../../reference/qweb.rst:349
msgid "is equivalent to ``importlib.import_module(\"pdb\").set_trace()``"
msgstr "相当于 ``importlib.import_module（'PDB'）。set_trace（）`` "

#: ../../reference/qweb.rst:352 ../../reference/qweb.rst:519
msgid "Helpers"
msgstr "助手"

#: ../../reference/qweb.rst:355
msgid "Request-based"
msgstr "基于请求"

#: ../../reference/qweb.rst:357
msgid "Most Python-side uses of QWeb are in controllers (and during HTTP requests), in which case templates stored in the database (as :ref:`views <reference/views/qweb>`) can be trivially rendered by calling :meth:`openerp.http.HttpRequest.render`:"
msgstr "Most Python-side uses of QWeb are in controllers (and during HTTP requests), in which case templates stored in the database (as :ref:`views <reference/views/qweb>` ) can be trivially rendered by calling :meth:`openerp.http.HttpRequest.render` :"

#: ../../reference/qweb.rst:368
msgid "This automatically creates a :class:`~openerp.http.Response` object which can be returned from the controller (or further customized to suit)."
msgstr "这会自动创建一个 :class: 可从控制器返回（或进一步定制, 以适应） `~openerp.http.Response` 对象。"

#: ../../reference/qweb.rst:372
msgid "View-based"
msgstr "基于视图的"

#: ../../reference/qweb.rst:374
msgid "At a deeper level than the previous helper is the ``render`` method on ``ir.ui.view``:"
msgstr "在更深的层次比前助手是 ``ir.ui.view`` 的 ``render`` 方法:"

#: ../../reference/qweb.rst:379
msgid "Renders a QWeb view/template by database id or :term:`external id`. Templates are automatically loaded from ``ir.ui.view`` records."
msgstr "渲染一个QWeb视图/模板, 数据库ID或者 :term:`外部ID` 。模板是从 ``ir.ui.view`` 记录自动加载。"

#: ../../reference/qweb.rst:382
msgid "Sets up a number of default values in the rendering context:"
msgstr "设置若干在呈现上下文的默认值:"

#: ../../reference/qweb.rst:384 ../../reference/upgrade_api.rst:116
msgid "``request``"
msgstr " ``request`` "

#: ../../reference/qweb.rst:385
msgid "the current :class:`~openerp.http.WebRequest` object, if any"
msgstr "当前 :class:`~openerp.http.WebRequest` 对象, 如果有的话"

#: ../../reference/qweb.rst:386
msgid "``debug``"
msgstr " ``debug`` "

#: ../../reference/qweb.rst:387
msgid "whether the current request (if any) is in ``debug`` mode"
msgstr "当前请求（如果有的话）是否在 ``debug`` 模式"

#: ../../reference/qweb.rst:388
msgid ":func:`quote_plus <werkzeug.urls.url_quote_plus>`"
msgstr ":func:`quote_plus <werkzeug.urls.url_quote_plus>` "

#: ../../reference/qweb.rst:389
msgid "url-encoding utility function"
msgstr "URL编码的效用函数"

#: ../../reference/qweb.rst:390
msgid ":mod:`json`"
msgstr ":mod:`json` "

#: ../../reference/qweb.rst:391 ../../reference/qweb.rst:393 ../../reference/qweb.rst:395
msgid "the corresponding standard library module"
msgstr "相应的标准库模块"

#: ../../reference/qweb.rst:392
msgid ":mod:`time`"
msgstr ":mod:`time` "

#: ../../reference/qweb.rst:394
msgid ":mod:`datetime`"
msgstr ":mod:`datetime` "

#: ../../reference/qweb.rst:396
msgid "`relativedelta <https://labix.org/python-dateutil#head-ba5ffd4df8111d1b83fc194b97ebecf837add454>`_"
msgstr " `relativedelta <https ://labix.org/python-dateutil#head-ba5ffd4df8111d1b83fc194b97ebecf837add454>` _"

#: ../../reference/qweb.rst:397
msgid "see module"
msgstr "请参阅模块"

#: ../../reference/qweb.rst:399
msgid "``keep_query``"
msgstr " ``keep_query`` "

#: ../../reference/qweb.rst:399
msgid "the ``keep_query`` helper function"
msgstr "在 ``keep_query`` 辅助函数"

#: ../../reference/qweb.rst:401
msgid "context values to pass to QWeb for rendering"
msgstr "上下文值传递给QWeb渲染"

#: ../../reference/qweb.rst:402
msgid "name of the Odoo model to use for rendering, can be used to expand or customize QWeb locally (by creating a \"new\" qweb based on ``ir.qweb`` with alterations)"
msgstr "用于渲染的Odoo模型的名称, 可以用来扩展或局部地定制QWeb（通过创建'新'qweb根据 ``ir.qweb`` 与改建）"

#: ../../reference/qweb.rst:409 ../../reference/qweb.rst:531
msgid "API"
msgstr "API"

#: ../../reference/qweb.rst:411
msgid "It is also possible to use the ``ir.qweb`` model directly (and extend it, and inherit from it):"
msgstr "另外, 也可以使用 ``ir.qweb`` 直接模型（和扩展它, 并从它继承）:"

#: ../../reference/qweb.rst:424
msgid "defining templates"
msgstr "定义模板"

#: ../../reference/qweb.rst:426
msgid "The ``t-name`` directive can only be placed at the top-level of a template file (direct children to the document root)::"
msgstr "该 ``T-name`` 指令只能放置在一个模板文件（直接子文档根目录）的顶级 ::"

#: ../../reference/qweb.rst:435
msgid "It takes no other parameter, but can be used with a ``<t>`` element or any other. With a ``<t>`` element, the ``<t>`` should have a single child."
msgstr "It takes no other parameter, but can be used with a ``<t>`` element or any other. With a ``<t>`` element, the ``<t>`` should have a single child."

#: ../../reference/qweb.rst:438
msgid "The template name is an arbitrary string, although when multiple templates are related (e.g. called sub-templates) it is customary to use dot-separated names to indicate hierarchical relationships."
msgstr "模板名称是任意的字符串, 虽然当多个模板相关（例如被称为子模板）, 这是习惯用点分隔的名字来表示层次关系。"

#: ../../reference/qweb.rst:443
msgid "template inheritance"
msgstr "模板继承"

#: ../../reference/qweb.rst:445
msgid "Template inheritance is used to alter existing templates in-place, e.g. to add information to templates created by an other modules."
msgstr "模板继承用于改变就地现有模板, 如将信息添加到由其他模块创建的模板。"

#: ../../reference/qweb.rst:448
msgid "Template inheritance is performed via the ``t-extend`` directive which takes the name of the template to alter as parameter."
msgstr "模板继承是通过 ``T-extend`` 指令, 它采用了模板的名称更改为参数进行。"

#: ../../reference/qweb.rst:451
msgid "The alteration is then performed with any number of ``t-jquery`` sub-directives::"
msgstr "然后用任何数量的 ``叔jquery`` 子指令进行变更 ::"

#: ../../reference/qweb.rst:460
msgid "The ``t-jquery`` directives takes a `CSS selector`_. This selector is used on the extended template to select *context nodes* to which the specified ``t-operation`` is applied:"
msgstr "该 ``T-jquery`` 指令需要一个 `CSS selector` _。这个选择是用在扩展模板选择 *上下文节点* 它指定 ``T-operation`` 适用于:"

#: ../../reference/qweb.rst:465
msgid "``append``"
msgstr " ``append`` "

#: ../../reference/qweb.rst:465
msgid "the node's body is appended at the end of the context node (after the context node's last child)"
msgstr "该节点的尸体是在上下文节点的末尾附加（上下文节点的最后一个孩子后）"

#: ../../reference/qweb.rst:468
msgid "``prepend``"
msgstr " ``prepend`` "

#: ../../reference/qweb.rst:468
msgid "the node's body is prepended to the context node (inserted before the context node's first child)"
msgstr "该节点的身体被前置到上下文节点（上下文节点的第一个孩子之前插入）"

#: ../../reference/qweb.rst:470 ../../reference/views.rst:100
msgid "``before``"
msgstr " ``before`` "

#: ../../reference/qweb.rst:471
msgid "the node's body is inserted right before the context node"
msgstr "节点的体插入上下文节点之前右"

#: ../../reference/qweb.rst:472 ../../reference/views.rst:97
msgid "``after``"
msgstr " ``after`` "

#: ../../reference/qweb.rst:473
msgid "the node's body is inserted right after the context node"
msgstr "节点的体插入上下文节点之后"

#: ../../reference/qweb.rst:474
msgid "``inner``"
msgstr " ``inner`` "

#: ../../reference/qweb.rst:475
msgid "the node's body replaces the context node's children"
msgstr "该节点的身体替换上下文节点的孩子"

#: ../../reference/qweb.rst:476 ../../reference/views.rst:94
msgid "``replace``"
msgstr " ``replace`` "

#: ../../reference/qweb.rst:477
msgid "the node's body is used to replace the context node itself"
msgstr "节点的主体是用来取代上下文节点本身"

#: ../../reference/qweb.rst:484
msgid "No operation"
msgstr "无操作"

#: ../../reference/qweb.rst:479
msgid "if no ``t-operation`` is specified, the template body is interpreted as javascript code and executed with the context node as ``this``"
msgstr "如果没有指定 ``T-operation`` 时, 模板身体被解释为JavaScript代码, 并与上下文节点为 ``this`` 执行"

#: ../../reference/qweb.rst:482
msgid "while much more powerful than other operations, this mode is also much harder to debug and maintain, it is recommended to avoid it"
msgstr "而多比其他操作更有力, 这种模式也更难调试和维护时, 建议避免它"

#: ../../reference/qweb.rst:489
msgid "The javascript QWeb implementation provides a few debugging hooks:"
msgstr "JavaScript的QWeb实施提供了一些调试钩:"

#: ../../reference/qweb.rst:497
msgid "``t-log``"
msgstr " ``T-log`` "

#: ../../reference/qweb.rst:492
msgid "takes an expression parameter, evaluates the expression during rendering and logs its result with ``console.log``::"
msgstr "接受一个表达式的参数, 在渲染过程中计算表达式并记录其结果与 ``console.log`` ::"

#: ../../reference/qweb.rst:498
msgid "will print ``42`` to the console"
msgstr "将打印 ``42`` 到控制台"

#: ../../reference/qweb.rst:500
msgid "triggers a debugger breakpoint during template rendering::"
msgstr "在触发模板呈现一个调试器断点 ::"

#: ../../reference/qweb.rst:506
msgid "will stop execution if debugging is active (exact condition depend on the browser and its development tools)"
msgstr "将停止执行, 如果调试有效（具体情况取决于浏览器及其开发工具）"

#: ../../reference/qweb.rst:516
msgid "``t-js``"
msgstr " ``T-js`` "

#: ../../reference/qweb.rst:509
msgid "the node's body is javascript code executed during template rendering. Takes a ``context`` parameter, which is the name under which the rendering context will be available in the ``t-js``'s body::"
msgstr "该节点的身体是在模板渲染执行JavaScript代码。需要 ``context`` 参数, 这是根据该渲染上下文将在 ``T-js`` 的体内可用的名字 ::"

#: ../../reference/qweb.rst:523
msgid "(core is the ``web.core`` module) An instance of :js:class:`QWeb2.Engine` with all module-defined template files loaded, and references to standard helper objects ``_`` (underscore), ``_t`` (translation function) and JSON_."
msgstr "（核心是 ``web.core`` 模块）的实例 :js: class :`QWeb2.Engine` 与加载的所有模块定义的模板文件, 并引用标准辅助对象 ``_`` （下划线）, ``_t`` （转换功能）和JSON_。"

#: ../../reference/qweb.rst:527
msgid ":js:func:`core.qweb.render <QWeb2.Engine.render>` can be used to easily render basic module templates"
msgstr ":js: func :`core.qweb.render <QWeb2.Engine.render>` 可以用来方便地呈现基本模块模板"

#: ../../reference/qweb.rst:535
msgid "The QWeb \"renderer\", handles most of QWeb's logic (loading, parsing, compiling and rendering templates)."
msgstr "该QWeb'呈现', 处理大部分QWeb的逻辑（加载, 解析, 编译和执行模板）。"

#: ../../reference/qweb.rst:538
msgid "OpenERP Web instantiates one for the user in the core module, and exports it to ``core.qweb``. It also loads all the template files of the various modules into that QWeb instance."
msgstr "OpenERP的网站实例化一个是核心模块中的用户, 并出口到 ``core.qweb`` 。它还加载了各种模块的所有模板文件到该QWeb实例。"

#: ../../reference/qweb.rst:542
msgid "A :js:class:`QWeb2.Engine` also serves as a \"template namespace\"."
msgstr "答 :js: class :`QWeb2.Engine` 也作为一个'模板命名空间'。"

#: ../../reference/qweb.rst:546
msgid "Renders a previously loaded template to a String, using ``context`` (if provided) to find the variables accessed during template rendering (e.g. strings to display)."
msgstr "渲染以前加载的模板, 一个字符串, 使用 ``context`` （如果有的话）, 以找到在模板渲染访问（如字符串显示）的变量。"

#: ../../reference/qweb.rst:550
msgid "the name of the template to render"
msgstr "呈现模板的名称"

#: ../../reference/qweb.rst:551
msgid "the basic namespace to use for template rendering"
msgstr "的基本名字空间要用于模板渲染"

#: ../../reference/qweb.rst:553
msgid "String"
msgstr "字符串"

#: ../../reference/qweb.rst:555
msgid "The engine exposes an other method which may be useful in some cases (e.g. if you need a separate template namespace with, in OpenERP Web, Kanban views get their own :js:class:`QWeb2.Engine` instance so their templates don't collide with more general \"module\" templates):"
msgstr "该引擎公开这可能是在某些情况下非常有用（例如, 如果你需要一个单独的模板命名空间, 在OpenERP的网页, 看板的视图得到自己的另一种方法 :js: class :`QWeb2.Engine` 实例, 以便他们的模板不碰撞更一般的'模块'模板）:"

#: ../../reference/qweb.rst:563
msgid "Loads a template file (a collection of templates) in the QWeb instance. The templates can be specified as:"
msgstr "加载中QWeb实例的模板文件（模板的集合）。模板可以指定为:"

#: ../../reference/qweb.rst:568
msgid "An XML string"
msgstr "XML字符串"

#: ../../reference/qweb.rst:567
msgid "QWeb will attempt to parse it to an XML document then load it."
msgstr "QWeb会尝试将其解析为一个XML文档然后将其加载。"

#: ../../reference/qweb.rst:572
msgid "A URL"
msgstr "一个URL"

#: ../../reference/qweb.rst:571
msgid "QWeb will attempt to download the URL content, then load the resulting XML string."
msgstr "QWeb会尝试下载的URL的内容, 然后加载生成的XML字符串。"

#: ../../reference/qweb.rst:577
msgid "A ``Document`` or ``Node``"
msgstr "一个 ``Document`` 或 ``Node`` "

#: ../../reference/qweb.rst:575
msgid "QWeb will traverse the first level of the document (the child nodes of the provided root) and load any named template or template override."
msgstr "QWeb将遍历文档（所提供的根的子节点）的第一级和装载任何命名模板或模板覆盖。"

#: ../../reference/qweb.rst:581
msgid "A :js:class:`QWeb2.Engine` also exposes various attributes for behavior customization:"
msgstr "答 :js: class :`QWeb2.Engine` 也暴露了行为定制各种属性:"

#: ../../reference/qweb.rst:586
msgid "Prefix used to recognize directives during parsing. A string. By default, ``t``."
msgstr "前缀用于在分析过程中识别的指令。一个字符串。默认情况下, ``t`` 。"

#: ../../reference/qweb.rst:591
msgid "Boolean flag putting the engine in \"debug mode\". Normally, QWeb intercepts any error raised during template execution. In debug mode, it leaves all exceptions go through without intercepting them."
msgstr "布尔标志, 把发动机'调试模式'。通常情况下, QWeb拦截模板执行过程中提出的任何错误。在调试模式下, 它使所有的异常经历, 而不拦截它们。"

#: ../../reference/qweb.rst:598
msgid "The jQuery instance used during template inheritance processing. Defaults to ``window.jQuery``."
msgstr "模板继承处理期间使用了jQuery实例。默认为 ``window.jQuery`` 。"

#: ../../reference/qweb.rst:603
msgid "A ``Function``. If present, called before compiling each DOM node to template code. In OpenERP Web, this is used to automatically translate text content and some attributes in templates. Defaults to ``null``."
msgstr "一个 ``Function`` 。如果存在, 被称为编译每个DOM节点模板代码之前。在的OpenERP网络, 这是用来自动翻译文字内容和在模板一些属性。默认为 ``null`` 。"

#: ../../reference/qweb.rst:608
msgid "it is similar in that to Genshi_, although it does not use (and has no support for) `XML namespaces`_"
msgstr "这是在给​​Genshi_类似, 虽然它没有使用（而且没有支持） `XML namespaces` _"

#: ../../reference/qweb.rst:611
msgid "although it uses a few others, either for historical reasons or because they remain better fits for the use case. Odoo 9.0 still depends on Jinja_ and Mako_."
msgstr ""

#: ../../reference/reports.rst:7
msgid "QWeb Reports"
msgstr "QWeb报告"

#: ../../reference/reports.rst:9
msgid "Reports are written in HTML/QWeb, like all regular views in Odoo. You can use the usual :ref:`QWeb control flow tools <reference/qweb>`. The PDF rendering itself is performed by wkhtmltopdf_."
msgstr "Reports are written in HTML/QWeb, like all regular views in Odoo. You can use the usual :ref:`QWeb control flow tools <reference/qweb>` . The PDF rendering itself is performed by wkhtmltopdf_."

#: ../../reference/reports.rst:13
msgid "If you want to create a report on a certain model, you will need to define this :ref:`reference/reports/report` and the :ref:`reference/reports/templates` it will use. If you wish, you can also specify a specific :ref:`reference/reports/paper_formats` for this report. Finally, if you need access to more than your model, you can define a :ref:`reference/reports/custom_reports` class that gives you access to more models and records in the template."
msgstr "如果你想创建一个特定的模式的报告, 您需要定义是 :ref:`参考/报告/ report` 和 :ref:`参考/报告/ templates` 它将使用。如果你愿意, 你也可以指定一个特定的 :ref:`参考/报告/ paper_formats` 此报告。最后, 如​​果你需要获得超过你的模型, 你可以定义 :ref:`参考/报告/ custom_reports` 类, 让你获得更多的车型和记录在模板中。"

#: ../../reference/reports.rst:24
msgid "Report"
msgstr "报告"

#: ../../reference/reports.rst:26
msgid "Every report must be declared by a :ref:`report action <reference/actions/report>`."
msgstr "所有的报表必须通过 :ref:`报表动作 <reference/actions/report>` 声明."

#: ../../reference/reports.rst:29
msgid "For simplicity, a shortcut ``<report>`` element is available to define a report, rather than have to set up :ref:`the action <reference/actions/report>` and its surroundings manually. That ``<report>`` can take the following attributes:"
msgstr "For simplicity, a shortcut ``<report>`` element is available to define a report, rather than have to set up :ref:`the action <reference/actions/report>` and its surroundings manually. That ``<report>`` can take the following attributes :"

#: ../../reference/reports.rst:35
msgid "the generated record's :term:`external id`"
msgstr "生成的记录的 :term:`external id` "

#: ../../reference/reports.rst:49
msgid "if set to True, the report will be stored as an attachment of the record using the name generated by the ``attachment`` expression; you can use this if you need your report to be generated only once (for legal reasons, for example)"
msgstr "如果设置为True, 则报告将被存储为使用由 ``attachment`` 表达式生成的名称记录的附件;你可以使用这个, 如果你需要你的报告中只生成一次（由于法律原因, 例如）"

#: ../../reference/reports.rst:54
msgid "python expression that defines the name of the report; the record is acessible as the variable ``object``"
msgstr "定义报表的名称Python表达;记录是acessible作为变量 ``object`` "

#: ../../reference/reports.rst:58
msgid "``paperformat``"
msgstr ""

#: ../../reference/reports.rst:57
msgid "external id of the paperformat you wish to use (defaults to the company's paperformat if not specified)"
msgstr ""

#: ../../reference/reports.rst:60 ../../reference/reports.rst:257
msgid "Example::"
msgstr "例如 ::"

#: ../../reference/reports.rst:77
msgid "Report template"
msgstr "报告模板"

#: ../../reference/reports.rst:81
msgid "Minimal viable template"
msgstr "最小可行模板"

#: ../../reference/reports.rst:83
msgid "A minimal template would look like::"
msgstr "一个最小的模板会是什么样子 ::"

#: ../../reference/reports.rst:98
msgid "Calling ``external_layout`` will add the default header and footer on your report. The PDF body will be the content inside the ``<div class=\"page\">``. The template's ``id`` must be the name specified in the report declaration; for example ``account.report_invoice`` for the above report. Since this is a QWeb template, you can access all the fields of the ``docs`` objects received by the template."
msgstr "Calling ``external_layout`` will add the default header and footer on your report. The PDF body will be the content inside the ``<div class=`` page ``>`` . The template's ``id`` must be the name specified in the report declaration; for example ``account.report_invoice`` for the above report. Since this is a QWeb template, you can access all the fields of the ``docs`` objects received by the template."

#: ../../reference/reports.rst:105
msgid "There are some specific variables accessible in reports, mainly:"
msgstr "有报告中访问一些特定的变量, 主要是:"

#: ../../reference/reports.rst:107
msgid "``docs``"
msgstr " ``docs`` "

#: ../../reference/reports.rst:108
msgid "records for the current report"
msgstr "当前报告的记录"

#: ../../reference/reports.rst:109
msgid "``doc_ids``"
msgstr " ``doc_ids`` "

#: ../../reference/reports.rst:110
msgid "list of ids for the ``docs`` records"
msgstr " ``docs`` 记录的ids列表"

#: ../../reference/reports.rst:111
msgid "``doc_model``"
msgstr " ``doc_model`` "

#: ../../reference/reports.rst:112
msgid "model for the ``docs`` records"
msgstr " ``docs`` 记录的模型"

#: ../../reference/reports.rst:113
msgid "``time``"
msgstr " ``time`` "

#: ../../reference/reports.rst:114
msgid "a reference to :mod:`python:time` from the Python standard library"
msgstr "从Python标准库time `:引用 :mod:` Python"

#: ../../reference/reports.rst:116
msgid "``res.user`` record for the user printing the report"
msgstr "打印报告的用户的 ``res.user`` 记录"

#: ../../reference/reports.rst:118
msgid "``res_company``"
msgstr " ``res_company`` "

#: ../../reference/reports.rst:118
msgid "record for the current ``user``'s company"
msgstr "当前 ``user`` 的公司纪录"

#: ../../reference/reports.rst:120
msgid "If you wish to access other records/models in the template, you will need :ref:`a custom report <reference/reports/custom_reports>`."
msgstr "If you wish to access other records/models in the template, you will need :ref:`a custom report <reference/reports/custom_reports>` ."

#: ../../reference/reports.rst:124
msgid "Translatable Templates"
msgstr "可翻译模板"

#: ../../reference/reports.rst:126
msgid "If you wish to translate reports (to the language of a partner, for example), you need to define two templates:"
msgstr "如果你要翻译报告（给合作伙伴的语言, 例如）, 您需要定义两个模板:"

#: ../../reference/reports.rst:129
msgid "The main report template"
msgstr "主报告模板"

#: ../../reference/reports.rst:130
msgid "The translatable document"
msgstr "可翻译文档"

#: ../../reference/reports.rst:132
msgid "You can then call the translatable document from your main template with the attribute ``t-lang`` set to a language code (for example ``fr`` or ``en_US``) or to a record field. You will also need to re-browse the related records with the proper context if you use fields that are translatable (like country names, sales conditions, etc.)"
msgstr "然后, 您可以从您的属性 ``T-lang`` 设置为语言代码（例如 ``fr`` 或 ``en_US`` ）, 或至创纪录的场主模板调用翻译的文档。您还需要重新浏览相关记录与适当的范围内, 如果你使用的是翻译字段（如国名, 销售条件等）"

#: ../../reference/reports.rst:139
msgid "If your report template does not use translatable record fields, re-browsing the record in another language is *not* necessary and will impact performances."
msgstr "如果您的报告模板不使用翻译记录字段, 再浏览记录在另一种语言是 *不* 必要的, 会影响演出。"

#: ../../reference/reports.rst:142
msgid "For example, let's look at the Sale Order report from the Sale module::"
msgstr "例如, 让我们来看看从销售模块销售订单报告 ::"

#: ../../reference/reports.rst:172
msgid "The main template calls the translatable template with ``doc.partner_id.lang`` as a ``t-lang`` parameter, so it will be rendered in the language of the partner. This way, each Sale Order will be printed in the language of the corresponding customer. If you wish to translate only the body of the document, but keep the header and footer in a default language, you could call the report's external layout this way::"
msgstr "主模板调用翻译模板 ``doc.partner_id.lang`` 作为一个 ``T-lang`` 参数, 所以它会在合作伙伴的语言来呈现。这样, 每个销售订单将被打印在相应客户的语言。如果你想翻译的文档的只是身体, 而是保持在一个默认语言的页眉和页脚, 你可以调用报表的外部布局这样 ::"

#: ../../reference/reports.rst:182
msgid "Please take note that this works only when calling external templates, you will not be able to translate part of a document by setting a ``t-lang`` attribute on an xml node other than ``t-call``. If you wish to translate part of a template, you can create an external template with this partial template and call it from the main one with the ``t-lang`` attribute."
msgstr "请大家注意, 这只能调用外部模板时, 您将无法通过比 ``T-call`` 其他的XML节点上设置一个 ``T-lang`` 属性上传文档的一部分。如果你想翻译一个模板的一部分, 你可以创建一个外部模板, 这部分的模板, 并从主一个具有 ``T-lang`` 属性调用它。"

#: ../../reference/reports.rst:190
msgid "Barcodes"
msgstr "条码"

#: ../../reference/reports.rst:192
msgid "Barcodes are images returned by a controller and can easily be embedded in reports thanks to the QWeb syntax:"
msgstr "条形码是由控制器返回的图像, 可以很容易地嵌入到报告要归功于QWeb语法:"

#: ../../reference/reports.rst:199
msgid "More parameters can be passed as a query string"
msgstr "更多参数可以通过作为查询字符串"

#: ../../reference/reports.rst:208
msgid "Useful Remarks"
msgstr "有用的备注"

#: ../../reference/reports.rst:209
msgid "Twitter Bootstrap and FontAwesome classes can be used in your report template"
msgstr "Twitter的引导和FontAwesome类可以在报告模板中使用"

#: ../../reference/reports.rst:211
msgid "Local CSS can be put directly in the template"
msgstr "本地的CSS可以直接在模板中放"

#: ../../reference/reports.rst:212
msgid "Global CSS can be inserted in the main report layout by inheriting its template and inserting your CSS::"
msgstr "全局CSS可以插入主报表布局在继承其模板并插入你的CSS ::"

#: ../../reference/reports.rst:224
msgid "If it appears that your PDF report is missing the styles, please check :ref:`these instructions <reference/backend/reporting/printed-reports/pdf-without-styles>`."
msgstr ""

#: ../../reference/reports.rst:230
msgid "Paper Format"
msgstr "纸张格式"

#: ../../reference/reports.rst:232
msgid "Paper formats are records of ``report.paperformat`` and can contain the following attributes:"
msgstr "论文的格式是 ``report.paperformat`` 记录, 可以包含下列属性:"

#: ../../reference/reports.rst:238
msgid "``description``"
msgstr " ``description`` "

#: ../../reference/reports.rst:239
msgid "a small description of your format"
msgstr "格式的简短描述"

#: ../../reference/reports.rst:242
msgid "``format``"
msgstr " ``format`` "

#: ../../reference/reports.rst:241
msgid "either a predefined format (A0 to A9, B0 to B10, Legal, Letter, Tabloid,...) or ``custom``; A4 by default. You cannot use a non-custom format if you define the page dimensions."
msgstr "无论是预定义的格式（A0到A9, B0到B10, 法律, 信, 小报, ...）或 ``custom`` ; A4在默认情况下。不能使用非自定义格式, 如果你定义页面的尺寸。"

#: ../../reference/reports.rst:244
msgid "``dpi``"
msgstr " ``dpi`` "

#: ../../reference/reports.rst:245
msgid "output DPI; 90 by default"
msgstr "输出DPI; 默认90"

#: ../../reference/reports.rst:246
msgid "``margin_top``, ``margin_bottom``, ``margin_left``, ``margin_right``"
msgstr " ``margin_top`` , ``margin_bottom`` , ``margin_left`` , ``margin_right`` "

#: ../../reference/reports.rst:247
msgid "margin sizes in mm"
msgstr "保证金规模在毫米"

#: ../../reference/reports.rst:248
msgid "``page_height``, ``page_width``"
msgstr " ``page_height`` , ``page_width`` "

#: ../../reference/reports.rst:249
msgid "page dimensions in mm"
msgstr "页面尺寸, 按毫米"

#: ../../reference/reports.rst:250
msgid "``orientation``"
msgstr " ``orientation`` "

#: ../../reference/reports.rst:251
msgid "Landscape or Portrait"
msgstr "横向或纵向"

#: ../../reference/reports.rst:252
msgid "``header_line``"
msgstr " ``header_line`` "

#: ../../reference/reports.rst:253
msgid "boolean to display a header line"
msgstr "布尔显示的标题行"

#: ../../reference/reports.rst:255
msgid "``header_spacing``"
msgstr " ``header_spacing`` "

#: ../../reference/reports.rst:255
msgid "header spacing in mm"
msgstr "头部间距, 按毫米"

#: ../../reference/reports.rst:278
msgid "Custom Reports"
msgstr "自定义报告"

#: ../../reference/reports.rst:280
msgid "The report model has a default ``get_html`` function that looks for a model named :samp:`report.{module.report_name}`. If it exists, it will use it to call the QWeb engine; otherwise a generic function will be used. If you wish to customize your reports by including more things in the template (like records of others models, for example), you can define this model, overwrite the function ``render_html`` and pass objects in the ``docargs`` dictionnary:"
msgstr "该报表模型有一个默认的 ``get_html`` 功能查找名为型号 :samp:`报告{module.report_name}` 。如果它存在, 它会用它来调用QWeb引擎;否则一个通用的功能将被使用。如果你想通过包括更多的东西在模板中（像其他车型记录, 例如）自定义您的报告, 您可以定义这种模式, 覆盖功能 ``render_html`` 和 ``docargs`` dictionnary传递对象:"

#: ../../reference/reports.rst:305
msgid "Reports are web pages"
msgstr "网页报告"

#: ../../reference/reports.rst:307
msgid "Reports are dynamically generated by the report module and can be accessed directly via URL:"
msgstr "报告是由动态报表模块生成, 并可以通过URL直接访问:"

#: ../../reference/reports.rst:310
msgid "For example, you can access a Sale Order report in html mode by going to \\http://<server-address>/report/html/sale.report_saleorder/38"
msgstr "For example, you can access a Sale Order report in html mode by going to \\http ://<server-address>/report/html/sale.report_saleorder/38"

#: ../../reference/reports.rst:313
msgid "Or you can access the pdf version at \\http://<server-address>/report/pdf/sale.report_saleorder/38"
msgstr "Or you can access the pdf version at \\http ://<server-address>/report/pdf/sale.report_saleorder/38"

#: ../../reference/security.rst:7
msgid "Security in Odoo"
msgstr "Odoo安全"

#: ../../reference/security.rst:9
msgid "Aside from manually managing access using custom code, Odoo provides two main data-driven mechanisms to manage or restrict access to data."
msgstr "除了使用自定义代码手动管理访问, Odoo提供管理或限制访问数据的两个主要数据驱动的机制。"

#: ../../reference/security.rst:12
msgid "Both mechanisms are linked to specific users through *groups*: a user belongs to any number of groups, and security mechanisms are associated to groups, thus applying security mechamisms to users."
msgstr "这两种机制都与通过 *基团特定的用户* :用户属于任意数量的组, 和安全机制关联到组, 从而应用安全mechamisms给用户。"

#: ../../reference/security.rst:19
msgid "Access Control"
msgstr "访问控制"

#: ../../reference/security.rst:21
msgid "Managed by the ``ir.model.access`` records, defines access to a whole model."
msgstr "由 ``ir.model.access`` 记录管理, 定义了访问整个模型。"

#: ../../reference/security.rst:23
msgid "Each access control has a model to which it grants permissions, the permissions it grants and optionally a group."
msgstr "每个访问控制有一个模型, 它授予的权限, 它授予的权限和任选一组。"

#: ../../reference/security.rst:26
msgid "Access controls are additive, for a given model a user has access all permissions granted to any of its groups: if the user belongs to one group which allows writing and another which allows deleting, they can both write and delete."
msgstr "访问控制是附加的, 对于一个给定的模型, 用户可以访问其任何团体授予的所有权限:如果用户属于一个组, 让写作和另一个则允许删除, 它们可以同时写入和删除。"

#: ../../reference/security.rst:31
msgid "If no group is specified, the access control applies to all users, otherwise it only applies to the members of the given group."
msgstr "如果没有指定组, 则访问控制适用于所有用户, 否则它仅适用于给定组的成员。"

#: ../../reference/security.rst:34
msgid "Available permissions are creation (``perm_create``), searching and reading (``perm_read``), updating existing records (``perm_write``) and deleting existing records (``perm_unlink``)"
msgstr "可用的权限是创建（ ``perm_create`` ）, 搜索和阅读（ ``perm_read`` ）, 更新现有记录（ ``perm_write`` ）和删除现有记录（ ``perm_unlink`` ）"

#: ../../reference/security.rst:41
msgid "Record Rules"
msgstr "记录规则"

#: ../../reference/security.rst:43
msgid "Record rules are conditions that records must satisfy for an operation (create, read, update or delete) to be allowed. It is applied record-by-record after access control has been applied."
msgstr "记录规则条件的记录必须满足的操作（创建, 读取, 更新或删除）就可以了。该应用之后的访问控制已应用于记录被记录。"

#: ../../reference/security.rst:47
msgid "A record rule has:"
msgstr "记录规则有:"

#: ../../reference/security.rst:49
msgid "a model on which it applies"
msgstr "就其所适用的典范"

#: ../../reference/security.rst:50
msgid "a set of permissions to which it applies (e.g. if ``perm_read`` is set, the rule will only be checked when reading a record)"
msgstr "一组权限其所适用（例如, 如果 ``perm_read`` 设置, 该规则将只读取记录时选中）"

#: ../../reference/security.rst:52
msgid "a set of user groups to which the rule applies, if no group is specified the rule is *global*"
msgstr "一组用户群体以应用该规则, 如果没有组指定的规则是 *全球*"

#: ../../reference/security.rst:54
msgid "a :ref:`domain <reference/orm/domains>` used to check whether a given record matches the rule (and is accessible) or does not (and is not accessible). The domain is evaluated with two variables in context: ``user`` is the current user's record and ``time`` is the `time module`_"
msgstr "a :ref:`domain <reference/orm/domains>` used to check whether a given record matches the rule (and is accessible) or does not (and is not accessible). The domain is evaluated with two variables in context :``user`` is the current user's record and ``time`` is the `time module` _"

#: ../../reference/security.rst:59
msgid "Global rules and group rules (rules restricted to specific groups versus groups applying to all users) are used quite differently:"
msgstr "全球规则和分组规则（仅限于特定群体对适用于所有用户组的规则）中使用完全不同:"

#: ../../reference/security.rst:62
msgid "Global rules are subtractive, they *must all* be matched for a record to be accessible"
msgstr "全球规则是减法, 他们 *必须全部* 匹配的记录可访问"

#: ../../reference/security.rst:64
msgid "Group rules are additive, if *any* of them matches (and all global rules match) then the record is accessible"
msgstr "集团的规则是累加的, 如果 *其中任何* 匹配（和所有的全球规则匹配）, 则记录访问"

#: ../../reference/security.rst:67
msgid "This means the first *group rule* restricts access, but any further *group rule* expands it, while *global rules* can only ever restrict access (or have no effect)."
msgstr "这意味着第一个 *组规则* 限制访问, 但任何进一步的 *组规则* 对其进行了扩展, 而 *全球规则* 永远只能限制访问（或没有影响）。"

#: ../../reference/security.rst:71
msgid "record rules do not apply to the Administrator user"
msgstr "创纪录的规则并不适用于管理员用户"

#: ../../reference/security.rst:74
msgid "although access rules do"
msgstr "虽然访问规则做"

#: ../../reference/security.rst:79
msgid "Field Access"
msgstr "字段访问"

#: ../../reference/security.rst:83
msgid "An ORM :class:`~openerp.fields.Field` can have a ``groups`` attribute providing a list of groups (as a comma-separated string of :term:`external identifiers`)."
msgstr "一个ORM :class:`~openerp.fields.Field` 可以有一个 ``groups`` 属性提供组的列表（以逗号分隔的字符串 :term:`外部identifiers` ）。"

#: ../../reference/security.rst:87
msgid "If the current user is not in one of the listed groups, he will not have access to the field:"
msgstr "如果当前用户不处于所列基团之一, 他将不能访问的字段:"

#: ../../reference/security.rst:90
msgid "restricted fields are automatically removed from requested views"
msgstr "受限制的字段, 从要求的视图自动删除"

#: ../../reference/security.rst:91
msgid "restricted fields are removed from :meth:`~openerp.models.Model.fields_get` responses"
msgstr ":meth:`~openerp.models.Model.fields_get` 反应限制字段被调离"

#: ../../reference/security.rst:93
msgid "attempts to (explicitly) read from or write to restricted fields results in an access error"
msgstr "尝试（明确地）读取或写入受限字段导致访问错误"

#: ../../reference/security.rst:102
msgid "Workflow transition rules"
msgstr "工作流转换规则"

#: ../../reference/security.rst:104
msgid "Workflow transitions can be restricted to a specific group. Users outside the group can not trigger the transition."
msgstr "工作流程的转换可以被限制到特定的组。组外的用户无法触发的过渡。"

#: ../../reference/testing.rst:8
msgid "Testing Modules"
msgstr "测试模块"

#: ../../reference/testing.rst:10
msgid "Odoo provides support for testing modules using unittest."
msgstr ""

#: ../../reference/testing.rst:12
msgid "To write tests, simply define a ``tests`` sub-package in your module, it will be automatically inspected for test modules. Test modules should have a name starting with ``test_`` and should be imported from ``tests/__init__.py``, e.g."
msgstr "编写测试, 简单地定义一个 ``tests`` 子包在你的模块, 它会自动检查是否有测试模块。测试模块应该有一个名字开头 ``test_`` , 应该从 ``测试/ __ __初始化。py`` , 如进口"

#: ../../reference/testing.rst:26
msgid "and ``__init__.py`` contains::"
msgstr "和 ``__init __。py`` 包含 ::"

#: ../../reference/testing.rst:32
msgid "test modules which are not imported from ``tests/__init__.py`` will not be run"
msgstr "而不是从 ``测试导入测试模块/ __ __初始化。py`` 将不会运行"

#: ../../reference/testing.rst:37
msgid "previously, the test runner would only run modules added to two lists ``fast_suite`` and ``checks`` in ``tests/__init__.py``. In 8.0 it will run all imported modules"
msgstr "以前, 测试运行将只运行模块添加到两个列表 ``fast_suite`` 和 ``checks`` 在 ``测试/ __ __初始化。py`` 。在8.0它将运行所有导入模块"

#: ../../reference/testing.rst:41
msgid "The test runner will simply run any test case, as described in the official `unittest documentation`_, but Odoo provides a number of utilities and helpers related to testing Odoo content (modules, mainly):"
msgstr "测试运行会简单地运行任何测试情况下, 如在正式 `单元测试documentation` _说明, 但Odoo提供了许多实用程序和相关检测Odoo内容（模块, 主要）助手:"

#: ../../reference/testing.rst:51
msgid "By default, tests are run once right after the corresponding module has been installed. Test cases can also be configured to run after all modules have been installed, and not run right after the module installation:"
msgstr "默认情况下, 测试相应的模块安装后, 一旦正确运行。测试情况下也可配置为运行已安装的所有模块后, 而不是在模块安装后右运行:"

#: ../../reference/testing.rst:59
msgid "The most common situation is to use :class:`~openerp.tests.common.TransactionCase` and test a property of a model in each method::"
msgstr "最常见的情况是使用 :class:`~openerp.tests.common.TransactionCase` 并在每个方法测试模型的属性 ::"

#: ../../reference/testing.rst:74
msgid "Running tests"
msgstr "运行测试"

#: ../../reference/testing.rst:76
msgid "Tests are automatically run when installing or updating modules if :option:`--test-enable <odoo.py --test-enable>` was enabled when starting the Odoo server."
msgstr "Tests are automatically run when installing or updating modules if :option:`--test-enable <odoo.py --test-enable>` was enabled when starting the Odoo server."

#: ../../reference/testing.rst:80
msgid "As of Odoo 8, running tests outside of the install/update cycle is not supported."
msgstr "由于Odoo 8, 运行安装/更新周期之外的测试不支持。"

#: ../../reference/translations.rst:8
msgid "Translating Modules"
msgstr "翻译模块"

#: ../../reference/translations.rst:11
msgid "Exporting translatable term"
msgstr "导出翻译术语"

#: ../../reference/translations.rst:13
msgid "A number of terms in your modules are \"implicitly translatable\" as a result, even if you haven't done any specific work towards translation you can export your module's translatable terms and may find content to work with."
msgstr "许多术语在你的模块是'含蓄翻译'这样一来, 即使你没有做对翻译的具体工作, 你可以导出你的模块的翻译术语和可能会发现内容的工作。"

#: ../../reference/translations.rst:19
msgid "Translations export is performed via the administration interface by logging into the backend interface and opening :menuselection:`Settings --> Translations --> Import / Export --> Export Translations`"
msgstr "menuselection: - >翻译 - >导入/导出 - >导出Translations ``设置出口的翻译是通过登录到后端接口开放, 通过管理界面进行"

#: ../../reference/translations.rst:23
msgid "leave the language to the default (new language/empty template)"
msgstr "离开语言为默认（新的语言/空模板）"

#: ../../reference/translations.rst:24
msgid "select the `PO File`_ format"
msgstr "选择 `PO File` _格式"

#: ../../reference/translations.rst:25
msgid "select your module"
msgstr "选择你的模块"

#: ../../reference/translations.rst:26
msgid "click :guilabel:`Export` and download the file"
msgstr "点击 :guilabel:`Export` 和下载文件"

#: ../../reference/translations.rst:32
msgid ""
"This gives you a file called :file:`{yourmodule}.pot` which should be moved to the :file:`{yourmodule}/i18n/` directory. The file is a *PO Template* which simply lists translatable strings and from which actual translations (PO files) can be created. PO files can be created using msginit_, with a dedicated translation tool like POEdit_ or by simply copying the template to a new file called :file:`{language}.po`. Translation files should be put in :file:`{yourmodule}/i18n/`, next to :file:`{yourmodule}."
"pot`, and will be automatically loaded by Odoo when the corresponding language is installed (via :menuselection:`Settings --> Translations --> Load a Translation`)"
msgstr "这给你一个文件名为 :file:`{} yourmodule其中.pot` 应该被移到 :file:`{} yourmodule /国际化/` 目录。该文件是一个 * PO模板* 它只是列出了翻译字符串, 并从实际的翻译（PO文件）可以被创建。可以用msginit_创建PO文件的, 有专门的翻译工具如POEdit_或者简单地复制模板到一个名为新文件 :file:`{}语言.po` 。翻译文件应放在 :file:`{} yourmodule /国际化/` , 旁边即:file:`{} yourmodule .pot` , 并将于Odoo安装了相应的语言时, 通过自动加载（ :menuselection:`设置 - >翻译 - >加载Translation` ）"

#: ../../reference/translations.rst:42
msgid "translations for all loaded languages are also installed or updated when installing or updating a module"
msgstr "安装或更新一个模块时, 还安装或更新翻译所有装载语言"

#: ../../reference/translations.rst:46
msgid "Implicit exports"
msgstr "隐出口"

#: ../../reference/translations.rst:48
msgid "Odoo automatically exports translatable strings from \"data\"-type content:"
msgstr "Odoo自动导出翻译字符串从'数据'- 类型的内容:"

#: ../../reference/translations.rst:50
msgid "in non-QWeb views, all text nodes are exported as well as the content of the ``string``, ``help``, ``sum``, ``confirm`` and ``placeholder`` attributes"
msgstr "非QWeb的视图, 所有的文本节点远销还有 ``string`` 的内容, ``help`` , ``sum`` , ``confirm`` 和 ``placeholder`` 属性"

#: ../../reference/translations.rst:53
msgid "QWeb templates (both server-side and client-side), all text nodes are exported except inside ``t-translation=\"off\"`` blocks, the content of the ``title``, ``alt``, ``label`` and ``placeholder`` attributes are also exported"
msgstr "QWeb模板（包括服务器端和客户端）, 所有的文本节点远销除了内部 ``​​T-翻译='关'`` 块时, ``title`` 的内容, ``alt````label`` 和 ``placeholder`` 属性还出口"

#: ../../reference/translations.rst:57
msgid "for :class:`~openerp.fields.Field`, unless their model is marked with ``_translate = False``:"
msgstr "为 :class:`~openerp.fields.Field` , 除非他们的模型上标有 ``_translate = False`` :"

#: ../../reference/translations.rst:60
msgid "their ``string`` and ``help`` attributes are exported"
msgstr "他们 ``string`` 和 ``help`` 属性出口"

#: ../../reference/translations.rst:61
msgid "if ``selection`` is present and a list (or tuple), it's exported"
msgstr "如果 ``selection`` 存在和一个列表（或元组）, 它的出口"

#: ../../reference/translations.rst:62
msgid "if their ``translate`` attribute is set to ``True``, all of their existing values (across all records) are exported"
msgstr "如果他们的 ``translate`` 属性设置为 ``True`` , 那么所有的现有价值（所有记录）出口"

#: ../../reference/translations.rst:64
msgid "help/error messages of :attr:`~openerp.models.Model._constraints` and :attr:`~openerp.models.Model._sql_constraints` are exported"
msgstr ":attr: ~openerp.models.Model._sql_constraints `出口` :帮助/错误信息 `~openerp.models.Model._constraints` 和:ATTR"

#: ../../reference/translations.rst:68
msgid "Explicit exports"
msgstr "明确出口"

#: ../../reference/translations.rst:70
msgid "When it comes to more \"imperative\" situations in Python code or Javascript code, Odoo cannot automatically export translatable terms so they must be marked explicitly for export. This is done by wrapping a literal string in a function call."
msgstr "当谈到在Python代码或JavaScript代码更'势在必行'的情况下, Odoo不能自动导出翻译方面, 使他们必须明确标明用于出口。这是由包裹在一个函数调用一个字符串进行。"

#: ../../reference/translations.rst:75
msgid "In Python, the wrapping function is :func:`openerp._`::"
msgstr "在Python中, 包装的功能是 :func:`openerp._` ::"

#: ../../reference/translations.rst:79
msgid "In JavaScript, the wrapping function is generally :js:func:`openerp.web._t`:"
msgstr "在JavaScript中, 包装功能一般为 :js: func :`openerp.web._t` :"

#: ../../reference/translations.rst:87
msgid "Only literal strings can be marked for exports, not expressions or variables. For situations where strings are formatted, this means the format string must be marked, not the formatted string::"
msgstr "只有文字字符串可以被标记为出口, 而不是表达式或变量。对于在字符串格式化的情况下, 这意味着格式字符串必须标注, 而不是格式化字符串 ::"

#: ../../reference/upgrade_api.rst:11
msgid "Upgrade API"
msgstr "升级 API"

#: ../../reference/upgrade_api.rst:14
msgid "Introduction"
msgstr "介绍"

#: ../../reference/upgrade_api.rst:16
msgid "This document describes the API used to upgrade an Odoo database to a higher version."
msgstr ""

#: ../../reference/upgrade_api.rst:19
msgid "It allows a database to be upgraded without ressorting to the html form at https://upgrade.odoo.com Although the database will follow the same process described on that form."
msgstr ""

#: ../../reference/upgrade_api.rst:24
msgid "The required steps are:"
msgstr "必须的步骤 :"

#: ../../reference/upgrade_api.rst:26
msgid "creating a request"
msgstr "创建请求"

#: ../../reference/upgrade_api.rst:27
msgid "uploading a database dump"
msgstr "上传数据库导出"

#: ../../reference/upgrade_api.rst:28
msgid "running the upgrade process"
msgstr "运行升级过程"

#: ../../reference/upgrade_api.rst:29
msgid "obtaining the status of the database request"
msgstr ""

#: ../../reference/upgrade_api.rst:30
msgid "downloading the upgraded database dump"
msgstr ""

#: ../../reference/upgrade_api.rst:33
msgid "The methods"
msgstr ""

#: ../../reference/upgrade_api.rst:38
msgid "Creating a database upgrade request"
msgstr ""

#: ../../reference/upgrade_api.rst:40
msgid "This action creates a database request with the following information:"
msgstr "该动作使用下列信息创建数据库请求 :"

#: ../../reference/upgrade_api.rst:42
msgid "your contract reference"
msgstr ""

#: ../../reference/upgrade_api.rst:43
msgid "your email address"
msgstr ""

#: ../../reference/upgrade_api.rst:44
msgid "the target version (the Odoo version you want to upgrade to)"
msgstr ""

#: ../../reference/upgrade_api.rst:45
msgid "the purpose of your request (test or production)"
msgstr ""

#: ../../reference/upgrade_api.rst:46
msgid "the database dump name (required but purely informative)"
msgstr ""

#: ../../reference/upgrade_api.rst:47
msgid "optionally the server timezone (for Odoo source version < 6.1)"
msgstr ""

#: ../../reference/upgrade_api.rst:50
msgid "The ``create`` method"
msgstr ""

#: ../../reference/upgrade_api.rst:54
msgid "Creates a database upgrade request"
msgstr ""

#: ../../reference/upgrade_api.rst:56
msgid "(required) your enterprise contract reference"
msgstr ""

#: ../../reference/upgrade_api.rst:57
msgid "(required) your email address"
msgstr ""

#: ../../reference/upgrade_api.rst:58
msgid "(required) the Odoo version you want to upgrade to. Valid choices: 6.0, 6.1, 7.0, 8.0"
msgstr ""

#: ../../reference/upgrade_api.rst:59
msgid "(required) the purpose of your upgrade database request. Valid choices: test, production."
msgstr ""

#: ../../reference/upgrade_api.rst:60
msgid "(required) a purely informative name for you database dump file"
msgstr ""

#: ../../reference/upgrade_api.rst:61
msgid "(optional) the timezone used by your server. Only for Odoo source version < 6.1"
msgstr ""

#: ../../reference/upgrade_api.rst:62 ../../reference/upgrade_api.rst:215 ../../reference/upgrade_api.rst:286 ../../reference/upgrade_api.rst:352
msgid "request result"
msgstr ""

#: ../../reference/upgrade_api.rst:65
msgid "The *create* method returns a json dictionary containing the following keys:"
msgstr ""

#: ../../reference/upgrade_api.rst:68
msgid "``failures``"
msgstr ""

#: ../../reference/upgrade_api.rst:70
msgid "The list of errors."
msgstr ""

#: ../../reference/upgrade_api.rst:72
msgid "A list of dictionaries, each dictionary giving information about one particular error. Each dictionary can contain various keys depending of the type of error but you will always get the ``reason`` and the ``message`` keys:"
msgstr ""

#: ../../reference/upgrade_api.rst:76
msgid "``reason``: the error type"
msgstr ""

#: ../../reference/upgrade_api.rst:77
msgid "``message``: a human friendly message"
msgstr ""

#: ../../reference/upgrade_api.rst:79
msgid "Some possible keys:"
msgstr ""

#: ../../reference/upgrade_api.rst:81
msgid "``code``: a faulty value"
msgstr ""

#: ../../reference/upgrade_api.rst:82
msgid "``value``: a faulty value"
msgstr ""

#: ../../reference/upgrade_api.rst:83
msgid "``expected``: a list of valid values"
msgstr ""

#: ../../reference/upgrade_api.rst:85
msgid "See a sample output aside."
msgstr ""

#: ../../reference/upgrade_api.rst:118
msgid "If the *create* method is successful, the value associated to the *request* key will be a dictionary containing various information about the created request:"
msgstr ""

#: ../../reference/upgrade_api.rst:121
msgid "The most important keys are:"
msgstr ""

#: ../../reference/upgrade_api.rst:123
msgid "``id``: the request id"
msgstr ""

#: ../../reference/upgrade_api.rst:124
msgid "``key``: your private key for this request"
msgstr ""

#: ../../reference/upgrade_api.rst:126
msgid "These 2 values will be requested by the other methods (upload, process and status)"
msgstr ""

#: ../../reference/upgrade_api.rst:128
msgid "The other keys will be explained in the section describing the :ref:`status method <upgrade-api-status-method>`."
msgstr ""

#: ../../reference/upgrade_api.rst:132
msgid "Sample script"
msgstr ""

#: ../../reference/upgrade_api.rst:134
msgid "Here are 2 examples of database upgrade request creation using:"
msgstr ""

#: ../../reference/upgrade_api.rst:136
msgid "one in the python programming language using the pycurl library"
msgstr ""

#: ../../reference/upgrade_api.rst:137
msgid "one in the bash programming language using `curl <http://curl.haxx.se>`_ (tool for transfering data using http) and `jq <https://stedolan.github.io/jq>`_ (JSON processor):"
msgstr ""

#: ../../reference/upgrade_api.rst:202
msgid "Uploading your database dump"
msgstr ""

#: ../../reference/upgrade_api.rst:204
msgid "This action upload your database dump."
msgstr "该动作上传你的数据库转储."

#: ../../reference/upgrade_api.rst:207
msgid "The ``upload`` method"
msgstr ""

#: ../../reference/upgrade_api.rst:211
msgid "Uploads a database dump"
msgstr ""

#: ../../reference/upgrade_api.rst:213 ../../reference/upgrade_api.rst:284 ../../reference/upgrade_api.rst:350
msgid "(required) your private key"
msgstr ""

#: ../../reference/upgrade_api.rst:214 ../../reference/upgrade_api.rst:285 ../../reference/upgrade_api.rst:351
msgid "(required) your request id"
msgstr ""

#: ../../reference/upgrade_api.rst:218 ../../reference/upgrade_api.rst:289 ../../reference/upgrade_api.rst:355
msgid "The request id and the private key are obtained using the :ref:`create method <upgrade-api-create-method>`"
msgstr ""

#: ../../reference/upgrade_api.rst:221 ../../reference/upgrade_api.rst:292
msgid "The result is a json dictionary containing the list of ``failures``, which should be empty if everything went fine."
msgstr ""

#: ../../reference/upgrade_api.rst:273
msgid "Asking to process your request"
msgstr ""

#: ../../reference/upgrade_api.rst:275
msgid "This action ask the Upgrade Platform to process your database dump."
msgstr ""

#: ../../reference/upgrade_api.rst:278
msgid "The ``process`` method"
msgstr ""

#: ../../reference/upgrade_api.rst:282
msgid "Process a database dump"
msgstr ""

#: ../../reference/upgrade_api.rst:339
msgid "Obtaining your request status"
msgstr ""

#: ../../reference/upgrade_api.rst:341
msgid "This action ask the status of your database upgrade request."
msgstr ""

#: ../../reference/upgrade_api.rst:344
msgid "The ``status`` method"
msgstr ""

#: ../../reference/upgrade_api.rst:348
msgid "Ask the status of a database upgrade request"
msgstr ""

#: ../../reference/upgrade_api.rst:358
msgid "The result is a json dictionary containing various information about your database upgrade request."
msgstr ""

#: ../../reference/upgrade_api.rst:401
msgid "Sample output"
msgstr ""

#: ../../reference/upgrade_api.rst:403
msgid "The ``request`` key contains various useful information about your request:"
msgstr ""

#: ../../reference/upgrade_api.rst:406
msgid "the request id"
msgstr ""

#: ../../reference/upgrade_api.rst:407
msgid "``key``"
msgstr ""

#: ../../reference/upgrade_api.rst:408
msgid "your private key"
msgstr ""

#: ../../reference/upgrade_api.rst:409
msgid "``email``"
msgstr ""

#: ../../reference/upgrade_api.rst:410
msgid "the email address you supplied when creating the request"
msgstr ""

#: ../../reference/upgrade_api.rst:412
msgid "the target Odoo version you supplied when creating the request"
msgstr ""

#: ../../reference/upgrade_api.rst:413
msgid "``aim``"
msgstr ""

#: ../../reference/upgrade_api.rst:414
msgid "the purpose (test, production) of your database upgrade request you supplied when creating the request"
msgstr ""

#: ../../reference/upgrade_api.rst:415 ../../reference/views.rst:422
msgid "``filename``"
msgstr " ``filename`` "

#: ../../reference/upgrade_api.rst:416
msgid "the filename you supplied when creating the request"
msgstr ""

#: ../../reference/upgrade_api.rst:417
msgid "``timezone``"
msgstr ""

#: ../../reference/upgrade_api.rst:418
msgid "the timezone you supplied when creating the request"
msgstr ""

#: ../../reference/upgrade_api.rst:419
msgid "``state``"
msgstr " ``state`` "

#: ../../reference/upgrade_api.rst:420
msgid "the state of your request"
msgstr ""

#: ../../reference/upgrade_api.rst:421
msgid "``issue_stage``"
msgstr ""

#: ../../reference/upgrade_api.rst:422
msgid "the stage of the issue we have create on Odoo main server"
msgstr ""

#: ../../reference/upgrade_api.rst:423
msgid "``issue``"
msgstr ""

#: ../../reference/upgrade_api.rst:424
msgid "the id of the issue we have create on Odoo main server"
msgstr ""

#: ../../reference/upgrade_api.rst:425
msgid "``status_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:426
msgid "the URL to access your database upgrade request html page"
msgstr ""

#: ../../reference/upgrade_api.rst:427
msgid "``notes_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:428
msgid "the URL to get the notes about your database upgrade"
msgstr ""

#: ../../reference/upgrade_api.rst:429
msgid "``original_sql_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:430
msgid "the URL used to get your uploaded (not upgraded) database as an SQL stream"
msgstr ""

#: ../../reference/upgrade_api.rst:431
msgid "``original_dump_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:432
msgid "the URL used to get your uploaded (not upgraded) database as an archive file"
msgstr ""

#: ../../reference/upgrade_api.rst:433
msgid "``upgraded_sql_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:434
msgid "the URL used to get your upgraded database as an SQL stream"
msgstr ""

#: ../../reference/upgrade_api.rst:435
msgid "``upgraded_dump_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:436
msgid "the URL used to get your upgraded database as an archive file"
msgstr ""

#: ../../reference/upgrade_api.rst:437
msgid "``modules_url``"
msgstr ""

#: ../../reference/upgrade_api.rst:438
msgid "the URL used to get your custom modules"
msgstr ""

#: ../../reference/upgrade_api.rst:439
msgid "``filesize``"
msgstr ""

#: ../../reference/upgrade_api.rst:440
msgid "the size of your uploaded database file"
msgstr ""

#: ../../reference/upgrade_api.rst:441
msgid "``database_uuid``"
msgstr ""

#: ../../reference/upgrade_api.rst:442
msgid "the Unique ID of your database"
msgstr ""

#: ../../reference/upgrade_api.rst:443
msgid "``created_at``"
msgstr ""

#: ../../reference/upgrade_api.rst:444
msgid "the date when you created the request"
msgstr ""

#: ../../reference/upgrade_api.rst:445
msgid "``estimated_time``"
msgstr ""

#: ../../reference/upgrade_api.rst:446
msgid "an estimation of the time it takes to upgrade your database"
msgstr ""

#: ../../reference/upgrade_api.rst:447
msgid "``processed_at``"
msgstr ""

#: ../../reference/upgrade_api.rst:448
msgid "time when your database upgrade was started"
msgstr ""

#: ../../reference/upgrade_api.rst:449
msgid "``elapsed``"
msgstr ""

#: ../../reference/upgrade_api.rst:450
msgid "the time it takes to upgrade your database"
msgstr ""

#: ../../reference/upgrade_api.rst:451
msgid "``filestore``"
msgstr ""

#: ../../reference/upgrade_api.rst:452
msgid "your attachments were converted to the filestore"
msgstr ""

#: ../../reference/upgrade_api.rst:453
msgid "``customer_message``"
msgstr ""

#: ../../reference/upgrade_api.rst:454
msgid "an important message related to your request"
msgstr ""

#: ../../reference/upgrade_api.rst:455
msgid "``database_version``"
msgstr ""

#: ../../reference/upgrade_api.rst:456
msgid "the guessed Odoo version of your uploaded (not upgraded) database"
msgstr ""

#: ../../reference/upgrade_api.rst:457
msgid "``postgresql``"
msgstr ""

#: ../../reference/upgrade_api.rst:458
msgid "the guessed Postgresql version of your uploaded (not upgraded) database"
msgstr ""

#: ../../reference/upgrade_api.rst:460
msgid "``compressions``"
msgstr ""

#: ../../reference/upgrade_api.rst:460
msgid "the compression methods used by your uploaded database"
msgstr ""

#: ../../reference/views.rst:8
msgid "Views"
msgstr "视图"

#: ../../reference/views.rst:13
msgid "Common Structure"
msgstr "公共结构"

#: ../../reference/views.rst:15
msgid "View objects expose a number of fields, they are optional unless specified otherwise."
msgstr "查看对象公开若干字段, 它们是可选的, 除非另有说明。"

#: ../../reference/views.rst:19
msgid "only useful as a mnemonic/description of the view when looking for one in a list of some sort"
msgstr "只有在某种类型的列表作为视图的记忆/描述有用找一当"

#: ../../reference/views.rst:21
msgid "``model``"
msgstr " ``model`` "

#: ../../reference/views.rst:22
msgid "the model linked to the view, if applicable (it doesn't for QWeb views)"
msgstr "链接到视图模型, 如果适用（它不QWeb视图）"

#: ../../reference/views.rst:29
msgid "``priority``"
msgstr " ``priority`` "

#: ../../reference/views.rst:24
msgid "client programs can request views by ``id``, or by ``(model, type)``. For the latter, all the views for the right type and model will be searched, and the one with the lowest ``priority`` number will be returned (it is the \"default view\")."
msgstr "客户端程序可以通过 ``id`` , 或 ``（型号, 类型）`` 要求的意见。对于后者, 对于正确的类型和型号所有的意见都会被搜索, 并具有最低 ``priority`` 号将返回（这是'默认视图'）。"

#: ../../reference/views.rst:29
msgid "``priority`` also defines the order of application during :ref:`view inheritance <reference/views/inheritance>`"
msgstr " ``priority`` also defines the order of application during :ref:`view inheritance <reference/views/inheritance>` "

#: ../../reference/views.rst:31
msgid "``arch``"
msgstr " ``arch`` "

#: ../../reference/views.rst:32
msgid "the description of the view's layout"
msgstr "视图布局的说明"

#: ../../reference/views.rst:34
msgid ":class:`~openerp.fields.Many2many` field to the groups allowed to view/use the current view"
msgstr ":class:`~openerp.fields.Many2many` 字段允许查看组/用当前视图"

#: ../../reference/views.rst:37
msgid "``inherit_id``"
msgstr " ``inherit_id`` "

#: ../../reference/views.rst:37
msgid "the current view's parent view, see :ref:`reference/views/inheritance`, unset by default"
msgstr "当前视图的父视图, 请参阅 :ref:`参考/视图/ inheritance` , 未设置默认"

#: ../../reference/views.rst:42 ../../reference/views.rst:417 ../../reference/views.rst:983
msgid "``mode``"
msgstr " ``mode`` "

#: ../../reference/views.rst:40
msgid "inheritance mode, see :ref:`reference/views/inheritance`. If ``inherit_id`` is unset the ``mode`` can only be ``primary``. If ``inherit_id`` is set, ``extension`` by default but can be explicitly set to ``primary``"
msgstr "遗传方式, 请参阅 :ref:`参考/视图/ inheritance` 。如果 ``inherit_id`` 没有设置的 ``mode`` 只能是 ``primary`` 。如果 ``inherit_id`` 设置, ``默认extension`` 但可以明确设置为 ``primary`` "

#: ../../reference/views.rst:46
msgid "``application``"
msgstr " ``application`` "

#: ../../reference/views.rst:45
msgid "website feature defining togglable views. By default, views are always applied"
msgstr "网站功能定义togglable意见。默认情况下, 意见始终应用"

#: ../../reference/views.rst:51
msgid "Inheritance"
msgstr "继承"

#: ../../reference/views.rst:54
msgid "View matching"
msgstr "视图匹配"

#: ../../reference/views.rst:56
msgid "if a view is requested by ``(model, type)``, the view with the right model and type, ``mode=primary`` and the lowest priority is matched"
msgstr "如果一个视图要求 ``（型号, 类型）`` , 用正确的型号和类型, ``模式= primary`` 和最低优先级视图匹配"

#: ../../reference/views.rst:58
msgid "when a view is requested by ``id``, if its mode is not ``primary`` its *closest* parent with mode ``primary`` is matched"
msgstr "当一个视图被要求 ``id`` , 如果它的模式是不 ``primary`` 其 *最接近的* 父与模式 ``primary`` 匹配"

#: ../../reference/views.rst:62
msgid "View resolution"
msgstr "视图解析"

#: ../../reference/views.rst:64
msgid "Resolution generates the final ``arch`` for a requested/matched ``primary`` view:"
msgstr "解决方法生成最终的 ``arch`` 的请求/匹配 ``primary`` 视图:"

#: ../../reference/views.rst:67
msgid "if the view has a parent, the parent is fully resolved then the current view's inheritance specs are applied"
msgstr "如果认为有父, 父完全解决, 那么当前视图的继承规范应用"

#: ../../reference/views.rst:69
msgid "if the view has no parent, its ``arch`` is used as-is"
msgstr "如果视图没有父, 它的 ``arch`` 作为, 是"

#: ../../reference/views.rst:70
msgid "the current view's children with mode ``extension`` are looked up  and their inheritance specs are applied depth-first (a child view is applied, then its children, then its siblings)"
msgstr "当前视图的儿童模式 ``extension`` 正在抬头一看, 他们的产业规格的应用深度优先（子视图应用, 那么它的孩子, 那么它的兄弟姐妹）"

#: ../../reference/views.rst:74
msgid "The result of applying children views yields the final ``arch``"
msgstr "将儿童的意见的结果得到最终的 ``arch`` "

#: ../../reference/views.rst:77
msgid "Inheritance specs"
msgstr "继承规范"

#: ../../reference/views.rst:79
msgid "There are three types of inheritance specs:"
msgstr "有三种类型的继承规格的:"

#: ../../reference/views.rst:81
msgid "An ``xpath`` element with an ``expr`` attribute. ``expr`` is an XPath_ expression\\ [#hasclass]_ applied to the current ``arch``, the first node it finds is the match"
msgstr "一个 ``xpath`` 与 ``expr`` 属性的元素。 ``expr`` 是XPath_表达\\ [#hasclass] _应用到当前的 ``arch`` , 它找到的第一个节点是匹配"

#: ../../reference/views.rst:84
msgid "a ``field`` element with a ``name`` attribute, matches the first ``field`` with the same ``name``"
msgstr "用 ``name`` 属性的 ``field`` 元素, 匹配的第一个 ``field`` 用相同的 ``name`` "

#: ../../reference/views.rst:86
msgid "any other element, the first element with the same name and identical attributes (ignoring ``position``) is matched"
msgstr "任何其他元件, 具有相同的名称和相同属性的所述第一元件（忽略 ``position`` ）匹配"

#: ../../reference/views.rst:89
msgid "The inheritance spec may have an optional ``position`` attribute specifying how the matched node should be altered:"
msgstr "继承规范有一个可选的 ``position`` 属性指定如何匹配的节点应该被改变:"

#: ../../reference/views.rst:92
msgid "``inside`` (default)"
msgstr " ``inside`` （默认）"

#: ../../reference/views.rst:93
msgid "the content of the inheritance spec is appended to the matched node"
msgstr "继承规范的内容被附加给匹配节点"

#: ../../reference/views.rst:95
msgid "the content of the inheritance spec replaces the matched node"
msgstr "继承规范的内容替换匹配的节点"

#: ../../reference/views.rst:97
msgid "the content of the inheritance spec is added to the matched node's parent, after the matched node"
msgstr "继承规范的内容被添加到匹配节点的父, 匹配节点之后"

#: ../../reference/views.rst:100
msgid "the content of the inheritance spec is added to the matched node's parent, before the matched node"
msgstr "继承规范的内容被添加到匹配节点的父, 匹配节点之前"

#: ../../reference/views.rst:111
msgid "``attributes``"
msgstr " ``attributes`` "

#: ../../reference/views.rst:103
msgid "the content of the inheritance spec should be ``attribute`` elements with a ``name`` attribute and an optional body:"
msgstr "继承规范的内容应该是 ``用`` name ``属性和一个可选的机身attribute`` 要素:"

#: ../../reference/views.rst:106
msgid "if the ``attribute`` element has a body, a new attributed named after its ``name`` is created on the matched node with the ``attribute`` element's text as value"
msgstr "如果 ``attribute`` 元素有一个机构, 一个新的归因评出了 ``name`` 是匹配的节点上的 ``attribute`` 元素的文本作为价值创造之后"

#: ../../reference/views.rst:109
msgid "if the ``attribute`` element has no body, the attribute named after its ``name`` is removed from the matched node. If no such attribute exists, an error is raised"
msgstr "如果 ``attribute`` 元素没有主体, 它的 ``name`` 命名的属性从匹配节点删除。如果没有这样的属性存在, 将引发错误"

#: ../../reference/views.rst:113
msgid "A view's specs are applied sequentially."
msgstr "视图的功能依次应用。"

#: ../../reference/views.rst:118
msgid "Lists"
msgstr "列表"

#: ../../reference/views.rst:120
msgid "The root element of list views is ``<tree>``\\ [#treehistory]_. The list view's root can have the following attributes:"
msgstr "The root element of list views is ``<tree>`` \\ [#treehistory]_. The list view's root can have the following attributes :"

#: ../../reference/views.rst:134
msgid "``editable``"
msgstr " ``editable`` "

#: ../../reference/views.rst:124
msgid "by default, selecting a list view's row opens the corresponding :ref:`form view <reference/views/form>`. The ``editable`` attributes makes the list view itself editable in-place."
msgstr "by default, selecting a list view's row opens the corresponding :ref:`form view <reference/views/form>` . The ``editable`` attributes makes the list view itself editable in-place."

#: ../../reference/views.rst:128
msgid "Valid values are ``top`` and ``bottom``, making *new* records appear respectively at the top or bottom of the list."
msgstr "有效值为 ``top`` 和 ``bottom`` , 使得 *新* 记录分别出现在列表的顶部或底部。"

#: ../../reference/views.rst:131
msgid "The architecture for the inline :ref:`form view <reference/views/form>` is derived from the list view. Most attributes valid on a :ref:`form view <reference/views/form>`'s fields and buttons are thus accepted by list views although they may not have any meaning if the list view is non-editable"
msgstr "The architecture for the inline :ref:`form view <reference/views/form>` is derived from the list view. Most attributes valid on a :ref:`form view <reference/views/form>` 's fields and buttons are thus accepted by list views although they may not have any meaning if the list view is non-editable"

#: ../../reference/views.rst:142 ../../reference/views.rst:821
msgid "``default_order``"
msgstr " ``default_order`` "

#: ../../reference/views.rst:137
msgid "overrides the ordering of the view, replacing the model's default order. The value is a comma-separated list of fields, postfixed by ``desc`` to sort in reverse order:"
msgstr "覆盖视图的顺序, 取代模型的默认顺序。该值是用逗号分隔的字段列表, 用 ``desc`` 后缀以相反的顺序进行排序:"

#: ../../reference/views.rst:145
msgid "``colors``"
msgstr " ``colors`` "

#: ../../reference/views.rst:145 ../../reference/views.rst:148
msgid "replaced by ``decoration-{$name}``"
msgstr "replaced by ``decoration-{$name}`` "

#: ../../reference/views.rst:148
msgid "``fonts``"
msgstr " ``fonts`` "

#: ../../reference/views.rst:162
msgid "``decoration-{$name}``"
msgstr " ``decoration-{$name}`` "

#: ../../reference/views.rst:151
msgid "allow changing the style of a row's text based on the corresponding record's attributes."
msgstr "允许更改行的文本的基础上, 相应的记录的属性的风格。"

#: ../../reference/views.rst:154
msgid "Values are Python expressions. For each record, the expression is evaluated with the record's attributes as context values and if ``true``, the corresponding style is applied to the row. Other context values are ``uid`` (the id of the current user) and ``current_date`` (the current date as a string of the form ``yyyy-MM-dd``)."
msgstr "价值观是Python表达式。对于每一个记录, 该表达式的值与记录的属性为背景值, 如果 ``True`` , 那么相应的样式应用到该行。其他情况下的值是 ``uid`` （当前用户的ID）和 ``current_date`` （当前日期的形式 ``YYYY-MM-dd`` 的字符串）。"

#: ../../reference/views.rst:160
msgid "``{$name}`` can be ``bf`` (``font-weight: bold``), ``it`` (``font-style: italic``), or any `bootstrap contextual color <http://getbootstrap.com/components/#available-variations>`_ (``danger``, ``info``, ``muted``, ``primary``, ``success`` or ``warning``)."
msgstr ""

#: ../../reference/views.rst:165
msgid "``create``, ``edit``, ``delete``"
msgstr " ``create`` , ``edit`` , ``delete`` "

#: ../../reference/views.rst:165
msgid "allows *dis*\\ abling the corresponding action in the view by setting the corresponding attribute to ``false``"
msgstr "允许 * DIS * \\ abling视图由相应的属性设置为'相应的动作 `false ``"

#: ../../reference/views.rst:171
msgid "``on_write``"
msgstr " ``on_write`` "

#: ../../reference/views.rst:168
msgid "only makes sense on an ``editable`` list. Should be the name of a method on the list's model. The method will be called with the ``id`` of a record after having created or edited that record (in database)."
msgstr "不仅使一个 ``editable`` 名单上的意义。应该对名单的模型方法的名称。已经创建或编辑该记录（数据库）后, 该方法将被称为一个记录的 ``id`` 。"

#: ../../reference/views.rst:172
msgid "The method should return a list of ids of other records to load or update."
msgstr "该方法应返回的其他记录ID的列表, 以装载或更新。"

#: ../../reference/views.rst:178 ../../reference/views.rst:192 ../../reference/views.rst:253 ../../reference/views.rst:1127
msgid "``string``"
msgstr " ``string`` "

#: ../../reference/views.rst:174
msgid "alternative translatable label for the view"
msgstr "另一种翻译标签视图"

#: ../../reference/views.rst:178
msgid "not displayed anymore"
msgstr "了不显示"

#: ../../reference/views.rst:182
msgid "Possible children elements of the list view are:"
msgstr "列表视图中可能的子元素有:"

#: ../../reference/views.rst:243 ../../reference/views.rst:349
msgid "``button``"
msgstr " ``button`` "

#: ../../reference/views.rst:187
msgid "displays a button in a list cell"
msgstr "列表中的单元格中显示一个按钮"

#: ../../reference/views.rst:189
msgid "``icon``"
msgstr " ``icon`` "

#: ../../reference/views.rst:190
msgid "icon to use to display the button"
msgstr "要使用的图标来显示按钮"

#: ../../reference/views.rst:192
msgid "if there is no ``icon``, the button's text"
msgstr "如果没有 ``icon`` , 按钮的文本"

#: ../../reference/views.rst:193
msgid "if there is an ``icon``, ``alt`` text for the icon"
msgstr "如果有一个 ``icon`` , ``alt`` 文本图标"

#: ../../reference/views.rst:195
msgid "type of button, indicates how it clicking it affects Odoo:"
msgstr "按钮类型, 表明它如何影响点击Odoo:"

#: ../../reference/views.rst:199
msgid "``workflow`` (default)"
msgstr " ``workflow`` （默认）"

#: ../../reference/views.rst:198
msgid "sends a signal to a workflow. The button's ``name`` is the workflow signal, the row's record is passed as argument to the signal"
msgstr "将信号发送到一个工作流程。按钮的 ``name`` 是工作流信号, 该行的记录被作为参数传递给信号"

#: ../../reference/views.rst:208 ../../reference/views.rst:1070
msgid "``object``"
msgstr " ``object`` "

#: ../../reference/views.rst:202
msgid "call a method on the list's model. The button's ``name`` is the method, which is called with the current row's record id and the current context."
msgstr "调用列表模型的方法。按钮的 ``name`` 是方法, 这就是所谓的当前行的记录ID和当前上下文。"

#: ../../reference/views.rst:211
msgid "load an execute an ``ir.actions``, the button's ``name`` is the database id of the action. The context is expanded with the list's model (as ``active_model``), the current row's record (``active_id``) and all the records currently loaded in the list (``active_ids``, may be just a subset of the database records matching the current search)"
msgstr "加载执行 ``ir.actions`` , 按钮的 ``name`` 是行动的数据库ID。上下文与列表中的模型扩展（如 ``active_model`` ）, 当前行的纪录（ ``active_id`` ）, 目前在列表中加载的所有记录（ ``active_ids`` , 可能是一个子集数据库记录相匹配的当前搜索）"

#: ../../reference/views.rst:218 ../../reference/views.rst:220
msgid "see ``type``"
msgstr "请参阅 ``type`` "

#: ../../reference/views.rst:219
msgid "``args``"
msgstr " ``args`` "

#: ../../reference/views.rst:228 ../../reference/views.rst:281 ../../reference/views.rst:311 ../../reference/views.rst:395
msgid "``attrs``"
msgstr " ``attrs`` "

#: ../../reference/views.rst:222
msgid "dynamic attributes based on record values."
msgstr "根据记录值动态属性。"

#: ../../reference/views.rst:224
msgid "A mapping of attributes to domains, domains are evaluated in the context of the current row's record, if ``True`` the corresponding attribute is set on the cell."
msgstr "属性域的映射域在当前行的记录的上下文中计算, 如果值为 ``True`` 相应的属性设置单元格。"

#: ../../reference/views.rst:228
msgid "Possible attributes are ``invisible`` (hides the button) and ``readonly`` (disables the button but still shows it)"
msgstr "可能的属性 ``invisible`` （隐藏的按钮）和 ``readonly`` （禁用按钮, 但仍显示它）"

#: ../../reference/views.rst:235
msgid "``states``"
msgstr " ``states`` "

#: ../../reference/views.rst:231
msgid "shorthand for ``invisible`` ``attrs``: a list of states, comma separated, requires that the model has a ``state`` field and that it is used in the view."
msgstr "简写 ``invisible````attrs`` :状态列表, 逗号分隔, 要求该模型有一个 ``state`` 字段, 并且它是用在图。"

#: ../../reference/views.rst:235
msgid "Makes the button ``invisible`` if the record is *not* in one of the listed states"
msgstr "使得按钮 ``invisible`` 如果记录 *没有列出的状态之一*"

#: ../../reference/views.rst:238
msgid "merged into the view's context when performing the button's Odoo call"
msgstr "执行按钮的Odoo电话时, 合并到视图的上下文"

#: ../../reference/views.rst:241
msgid "``confirm``"
msgstr " ``confirm`` "

#: ../../reference/views.rst:240
msgid "confirmation message to display (and for the user to accept) before performing the button's Odoo call"
msgstr "执行按钮的Odoo呼叫之前显示确认消息（以及用户接受）"

#: ../../reference/views.rst:246
msgid "defines a column where the corresponding field should be displayed for each record. Can use the following attributes:"
msgstr "定义了相应的字段应显示每个记录的列。可以用下面的属性:"

#: ../../reference/views.rst:250
msgid "the name of the field to display in the current model. A given name can only be used once per view"
msgstr "在当前的模型, 以显示场的名称。给定的名称只能按次使用一次"

#: ../../reference/views.rst:253
msgid "the title of the field's column (by default, uses the ``string`` of the model's field)"
msgstr "该字段的列标题（默认情况下, 使用模型的字段的 ``string`` ）"

#: ../../reference/views.rst:257
msgid "``invisible``"
msgstr " ``invisible`` "

#: ../../reference/views.rst:256
msgid "fetches and stores the field, but doesn't display the column in the table. Necessary for fields which shouldn't be displayed but are used by e.g. ``@colors``"
msgstr "取和存储该字段, 但是不显示在表中的列。必要的量不应该被显示, 但所使用的如 ``@ colors`` 字段"

#: ../../reference/views.rst:260
msgid "lists the groups which should be able to see the field"
msgstr "列出的应能看到字段的组"

#: ../../reference/views.rst:271 ../../reference/views.rst:365 ../../reference/views.rst:860 ../../reference/views.rst:1160
msgid "``widget``"
msgstr " ``widget`` "

#: ../../reference/views.rst:262
msgid "alternate representations for a field's display. Possible list view values are:"
msgstr "备用表示为字段的显示。可能的列表视图中的值有:"

#: ../../reference/views.rst:265
msgid "``progressbar``"
msgstr " ``progressbar`` "

#: ../../reference/views.rst:266
msgid "displays ``float`` fields as a progress bar."
msgstr "显示 ``float`` 进度条的字段。"

#: ../../reference/views.rst:268
msgid "``many2onebutton``"
msgstr " ``many2onebutton`` "

#: ../../reference/views.rst:268
msgid "replaces the m2o field's value by a checkmark if the field is filled, and a cross if it is not"
msgstr "替换被勾选的M2O字段的值, 如果该字段被填满, 和横, 如果它不是"

#: ../../reference/views.rst:271
msgid "``handle``"
msgstr " ``handle`` "

#: ../../reference/views.rst:271
msgid "for ``sequence`` fields, instead of displaying the field's value just displays a dra&drop icon"
msgstr "对于 ``sequence`` 字段, 而不是显示的字段的值, 只显示一个DRA和下降图标"

#: ../../reference/views.rst:276
msgid "``sum``, ``avg``"
msgstr " ``sum`` , ``avg`` "

#: ../../reference/views.rst:274
msgid "displays the corresponding aggregate at the bottom of the column. The aggregation is only computed on *currently displayed* records. The aggregation operation must match the corresponding field's ``group_operator``"
msgstr "显示在塔底部的对应的集合体。聚集仅计算在 *当前显示* 记录。聚合操作必须在相应字段的 ``group_operator`` 匹配"

#: ../../reference/views.rst:279
msgid "dynamic attributes based on record values. Only effects the current field, so e.g. ``invisible`` will hide the field but leave the same field of other records visible, it will not hide the column itself"
msgstr "根据记录值动态属性。只影响当前的字段, 所以如 ``invisible`` 将隐藏字段, 但留下的其他记录相同的字段可见, 它不会隐藏列本身"

#: ../../reference/views.rst:283
msgid "if the list view is ``editable``, any field attribute from the :ref:`form view <reference/views/form>` is also valid and will be used when setting up the inline form view"
msgstr "if the list view is ``editable`` , any field attribute from the :ref:`form view <reference/views/form>` is also valid and will be used when setting up the inline form view"

#: ../../reference/views.rst:290
msgid "Forms"
msgstr "表单"

#: ../../reference/views.rst:292
msgid "Form views are used to display the data from a single record. Their root element is ``<form>``. They are composed of regular HTML_ with additional structural and semantic components."
msgstr "表格视图用于从单个记录显示数据。他们的根元素是 ``的<form>`` 。它们与另外的结构和语义成分组成的常规HTML_。"

#: ../../reference/views.rst:297
msgid "Structural components"
msgstr "结构部件"

#: ../../reference/views.rst:299
msgid "Structural components provide structure or \"visual\" features with little logic. They are used as elements or sets of elements in form views."
msgstr "结构组件提供结构或很少有逻辑'视觉'的特点。它们被用作在形式次元素或元素组。"

#: ../../reference/views.rst:311
msgid "``notebook``"
msgstr " ``notebook`` "

#: ../../reference/views.rst:303
msgid "defines a tabbed section. Each tab is defined through a ``page`` child element. Pages can have the following attributes:"
msgstr "定义一个选项卡式部分。每个选项卡通过 ``page`` 子元素定义。网页可以具有以下属性:"

#: ../../reference/views.rst:306 ../../reference/views.rst:1175
msgid "``string`` (required)"
msgstr " ``string`` （必填）"

#: ../../reference/views.rst:307
msgid "the title of the tab"
msgstr "的选项卡的标题"

#: ../../reference/views.rst:308
msgid "``accesskey``"
msgstr " ``accesskey`` "

#: ../../reference/views.rst:309
msgid "an HTML accesskey_"
msgstr "一个HTML accesskey_"

#: ../../reference/views.rst:311
msgid "standard dynamic attributes based on record values"
msgstr "根据记录值标准的动态属性"

#: ../../reference/views.rst:326 ../../reference/views.rst:1222
msgid "``group``"
msgstr " ``group`` "

#: ../../reference/views.rst:314
msgid "used to define column layouts in forms. By default, groups define 2 columns and most direct children of groups take a single column. ``field`` direct children of groups display a label by default, and the label and the field itself have a colspan of 1 each."
msgstr "用于表单定义列布局。缺省情况下, 组定义2列和最直接的组的儿童采取单个列。 ``组field`` 直接子默认显示一个标签, 标签和字段本身具有1每一个列跨度。"

#: ../../reference/views.rst:319
msgid "The number of columns in a ``group`` can be customized using the ``col`` attribute, the number of columns taken by an element can be customized using ``colspan``."
msgstr "在一个 ``group`` 列数可以使用 ``col`` 属性定制, 采取的元件的列数可以用 ``colspan`` 定制。"

#: ../../reference/views.rst:323
msgid "Children are laid out horizontally (tries to fill the next column before changing row)."
msgstr "孩子们水平排列（试图改变行之前填写下一列）。"

#: ../../reference/views.rst:326
msgid "Groups can have a ``string`` attribute, which is displayed as the group's title"
msgstr "组可以有一个 ``string`` 属性, 该属性显示为组的标题"

#: ../../reference/views.rst:330
msgid "``newline``"
msgstr " ``newline`` "

#: ../../reference/views.rst:329
msgid "only useful within ``group`` elements, ends the current row early and immediately switches to a new row (without filling any remaining column beforehand)"
msgstr "仅在 ``group`` 元素有用, 早结束当前行并立即切换到一个新行（事先不填充任何剩余的列）"

#: ../../reference/views.rst:333 ../../reference/views.rst:1218
msgid "``separator``"
msgstr " ``separator`` "

#: ../../reference/views.rst:333
msgid "small horizontal spacing, with a ``string`` attribute behaves as a section title"
msgstr "小型水平间距, 用 ``string`` 属性表现为部分标题"

#: ../../reference/views.rst:336
msgid "``sheet``"
msgstr " ``sheet`` "

#: ../../reference/views.rst:336
msgid "can be used as a direct child to ``form`` for a narrower and more responsive form layout"
msgstr "可以作为一个直接子到 ``form`` 为较窄和更敏感形式布局"

#: ../../reference/views.rst:340
msgid "``header``"
msgstr " ``header`` "

#: ../../reference/views.rst:339
msgid "combined with ``sheet``, provides a full-width location above the sheet itself, generally used to display workflow buttons and status widgets"
msgstr "加上 ``sheet`` , 提供了一个全角位置片本身上面, 一般用来显示工作流程按钮和状态部件"

#: ../../reference/views.rst:343
msgid "Semantic components"
msgstr "语义组件"

#: ../../reference/views.rst:345
msgid "Semantic components tie into and allow interaction with the Odoo system. Available semantic components are:"
msgstr "语义成分扎入, 并允许与Odoo系统交互。可用的语义成分有:"

#: ../../reference/views.rst:349
msgid "call into the Odoo system, similar to :ref:`list view buttons <reference/views/list/button>`"
msgstr "call into the Odoo system, similar to :ref:`list view buttons <reference/views/list/button>` "

#: ../../reference/views.rst:352
msgid "renders (and allow edition of, possibly) a single field of the current record. Possible attributes are:"
msgstr "呈现（和允许的, 版本可能的）当前记录的单个场。可能的属性有:"

#: ../../reference/views.rst:356
msgid "the name of the field to render"
msgstr "呈现字段的名称"

#: ../../reference/views.rst:358
msgid "fields have a default rendering based on their type (e.g. :class:`~openerp.fields.Char`, :class:`~openerp.fields.Many2one`). The ``widget`` attributes allows using a different rendering method and context."
msgstr "域有一个默认的渲染根据自己的类型（如 :class:`~openerp.fields.Char` , :class:`~openerp.fields.Many2one` ）。该 ``widget`` 属性允许使用不同的绘制方法和背景。"

#: ../../reference/views.rst:368
msgid "``options``"
msgstr " ``options`` "

#: ../../reference/views.rst:368
msgid "JSON object specifying configuration option for the field's widget (including default widgets)"
msgstr "指定配置选项字段的小部件（包括默认挂件）JSON对象"

#: ../../reference/views.rst:383 ../../reference/views.rst:823
msgid "``class``"
msgstr " ``class`` "

#: ../../reference/views.rst:371
msgid "HTML class to set on the generated element, common field classes are:"
msgstr "HTML类生成的元素上设置, 常见的字段类是:"

#: ../../reference/views.rst:373
msgid "``oe_inline``"
msgstr " ``oe_inline`` "

#: ../../reference/views.rst:374
msgid "prevent the usual line break following fields"
msgstr "防止通常的换行符以下字段"

#: ../../reference/views.rst:375
msgid "``oe_left``, ``oe_right``"
msgstr " ``oe_left`` , ``oe_right`` "

#: ../../reference/views.rst:376
msgid "floats_ the field to the corresponding direction"
msgstr "floats_场到相应的方向"

#: ../../reference/views.rst:377
msgid "``oe_read_only``, ``oe_edit_only``"
msgstr " ``oe_read_only`` , ``oe_edit_only`` "

#: ../../reference/views.rst:378
msgid "only displays the field in the corresponding form mode"
msgstr "仅在相应的表格模式显示字段"

#: ../../reference/views.rst:380
msgid "``oe_no_button``"
msgstr " ``oe_no_button`` "

#: ../../reference/views.rst:380
msgid "avoids displaying the navigation button in a :class:`~openerp.fields.Many2one`"
msgstr "避免了在显示导航按钮 :class:`~openerp.fields.Many2one` "

#: ../../reference/views.rst:383
msgid "``oe_avatar``"
msgstr " ``oe_avatar`` "

#: ../../reference/views.rst:383
msgid "for image fields, displays images as \"avatar\" (square, 90x90 maximum size, some image decorations)"
msgstr "图像字段, 显示图像为'阿凡达'（广场, 90x90最大尺寸, 一些图像装饰）"

#: ../../reference/views.rst:386
msgid "only displays the field for specific users"
msgstr "仅显示字段为特定用户"

#: ../../reference/views.rst:393
msgid "``on_change``"
msgstr " ``on_change`` "

#: ../../reference/views.rst:388
msgid "calls the specified method when this field's value is edited, can generate update other fields or display warnings for the user"
msgstr "调用指定的方法时, 该字段的值进行编辑, 可以生成更新等字段或显示警告用户"

#: ../../reference/views.rst:393
msgid "Use :func:`openerp.api.onchange` on the model"
msgstr "使用方法 :func:`openerp.api.onchange` 型号"

#: ../../reference/views.rst:396
msgid "dynamic meta-parameters based on record values"
msgstr "根据记录值动态荟萃参数"

#: ../../reference/views.rst:398 ../../reference/views.rst:1165 ../../reference/views.rst:1178
msgid "``domain``"
msgstr " ``domain`` "

#: ../../reference/views.rst:398
msgid "for relational fields only, filters to apply when displaying existing records for selection"
msgstr "只有关系字段, 过滤器显示为选择现有记录时应用"

#: ../../reference/views.rst:401
msgid "for relational fields only, context to pass when fetching possible values"
msgstr "对于关系字段只, 背景, 以获取可能的值时, 通过"

#: ../../reference/views.rst:403
msgid "``readonly``"
msgstr " ``readonly`` "

#: ../../reference/views.rst:403
msgid "display the field in both readonly and edition mode, but never make it editable"
msgstr "显示在两个只读和出版模式的场, 但从来没有使其可编辑"

#: ../../reference/views.rst:406
msgid "``required``"
msgstr " ``required`` "

#: ../../reference/views.rst:406
msgid "generates an error and prevents saving the record if the field doesn't have a value"
msgstr "产生一个错误, 并且防止保存记录, 如果该字段不具有值"

#: ../../reference/views.rst:409
msgid "``nolabel``"
msgstr " ``nolabel`` "

#: ../../reference/views.rst:409
msgid "don't automatically display the field's label, only makes sense if the field is a direct child of a ``group`` element"
msgstr "不会自动显示字段的标签, 才有意义, 如果该字段是 ``group`` 元素的直接子"

#: ../../reference/views.rst:413
msgid "``placeholder``"
msgstr " ``placeholder`` "

#: ../../reference/views.rst:412
msgid "help message to display in *empty* fields. Can replace field labels in complex forms. *Should not* be an example of data as users are liable to confuse placeholder text with filled fields"
msgstr "帮助信息在 *空* 域显示。能在复杂的形式代替字段标签。 *不应该* 是数据的一个例子, 因为用户易于占位符文本填充字段混淆"

#: ../../reference/views.rst:416
msgid "for :class:`~openerp.fields.One2many`, display mode (view type) to use for the field's linked records. One of ``tree``, ``form``, ``kanban`` or ``graph``. The default is ``tree`` (a list display)"
msgstr "为 :class:`~openerp.fields.One2many` , 显示模式（视图类型）, 用于该字段的链接的记录。一个 ``tree`` , ``form`` , ``kanban`` 或 ``graph`` 。默认值是 ``tree`` （列表显示）"

#: ../../reference/views.rst:419 ../../reference/views.rst:1188
msgid "``help``"
msgstr " ``help`` "

#: ../../reference/views.rst:420
msgid "tooltip displayed for users when hovering the field or its label"
msgstr "徘徊中的字段或它的标签时显示提示用户"

#: ../../reference/views.rst:422
msgid "for binary fields, name of the related field providing the name of the file"
msgstr "对于二进制字段, 相关字段的名称提供该文件的名称"

#: ../../reference/views.rst:426
msgid "``password``"
msgstr " ``password`` "

#: ../../reference/views.rst:425
msgid "indicates that a :class:`~openerp.fields.Char` field stores a password and that its data shouldn't be displayed"
msgstr "指示 :class:`~openerp.fields.Char` 字段存储密码, 它的数据不应该显示"

#: ../../reference/views.rst:433
msgid "Business Views guidelines"
msgstr "业务视图指南"

#: ../../reference/views.rst:437
msgid "Business views are targeted at regular users, not advanced users.  Examples are: Opportunities, Products, Partners, Tasks, Projects, etc."
msgstr "业务视图是针对普通用户, 而不是高级用户。例子是:机遇, 产品, 合作伙伴, 任务, 项目, 等等。"

#: ../../reference/views.rst:443
msgid "In general, a business view is composed of"
msgstr "在一般情况下, 一个业务视图是由"

#: ../../reference/views.rst:445
msgid "a status bar on top (with technical or business flow),"
msgstr "在顶部的状态栏（带技术或业务流程）,"

#: ../../reference/views.rst:446
msgid "a sheet in the middle (the form itself),"
msgstr "在中间片材（形式本身）,"

#: ../../reference/views.rst:447
msgid "a bottom part with History and Comments."
msgstr "一个底部有历史和评论。"

#: ../../reference/views.rst:449
msgid "Technically, the new form views are structured as follows in XML::"
msgstr "从技术上讲, 新形式视图的结构与XML如下 ::"

#: ../../reference/views.rst:458
msgid "The Status Bar"
msgstr "状态栏"

#: ../../reference/views.rst:460
msgid "The purpose of the status bar is to show the status of the current record and the action buttons."
msgstr "状态栏的目的是为了显示当前记录的状态和操作按钮。"

#: ../../reference/views.rst:467
msgid "The Buttons"
msgstr "按钮"

#: ../../reference/views.rst:469
msgid "The order of buttons follows the business flow. For instance, in a sale order, the logical steps are:"
msgstr "按钮的顺序遵循业务流程。例如, 在出售顺序, 逻辑步骤是:"

#: ../../reference/views.rst:472
msgid "Send the quotation"
msgstr "发送报价"

#: ../../reference/views.rst:473
msgid "Confirm the quotation"
msgstr "确认报价"

#: ../../reference/views.rst:474
msgid "Create the final invoice"
msgstr "创建最终发票"

#: ../../reference/views.rst:475
msgid "Send the goods"
msgstr "发送货物"

#: ../../reference/views.rst:477
msgid "Highlighted buttons (in red by default) emphasize the logical next step, to help the user. It is usually the first active button. On the other hand, :guilabel:`cancel` buttons *must* remain grey (normal).  For instance, in Invoice the button :guilabel:`Refund` must never be red."
msgstr "突出显示的按钮（红色默认）强调合乎逻辑的下一步, 以帮助用户。它通常是在第一有源按钮。在另一方面, :guilabel:`cancel` 按钮 *必须* 保持灰色（正常）。例如, 在发票按钮 :guilabel:`Refund` 绝不是红色的。"

#: ../../reference/views.rst:482
msgid "Technically, buttons are highlighted by adding the class \"oe_highlight\"::"
msgstr "从技术上讲, 按钮是通过添加类'oe_highlight'强调 ::"

#: ../../reference/views.rst:487
msgid "The Status"
msgstr "状态"

#: ../../reference/views.rst:489
msgid "Uses the ``statusbar`` widget, and shows the current state in red. States common to all flows (for instance, a sale order begins as a quotation, then we send it, then it becomes a full sale order, and finally it is done) should be visible at all times but exceptions or states depending on particular sub-flow should only be visible when current."
msgstr "使用 ``statusbar`` 插件, 并且用红色显示当前状态。规定共同所有流（例如, 一个销售订单开始表现为报价, 那么我们将其发送, 那么它变成一个完整的销售订单, 并且最后它完成）应在所有时间, 但例外可见或状态取决于特定子-flow只应该看到, 当电流。"

#: ../../reference/views.rst:501
msgid "The states are shown following the order used in the field (the list in a selection field, etc). States that are always visible are specified with the attribute ``statusbar_visible``."
msgstr "其状态如图以下在该字段中使用的顺序（所述列表中的选择域, 等等）。这始终可见国家指定的属性 ``statusbar_visible`` 。"

#: ../../reference/views.rst:509
msgid "``statusbar_colors``"
msgstr ""

#: ../../reference/views.rst:506
msgid "can be used to give a custom color to specific states."
msgstr ""

#: ../../reference/views.rst:517
msgid "The Sheet"
msgstr "表"

#: ../../reference/views.rst:519
msgid "All business views should look like a printed sheet:"
msgstr "所有的业务视图应该看起来像一个印张:"

#: ../../reference/views.rst:524
msgid "Elements inside a ``<form>`` or ``<page>`` do not define groups, elements inside them are laid out according to normal HTML rules. They content can be explicitly grouped using ``<group>`` or regular ``<div>`` elements."
msgstr "Elements inside a ``<form>`` or ``<page>`` do not define groups, elements inside them are laid out according to normal HTML rules. They content can be explicitly grouped using ``<group>`` or regular ``<div>`` elements."

#: ../../reference/views.rst:527
msgid "By default, the element ``<group>`` defines two columns inside, unless an attribute ``col=\"n\"`` is used.  The columns have the same width (1/n th of the group's width). Use a ``<group>`` element to produce a column of fields."
msgstr "By default, the element ``<group>`` defines two columns inside, unless an attribute ``col=`` n ```` is used. The columns have the same width (1/n th of the group's width). Use a ``<group>`` element to produce a column of fields."

#: ../../reference/views.rst:530
msgid "To give a title to a section, add a ``string`` attribute to a ``<group>`` element::"
msgstr "To give a title to a section, add a ``string`` attribute to a ``<group>`` element ::"

#: ../../reference/views.rst:534
msgid "this replaces the former use of ``<separator string=\"XXX\"/>``."
msgstr "this replaces the former use of ``<separator string=`` XXX ``/>`` ."

#: ../../reference/views.rst:535
msgid "The ``<field>`` element does not produce a label, except as direct children of a ``<group>`` element\\ [#backwards-compatibility]_.  Use :samp:`<label for=\"{field_name}>` to produce a label of a field."
msgstr "The ``<field>`` element does not produce a label, except as direct children of a ``<group>`` element\\ [#backwards-compatibility]_. Use :samp:`<label for= ``{field_name}>` to produce a label of a field."

#: ../../reference/views.rst:540
msgid "Sheet Headers"
msgstr "表头"

#: ../../reference/views.rst:542
msgid "Some sheets have headers with one or more fields, and the labels of those fields are only shown in edit mode."
msgstr "一些片材具有标头被一个或多个字段, 这些字段的标签仅在编辑模式所示。"

#: ../../reference/views.rst:548 ../../reference/views.rst:654
msgid "View mode"
msgstr "浏览模式"

#: ../../reference/views.rst:549 ../../reference/views.rst:653
msgid "Edit mode"
msgstr "编辑模式"

#: ../../reference/views.rst:555
msgid "Use HTML text, ``<div>``, ``<h1>``, ``<h2>``… to produce nice headers, and ``<label>`` with the class ``oe_edit_only`` to only display the field's label in edit mode. The class ``oe_inline`` will make fields inline (instead of blocks): content following the field will be displayed on the same line rather than on the line below it. The form above is produced by the following XML::"
msgstr "Use HTML text, ``<div>`` , ``<h1>`` , ``<h2>`` … to produce nice headers, and ``<label>`` with the class ``oe_edit_only`` to only display the field's label in edit mode. The class ``oe_inline`` will make fields inline (instead of blocks) : content following the field will be displayed on the same line rather than on the line below it. The form above is produced by the following XML: :"

#: ../../reference/views.rst:572
msgid "Button Box"
msgstr "按钮"

#: ../../reference/views.rst:574
msgid "Many relevant actions or links can be displayed in the form. For example, in Opportunity form, the actions \"Schedule a Call\" and \"Schedule a Meeting\" have an important place in the use of the CRM. Instead of placing them in the \"More\" menu, put them directly in the sheet as buttons (on the top) to make them more visible and more easily accessible."
msgstr "许多相关的操作或链接可以显示在表格。例如, 在机会表单, 动作'预约来电'和'预定会议'已经在使用CRM的重要场所。相反, 将它们放置在'更多'菜单, 把它们直接在表的按钮（顶部）, 使他们更加明显和更容易获得。"

#: ../../reference/views.rst:583
msgid "Technically, the buttons are placed inside a ``<div>`` to group them as a block on the top of the sheet."
msgstr "Technically, the buttons are placed inside a ``<div>`` to group them as a block on the top of the sheet."

#: ../../reference/views.rst:594
msgid "Groups and Titles"
msgstr "分组和标题"

#: ../../reference/views.rst:596
msgid "A column of fields is now produced with a ``<group>`` element, with an optional title."
msgstr "A column of fields is now produced with a ``<group>`` element, with an optional title."

#: ../../reference/views.rst:609
msgid "It is recommended to have two columns of fields on the form. For this, simply put the ``<group>`` elements that contain the fields inside a top-level ``<group>`` element."
msgstr "It is recommended to have two columns of fields on the form. For this, simply put the ``<group>`` elements that contain the fields inside a top-level ``<group>`` element."

#: ../../reference/views.rst:613
msgid "To make :ref:`view extension <reference/views/inheritance>` simpler, it is recommended to put a ``name`` attribute on ``<group>`` elements, so new fields can easily be added at the right place."
msgstr "To make :ref:`view extension <reference/views/inheritance>` simpler, it is recommended to put a ``name`` attribute on ``<group>`` elements, so new fields can easily be added at the right place."

#: ../../reference/views.rst:618
msgid "Special Case: Subtotals"
msgstr "特例:分类汇总"

#: ../../reference/views.rst:620
msgid "Some classes are defined to render subtotals like in invoice forms:"
msgstr "有些类的定义来呈现小计像发票的形式:"

#: ../../reference/views.rst:635
msgid "Placeholders and Inline Fields"
msgstr "Placeholders and Inline Fields"

#: ../../reference/views.rst:637
msgid "Sometimes field labels make the form too complex. One can omit field labels, and instead put a placeholder inside the field. The placeholder text is visible only when the field is empty. The placeholder should tell what to place inside the field, it *must not* be an example as they are often confused with filled data."
msgstr "有时候字段标签使形式过于复杂。人们可以省略字段标签, 而是把一个占位符字段内。占位符文本是可见的, 只有当该字段为空。占位符应该告诉放入字段里面有什么, 它 *不能* 是一个例子, 因为他们经常被混淆与填充数据。"

#: ../../reference/views.rst:643
msgid "One can also group fields together by rendering them \"inline\" inside an explicit block element like ``<div>``. This allows grouping semantically related fields as if they were a single (composite) fields."
msgstr "One can also group fields together by rendering them ``inline`` inside an explicit block element like ``<div>`` . This allows grouping semantically related fields as if they were a single (composite) fields."

#: ../../reference/views.rst:647
msgid "The following example, taken from the *Leads* form, shows both placeholders and inline fields (zip and city)."
msgstr "下面的例子, 从 *拍摄信息* 的形式, 同时显示占位符和内联字段（邮编及城市）。"

#: ../../reference/views.rst:677
msgid "Images"
msgstr "图片"

#: ../../reference/views.rst:679
msgid "Images, like avatars, should be displayed on the right of the sheet.  The product form looks like:"
msgstr "图像, 像替身, 应显示在片材的右侧。产品形式如下:"

#: ../../reference/views.rst:685
msgid "The form above contains a <sheet> element that starts with:"
msgstr "The form above contains a <sheet> element that starts with :"

#: ../../reference/views.rst:692
msgid "Tags"
msgstr "标签"

#: ../../reference/views.rst:694
msgid "Most :class:`~openerp.fields.Many2many` fields, like categories, are better rendered as a list of tags. Use the widget ``many2many_tags`` for this:"
msgstr "大多数 :class:`~openerp.fields.Many2many` 字段里, 如类别, 更好地呈现为标签列表。使用Widget ``many2many_tags`` 此:"

#: ../../reference/views.rst:705
msgid "Configuration forms guidelines"
msgstr "配置表单指南"

#: ../../reference/views.rst:707
msgid "Examples of configuration forms: Stages, Leave Type, etc.  This concerns all menu items under Configuration of each application (like Sales/Configuration)."
msgstr "阶段, 休假类型, 等等。这涉及到每个应用程序的配置下的所有菜单项（如销售/配置）:配置形式的实例。"

#: ../../reference/views.rst:713
msgid "no header (because no state, no workflow, no button)"
msgstr "没有头（因为没有一个国家, 没有工作流, 无按钮）"

#: ../../reference/views.rst:714 ../../reference/views.rst:739
msgid "no sheet"
msgstr "无表格"

#: ../../reference/views.rst:717
msgid "Dialog forms guidelines"
msgstr "对话表单指南"

#: ../../reference/views.rst:719
msgid "Example: \"Schedule a Call\" from an opportunity."
msgstr "例如:'预约来电'的一个机会。"

#: ../../reference/views.rst:724
msgid "avoid separators (the title is already in the popup title bar, so another separator is not relevant)"
msgstr "避免分隔符（标题已经在弹出的标题栏, 所以另外一个分隔符是不相关的）"

#: ../../reference/views.rst:726
msgid "avoid cancel buttons (user generally close the popup window to get the same effect)"
msgstr "避免取消按钮（用户一般关闭弹出窗口来获得同样的效果）"

#: ../../reference/views.rst:728
msgid "action buttons must be highlighted (red)"
msgstr "动作按钮必须高亮 (红色)"

#: ../../reference/views.rst:729
msgid "when there is a text area, use a placeholder instead of a label or a separator"
msgstr "当有一个文本区域, 而不是使用一个标签或一个分离器的占位符"

#: ../../reference/views.rst:731
msgid "like in regular form views, put buttons in the <header> element"
msgstr "就像在普通形式的意见, 把按钮在<header>元素"

#: ../../reference/views.rst:734
msgid "Configuration Wizards guidelines"
msgstr "配置向导指南"

#: ../../reference/views.rst:736
msgid "Example: Settings / Configuration / Sales."
msgstr "例如:设置/配置/销售。"

#: ../../reference/views.rst:738
msgid "always in line (no popup)"
msgstr "总是在线的（不弹出）"

#: ../../reference/views.rst:740
msgid "keep the cancel button (users cannot close the window)"
msgstr "保持取消按钮（用户不能关闭窗口）"

#: ../../reference/views.rst:741
msgid "the button \"Apply\" must be red"
msgstr "按钮'应用'必须是红色的"

#: ../../reference/views.rst:747
msgid "Graphs"
msgstr "图形"

#: ../../reference/views.rst:749
msgid "The graph view is used to visualize aggregations over a number of records or record groups. Its root element is ``<graph>`` which can take the following attributes:"
msgstr "The graph view is used to visualize aggregations over a number of records or record groups. Its root element is ``<graph>`` which can take the following attributes :"

#: ../../reference/views.rst:754
msgid "one of ``bar`` (default), ``pie`` and ``line``, the type of graph to use"
msgstr "的 ``bar`` （默认）, ``pie`` 和 `是` line ``, 用图表的类型"

#: ../../reference/views.rst:757
msgid "``stacked``"
msgstr " ``stacked`` "

#: ../../reference/views.rst:756
msgid "only used for ``bar`` charts. If present and set to ``True``, stacks bars within a group"
msgstr "仅用于 ``bar`` 图表。如果存在并设置为 ``True`` , 那么堆叠组内的酒吧"

#: ../../reference/views.rst:759
msgid "The only allowed element within a graph view is ``field`` which can have the following attributes:"
msgstr "的曲线图视图中的只允许元件是 ``field`` 其可以具有以下属性:"

#: ../../reference/views.rst:764 ../../reference/views.rst:840
msgid "``name`` (required)"
msgstr " ``name`` （必填）"

#: ../../reference/views.rst:763
msgid "the name of a field to use in a graph view. If used for grouping (rather than aggregating)"
msgstr "在图中, 以使用一个字段的名称。如果用于分组（而不是聚集）"

#: ../../reference/views.rst:767
msgid "indicates whether the field should be used as a grouping criteria or as an aggregated value within a group. Possible values are:"
msgstr "指示字段是否应该使用作为分组标准或作为组内的聚合值。可能的值有:"

#: ../../reference/views.rst:772
msgid "``row`` (default)"
msgstr " ``row`` （默认）"

#: ../../reference/views.rst:771
msgid "groups by the specified field. All graph types support at least one level of grouping, some may support more. For pivot views, each group gets its own row."
msgstr "组按指定字段。所有图表类型支持分组中的至少一个级别, 一些可以支持更多。对于支点的意见, 每个小组都有自己的行。"

#: ../../reference/views.rst:774
msgid "``col``"
msgstr " ``col`` "

#: ../../reference/views.rst:775
msgid "only used by pivot tables, creates column-wise groups"
msgstr "仅用于数据透视表, 创建逐列组"

#: ../../reference/views.rst:777
msgid "``measure``"
msgstr " ``measure`` "

#: ../../reference/views.rst:777
msgid "field to aggregate within a group"
msgstr "汇总到一起的字段"

#: ../../reference/views.rst:782
msgid "``interval``"
msgstr " ``interval`` "

#: ../../reference/views.rst:780
msgid "on date and datetime fields, groups by the specified interval (``day``, ``week``, ``month``, ``quarter`` or ``year``) instead of grouping on the specific datetime (fixed second resolution) or date (fixed day resolution)."
msgstr "日期和日期时间字段, 组按指定的时间间隔（ ``day`` , ``week`` , ``month`` , ``quarter`` 或 ``year`` ）, 而不是具体的日期时间分组（固定的第二项决议案）或日期（固定一天分辨率）。"

#: ../../reference/views.rst:786
msgid "graph view aggregations are performed on database content, non-stored function fields can not be used in graph views"
msgstr "图形视图聚合是在数据库中的内容执行, 非存储功能字段不能在图形视图中使用"

#: ../../reference/views.rst:790
msgid "Pivots"
msgstr "支点"

#: ../../reference/views.rst:792
msgid "The pivot view is used to visualize aggregations as a `pivot table`_. Its root element is ``<pivot>`` which can take the following attributes:"
msgstr "The pivot view is used to visualize aggregations as a `pivot table` _. Its root element is ``<pivot>`` which can take the following attributes :"

#: ../../reference/views.rst:795
msgid "``disable_linking``"
msgstr " ``disable_linking`` "

#: ../../reference/views.rst:796
msgid "Set to ``True`` to remove table cell's links to list view."
msgstr "设置为值为 ``True`` 删除表格单元格的链接列表视图。"

#: ../../reference/views.rst:798
msgid "``display_quantity``"
msgstr " ``display_quantity`` "

#: ../../reference/views.rst:798
msgid "Set to ``true`` to display the Quantity column by default."
msgstr "设置为值为 ``True`` 默认显示数量列。"

#: ../../reference/views.rst:800
msgid "The elements allowed within a pivot view are the same as for the graph view."
msgstr "一个枢轴视图内所允许的元件是一样的图形视图。"

#: ../../reference/views.rst:805
msgid "Kanban"
msgstr "看板"

#: ../../reference/views.rst:807
msgid "The kanban view is a `kanban board`_ visualisation: it displays records as \"cards\", halfway between a :ref:`list view <reference/views/list>` and a non-editable :ref:`form view <reference/views/form>`. Records may be grouped in columns for use in workflow visualisation or manipulation (e.g. tasks or work-progress management), or ungrouped (used simply to visualize records)."
msgstr "The kanban view is a `kanban board` _ visualisation : it displays records as ``cards`` , halfway between a : ref :`list view <reference/views/list>` and a non-editable : ref :`form view <reference/views/form>` . Records may be grouped in columns for use in workflow visualisation or manipulation (e.g. tasks or work-progress management), or ungrouped (used simply to visualize records)."

#: ../../reference/views.rst:813
msgid "The root element of the Kanban view is ``<kanban>``, it can use the following attributes:"
msgstr "The root element of the Kanban view is ``<kanban>`` , it can use the following attributes :"

#: ../../reference/views.rst:818 ../../reference/views.rst:1025
msgid "``default_group_by``"
msgstr " ``default_group_by`` "

#: ../../reference/views.rst:817
msgid "whether the kanban view should be grouped if no grouping is specified via the action or the current research. Should be the name of the field to group by when no grouping is otherwise specified"
msgstr "无论是如果通过动作或目前的研究中没有指定分组看板认为应该进行分组。应该是场组时另有规定不分组的名称"

#: ../../reference/views.rst:821
msgid "cards sorting order used if the user has not already sorted the records (via the list view)"
msgstr "卡排序顺序使用, 如果用户没有已经排序的记录（经由列表视图）"

#: ../../reference/views.rst:824
msgid "adds HTML classes to the root HTML element of the Kanban view"
msgstr "添加HTML类看板视图的根HTML元素"

#: ../../reference/views.rst:830
msgid "``quick_create``"
msgstr " ``quick_create`` "

#: ../../reference/views.rst:826
msgid "whether it should be possible to create records without switching to the form view. By default, ``quick_create`` is enabled when the Kanban view is grouped, and disabled when not."
msgstr "是否应该是可能的创建记录, 而不转换到形式图。默认情况下, ``quick_create`` 时启用看板视图分组, 并禁用时不会。"

#: ../../reference/views.rst:830
msgid "Set to ``true`` to always enable it, and to ``false`` to always disable it."
msgstr "设置为值为 ``True`` 总是启用它, 并且 ``false`` 总是禁用它。"

#: ../../reference/views.rst:832
msgid "Possible children of the view element are:"
msgstr "视图元素的可能孩子是:"

#: ../../reference/views.rst:835
msgid "declares fields to aggregate or to use in kanban *logic*. If the field is simply displayed in the kanban view, it does not need to be pre-declared."
msgstr "声明了字段或聚集在看板 *逻辑使用* 。如果该字段被简单地显示在看板视图, 它并不需要被预先声明。"

#: ../../reference/views.rst:838
msgid "Possible attributes are:"
msgstr "可能的属性有 :"

#: ../../reference/views.rst:841
msgid "the name of the field to fetch"
msgstr "抓取的字段的名称"

#: ../../reference/views.rst:845
msgid "``sum``, ``avg``, ``min``, ``max``, ``count``"
msgstr " ``sum`` , ``avg`` , ``min`` , ``max`` , ``count`` "

#: ../../reference/views.rst:843
msgid "displays the corresponding aggregation at the top of a kanban column, the field's value is the label of the aggregation (a string). Only one aggregate operation per field is supported."
msgstr "显示在看板塔顶部的相应聚合, 该字段的值是聚合（字符串）的标签。支持每场只有一个总的操作。"

#: ../../reference/views.rst:902
msgid "``templates``"
msgstr " ``templates`` "

#: ../../reference/views.rst:848
msgid "defines a list of :ref:`reference/qweb` templates. Cards definition may be split into multiple templates for clarity, but kanban views *must* define at least one root template ``kanban-box``, which will be rendered once for each record."
msgstr "定义列表 :ref:`参考/ qweb` 模板。卡定义可以被分成多个模板清晰, 但看板意见 *必须* 至少定义一个根模板 ``看板box`` , 这将是为每个记录呈现的一次。"

#: ../../reference/views.rst:853
msgid "The kanban view uses mostly-standard :ref:`javascript qweb <reference/qweb/javascript>` and provides the following context variables:"
msgstr "The kanban view uses mostly-standard :ref:`javascript qweb <reference/qweb/javascript>` and provides the following context variables :"

#: ../../reference/views.rst:856
msgid "``instance``"
msgstr " ``instance`` "

#: ../../reference/views.rst:857
msgid "the current :ref:`reference/javascript/client` instance"
msgstr "当前 :ref:`reference/javascript/client` 实例"

#: ../../reference/views.rst:859
msgid "the current :js:class:`KanbanRecord`, can be used to fetch some meta-information. These methods are also available directly in the template context and don't need to be accessed via ``widget``"
msgstr "当前 :js: class :`KanbanRecord` , 可以用来获取一些元信息。这些方法也可以直接在模板上下文中可用​​并且不需要经由 ``widget`` 访问"

#: ../../reference/views.rst:863
msgid "an object with all the requested fields as its attributes. Each field has two attributes ``value`` and ``raw_value``, the former is formatted according to current user parameters, the latter is the direct value from a :meth:`~openerp.models.Model.read` (except for date and datetime fields that are `formatted according to user's locale <https://github.com/odoo/odoo/blob/a678bd4e/addons/web_kanban/static/src/js/kanban_record.js#L102>`_)"
msgstr ""

#: ../../reference/views.rst:869
msgid "``formats``"
msgstr ""

#: ../../reference/views.rst:870
msgid "the :js:class:`web.formats` module to manipulate and convert values"
msgstr ""

#: ../../reference/views.rst:902
msgid "``read_only_mode``"
msgstr " ``read_only_mode`` "

#: ../../reference/views.rst:872
msgid "self-explanatory"
msgstr "不言自明"

#: ../../reference/views.rst:0
msgid "buttons and fields"
msgstr "按钮和字段"

#: ../../reference/views.rst:877
msgid "While most of the Kanban templates are standard :ref:`reference/qweb`, the Kanban view processes ``field``, ``button`` and ``a`` elements specially:"
msgstr "虽然大多数的看板模板标准 :ref:`参考/ qweb` , 看板查看进程 ``field`` , ``button`` 和 ``a`` 元素特别:"

#: ../../reference/views.rst:880
msgid "by default fields are replaced by their formatted value, unless they match specific kanban view widgets"
msgstr "默认域由他们格式化的值被替换, 除非它们与特定的看板视图控件"

#: ../../reference/views.rst:885
msgid "buttons and links with a ``type`` attribute become perform Odoo-related operations rather than their standard HTML function. Possible types are:"
msgstr "按钮和一个 ``type`` 属性将成为执行Odoo相关的操作, 而不是他们的标准的HTML功能。可能的类型是:"

#: ../../reference/views.rst:890
msgid "``action``, ``object``"
msgstr " ``action`` , ``object`` "

#: ../../reference/views.rst:889
msgid "standard behavior for :ref:`Odoo buttons <reference/views/list/button>`, most attributes relevant to standard Odoo buttons can be used."
msgstr "standard behavior for :ref:`Odoo buttons <reference/views/list/button>` , most attributes relevant to standard Odoo buttons can be used."

#: ../../reference/views.rst:892
msgid "``open``"
msgstr " ``open`` "

#: ../../reference/views.rst:893
msgid "opens the card's record in the form view in read-only mode"
msgstr "打开表单视图卡的记录在只读模式"

#: ../../reference/views.rst:894
msgid "``edit``"
msgstr " ``edit`` "

#: ../../reference/views.rst:895
msgid "opens the card's record in the form view in editable mode"
msgstr "开证的记录在编辑模式下的表单视图"

#: ../../reference/views.rst:897
msgid "deletes the card's record and removes the card"
msgstr "删除存储卡的记录, 并取出卡"

#: ../../reference/views.rst:905
msgid "Javascript API"
msgstr "Javascript API"

#: ../../reference/views.rst:909
msgid ":js:class:`Widget` handling the rendering of a single record to a card. Available within its own rendering as ``widget`` in the template context."
msgstr ":js: class :`Widget` 处理一条记录到记忆卡中的呈现。可在自己的渲染为 ``widget`` 在模板环境。"

#: ../../reference/views.rst:915
msgid "Converts a color segmentation value to a kanban color class :samp:`oe_kanban_color_{color_index}`. The built-in CSS provides classes up to a ``color_index`` of 9."
msgstr ":samp:`oe_kanban_color_ {color_index}` 颜色分割值看板颜色类转换。内置的CSS提供类高达9 ``color_index`` 。"

#: ../../reference/views.rst:921
msgid "Converts a color segmentation value to a color index (between 0 and 9 by default). Color segmentation values can be either numbers or strings."
msgstr "一个颜色值分割为颜色索引（0到9之间默认情况下）转换。颜色分割值可以是数字或字符串。"

#: ../../reference/views.rst:926
msgid "Generates the URL to the specified field as an image access."
msgstr "生成的URL指定的字段作为图像接入。"

#: ../../reference/views.rst:928
msgid "model hosting the image"
msgstr "模型托管图像"

#: ../../reference/views.rst:929
msgid "name of the field holding the image data"
msgstr "场的保持的图像数据名"

#: ../../reference/views.rst:930
msgid "identifier of the record contaning the image to display"
msgstr "记录的标识符contaning要显示的图像"

#: ../../reference/views.rst:931
msgid "caching duration (in seconds) of the browser default should be overridden. ``0`` disables caching entirely"
msgstr "浏览器默认的缓存时间（单位:秒）应该重写。 ``0`` 禁用完全缓存"

#: ../../reference/views.rst:934
msgid "an image URL"
msgstr "图片网址"

#: ../../reference/views.rst:938
msgid "clips text beyond the specified size and appends an ellipsis to it. Can be used to display the initial part of potentially very long fields (e.g. descriptions) without the risk of unwieldy cards"
msgstr "剪辑文本超出指定的大小和一个省略号追加到它。可以不使用的笨重卡的危险, 以显示可能非常长字段（例如描述）的初始部分"

#: ../../reference/views.rst:945
msgid "Calendar"
msgstr "日历"

#: ../../reference/views.rst:947
msgid "Calendar views display records as events in a daily, weekly or monthly calendar. Their root element is ``<calendar>``. Available attributes on the calendar view are:"
msgstr "Calendar views display records as events in a daily, weekly or monthly calendar. Their root element is ``<calendar>`` . Available attributes on the calendar view are :"

#: ../../reference/views.rst:951 ../../reference/views.rst:1011
msgid "``date_start`` (required)"
msgstr " ``date_start`` （必填）"

#: ../../reference/views.rst:952
msgid "name of the record's field holding the start date for the event"
msgstr "记录的字段持有的开始日期的事件名称"

#: ../../reference/views.rst:955 ../../reference/views.rst:1018
msgid "``date_stop``"
msgstr " ``date_stop`` "

#: ../../reference/views.rst:954
msgid "name of the record's field holding the end date for the event, if ``date_stop`` is provided records become movable (via drag and drop) directly in the calendar"
msgstr "该记录的字段持有的结束日期的情况下, 如果 ``提供date_stop`` 记录成为移动（通过拖放）的名字直接在日历"

#: ../../reference/views.rst:961 ../../reference/views.rst:1020
msgid "``date_delay``"
msgstr " ``date_delay`` "

#: ../../reference/views.rst:958
msgid "alternative to ``date_stop``, provides the duration of the event instead of its end date"
msgstr ""

#: ../../reference/views.rst:965
msgid "``color``"
msgstr " ``color`` "

#: ../../reference/views.rst:964
msgid "name of a record field to use for *color segmentation*. Records in the same color segment are allocated the same highlight color in the calendar, colors are allocated semi-randomly."
msgstr "用于 *色彩分割记录字段的名称* 。在相同颜色段记录被分配在日历相同的高亮颜色, 颜色被分配半随机。"

#: ../../reference/views.rst:968
msgid "``event_open_popup``"
msgstr " ``event_open_popup`` "

#: ../../reference/views.rst:968
msgid "opens the event in a dialog instead of switching to the form view, disabled by default"
msgstr ""

#: ../../reference/views.rst:972
msgid "``quick_add``"
msgstr " ``quick_add`` "

#: ../../reference/views.rst:971
msgid "enables quick-event creation on click: only asks the user for a ``name`` and tries to create a new event with just that and the clicked event time. Falls back to a full form dialog if the quick creation fails"
msgstr "使上点击快速事件创建:只要求用户输入一个 ``name`` , 并尝试与只是和点击事件时间创建一个新的事件。回落到一个完整的表格对话框, 如果快速创建失败"

#: ../../reference/views.rst:975
msgid "``display``"
msgstr " ``display`` "

#: ../../reference/views.rst:975
msgid "format string for event display, field names should be within brackets ``[`` and ``]``"
msgstr "格式字符串的事件显示, 字段名应该是括号内 ``[`` 和 ``]`` "

#: ../../reference/views.rst:978
msgid "``all_day``"
msgstr " ``all_day`` "

#: ../../reference/views.rst:978
msgid "name of a boolean field on the record indicating whether the corresponding event is flagged as day-long (and duration is irrelevant)"
msgstr "在记录一个布尔字段, 表示相应的事件是否被标记为一天的名称（和持续时间无关）"

#: ../../reference/views.rst:981
msgid "Default display mode when loading the calendar. Possible attributes are: ``day``, ``week``, ``month``"
msgstr ""

#: ../../reference/views.rst:1003
msgid "Gantt"
msgstr "甘特"

#: ../../reference/views.rst:1005
msgid "Gantt views appropriately display Gantt charts (for scheduling)."
msgstr "甘特的看法正确显示甘特图（调度）。"

#: ../../reference/views.rst:1007
msgid "The root element of gantt views is ``<gantt/>``, it has no children but can take the following attributes:"
msgstr "The root element of gantt views is ``<gantt/>`` , it has no children but can take the following attributes :"

#: ../../reference/views.rst:1011
msgid "name of the field providing the start datetime of the event for each record."
msgstr "现场提供事件的每个记录的开始日期时间命名。"

#: ../../reference/views.rst:1014
msgid "name of the field providing the end duration of the event for each record. Can be replaced by ``date_delay``. One (and only one) of ``date_stop`` and ``date_delay`` must be provided."
msgstr "字段提供该事件的每个记录的末尾持续时间命名。可以通过 ``date_delay`` 所取代。一个 ``date_stop`` 和 ``date_delay`` 必须提供（也是唯一一个）。"

#: ../../reference/views.rst:1018
msgid "If the field is ``False`` for a record, it's assumed to be a \"point event\" and the end date will be set to the start date"
msgstr "如果该字段为 ``False`` 的记录, 它认为是一个'点事件'和结束日期将被设置为起始日期"

#: ../../reference/views.rst:1021
msgid "name of the field providing the duration of the event"
msgstr "字段提供所述事件的持续时间的命名"

#: ../../reference/views.rst:1023
msgid "``duration_unit``"
msgstr ""

#: ../../reference/views.rst:1023
msgid "one of ``minute``, ``hour`` (default), ``day``, ``week``, ``month``, ``year``"
msgstr ""

#: ../../reference/views.rst:1026
msgid "name of a field to group tasks by"
msgstr "通过向组任务的场的命名"

#: ../../reference/views.rst:1028
msgid "``gantt`` classic gantt view (default)"
msgstr ""

#: ../../reference/views.rst:1030
msgid "``consolidate`` values of the first children are consolidated in the gantt's task"
msgstr ""

#: ../../reference/views.rst:1032
msgid "``planning`` children are displayed in the gantt's task"
msgstr ""

#: ../../reference/views.rst:1033
msgid "``consolidation``"
msgstr ""

#: ../../reference/views.rst:1034
msgid "field name to display consolidation value in record cell"
msgstr ""

#: ../../reference/views.rst:1041
msgid "``consolidation_max``"
msgstr ""

#: ../../reference/views.rst:1036
msgid "dictionary with the \"group by\" field as key and the maximum consolidation value that can be reached before displaying the cell in red (e.g. ``{\"user_id\": 100}``)"
msgstr ""

#: ../../reference/views.rst:1041
msgid "The dictionnary definition must use double-quotes, ``{'user_id': 100}`` is not a valid value"
msgstr ""

#: ../../reference/views.rst:1044
msgid "``consolidation_label``"
msgstr ""

#: ../../reference/views.rst:1044
msgid "string to display next to the consolidation value, if not specified, the label of the consolidation field will be used"
msgstr ""

#: ../../reference/views.rst:1046
msgid "``fold_last_level``"
msgstr ""

#: ../../reference/views.rst:1047
msgid "If a value is set, the last grouping level is folded"
msgstr ""

#: ../../reference/views.rst:1049
msgid "``round_dnd_dates``"
msgstr ""

#: ../../reference/views.rst:1049
msgid "enables rounding the task's start and end dates to the nearest scale marks"
msgstr ""

#: ../../reference/views.rst:1060
msgid "Diagram"
msgstr "图解"

#: ../../reference/views.rst:1062
msgid "The diagram view can be used to display directed graphs of records. The root element is ``<diagram>`` and takes no attributes."
msgstr "The diagram view can be used to display directed graphs of records. The root element is ``<diagram>`` and takes no attributes."

#: ../../reference/views.rst:1065
msgid "Possible children of the diagram view are:"
msgstr "图表视图的可能孩子是:"

#: ../../reference/views.rst:1078
msgid "``node`` (required, 1)"
msgstr " ``node`` （需要1）"

#: ../../reference/views.rst:1068
msgid "Defines the nodes of the graph. Its attributes are:"
msgstr "定义了图的节点。其特征是:"

#: ../../reference/views.rst:1071
msgid "the node's Odoo model"
msgstr "节点的Odoo模型"

#: ../../reference/views.rst:1074
msgid "``shape``"
msgstr " ``shape`` "

#: ../../reference/views.rst:1073
msgid "conditional shape mapping similar to colors and fonts in :ref:`the list view <reference/views/list>`. The only valid shape is ``rectangle`` (the default shape is an ellipsis)"
msgstr "conditional shape mapping similar to colors and fonts in :ref:`the list view <reference/views/list>` . The only valid shape is ``rectangle`` (the default shape is an ellipsis)"

#: ../../reference/views.rst:1078
msgid "``bgcolor``"
msgstr " ``bgcolor`` "

#: ../../reference/views.rst:1077
msgid "same as ``shape``, but conditionally maps a background color for nodes. The default background color is white, the only valid alternative is ``grey``."
msgstr "一样 ``shape`` , 但有条件映射的背景色节点。默认的背景色为白色, 唯一有效的办法是 ``grey`` 。"

#: ../../reference/views.rst:1094
msgid "``arrow`` (required, 1)"
msgstr " ``arrow`` （需要1）"

#: ../../reference/views.rst:1081
msgid "Defines the directed edges of the graph. Its attributes are:"
msgstr "定义了图的有向边。其特征是:"

#: ../../reference/views.rst:1083
msgid "``object`` (required)"
msgstr " ``object`` （必填）"

#: ../../reference/views.rst:1084
msgid "the edge's Odoo model"
msgstr "边缘的Odoo模型"

#: ../../reference/views.rst:1086
msgid "``source`` (required)"
msgstr " ``source`` （必填）"

#: ../../reference/views.rst:1086
msgid ":class:`~openerp.fields.Many2one` field of the edge's model pointing to the edge's source node record"
msgstr ":class:`~openerp.fields.Many2one` 场边缘的模型指向的边缘的源节点纪录"

#: ../../reference/views.rst:1089
msgid "``destination`` (required)"
msgstr " ``destination`` （必填）"

#: ../../reference/views.rst:1089
msgid ":class:`~openerp.fields.Many2one` field of the edge's model pointing to the edge's destination node record"
msgstr ":class:`~openerp.fields.Many2one` 场边缘的模型指向的边缘的目的节点记录"

#: ../../reference/views.rst:1094 ../../reference/views.rst:1099
msgid "``label``"
msgstr " ``label`` "

#: ../../reference/views.rst:1092
msgid "Python list of attributes (as quoted strings). The corresponding attributes's values will be concatenated and displayed as the edge's label"
msgstr "属性Python列表（引字符串）。相应属性的值将被连接起来并显示为边的标签"

#: ../../reference/views.rst:1097
msgid "Explanatory note for the diagram, the ``string`` attribute defines the note's content. Each ``label`` is output as a paragraph in the diagram header, easily visible but without any special emphasis."
msgstr "解释性说明的图中, ``string`` 属性定义了注释的内容。每个 ``label`` 是如在图报头, 很容易看到, 但没有任何特别强调一个段落的输出。"

#: ../../reference/views.rst:1104
msgid "Search"
msgstr "搜索"

#: ../../reference/views.rst:1106
msgid "Search views are a break from previous view types in that they don't display *content*: although they apply to a specific model, they are used to filter other view's content (generally aggregated views e.g. :ref:`reference/views/list` or :ref:`reference/views/graph`). Beyond that difference in use case, they are defined the same way."
msgstr "搜索视图是从以前的视图类型, 因为它们不显示 *量* 休息:虽然它们适用于一个特定的模式, 它们是用来过滤其他视图的内容（一般汇总的意见, 例如 :ref:`参考/视图/名单` 或 :ref:`参考/视图/ graph` ）。以外使用的情况下的差异, 它们被定义的方式相同。"

#: ../../reference/views.rst:1112
msgid "The root element of search views is ``<search>``. It takes no attributes."
msgstr "The root element of search views is ``<search>`` . It takes no attributes."

#: ../../reference/views.rst:1116
msgid "Possible children elements of the search view are:"
msgstr "搜索视图中可能的子元素有:"

#: ../../reference/views.rst:1119
msgid "fields define domains or contexts with user-provided values. When search domains are generated, field domains are composed with one another and with filters using **AND**."
msgstr "字段定义域或语境与用户提供的值。当生成搜索域, 场域由具有彼此之间以及与使用的过滤器 **** 与。"

#: ../../reference/views.rst:1123
msgid "Fields can have the following attributes:"
msgstr "字段可以具有以下属性:"

#: ../../reference/views.rst:1126
msgid "the name of the field to filter on"
msgstr "字段的名称过滤上"

#: ../../reference/views.rst:1128
msgid "the field's label"
msgstr "该字段的标签"

#: ../../reference/views.rst:1137
msgid "``operator``"
msgstr " ``operator`` "

#: ../../reference/views.rst:1130
msgid "by default, fields generate domains of the form :samp:`[({name}, {operator}, {provided_value})]` where ``name`` is the field's name and ``provided_value`` is the value provided by the user, possibly filtered or transformed (e.g. a user is expected to provide the *label* of a selection field's value, not the value itself)."
msgstr "默认情况下, 场生成表单域 :samp:`[（{名}, {运营商}, {provided_value}）]` , 其中 ``name`` 是字段的名称和 ``provided_value`` 是所提供的价值用户, 可能是过滤或转化（例如, 一个用户被预期提供的选择字段的值, 而不是值本身的 *标记* ）。"

#: ../../reference/views.rst:1136
msgid "The ``operator`` attribute allows overriding the default operator, which depends on the field's type (e.g. ``=`` for float fields but ``ilike`` for char fields)"
msgstr "该 ``operator`` 属性允许覆盖默认的运营商, 这取决于字段的类型（如 ``=`` 浮法字段, 但 ``ilike`` 对于char字段）"

#: ../../reference/views.rst:1145
msgid "``filter_domain``"
msgstr " ``filter_domain`` "

#: ../../reference/views.rst:1140
msgid "complete domain to use as the field's search domain, can use a ``self`` variable to inject the provided value in the custom domain. Can be used to generate significantly more flexible domains than ``operator`` alone (e.g. searches on multiple fields at once)"
msgstr "完整的域名作为字段的搜索域名使用, 可以使用 ``self`` 变量注入的自定义域提供的值。可以使用（同时对多个字段, 例如搜索）产生显著更灵活的域比 ``独自operator`` "

#: ../../reference/views.rst:1145
msgid "If both ``operator`` and ``filter_domain`` are provided, ``filter_domain`` takes precedence."
msgstr "如果两个 ``operator`` 和 ``filter_domain`` 提供, ``filter_domain`` 优先。"

#: ../../reference/views.rst:1148
msgid "allows adding context keys, including the user-provided value (which as for ``domain`` is available as a ``self`` variable). By default, fields don't generate domains."
msgstr "允许添加背景下键, 包括用户提供的值（作为 ``domain`` 可作为一个 ``self`` 变量）。默认情况下, 田地不产生域。"

#: ../../reference/views.rst:1152
msgid "the domain and context are inclusive and both are generated if if a ``context`` is specified. To only generate context values, set ``filter_domain`` to an empty list: ``filter_domain=\"[]\"``"
msgstr "域和上下文的包容性, 如果指定了 ``context`` 既产生。只生成背景值, 设置 ``filter_domain`` 到一个空表:``filter_domain ='[]'`` "

#: ../../reference/views.rst:1157
msgid "make the field only available to specific users"
msgstr "使现场只提供给特定用户"

#: ../../reference/views.rst:1159
msgid "use specific search widget for the field (the only use case in standard Odoo 8.0 is a ``selection`` widget for :class:`~openerp.fields.Many2one` fields)"
msgstr "使用特定的搜索挂件字段（唯一的用例的标准Odoo 8.0是一个 ``selection`` 小部件 :class:`~openerp.fields.Many2one` 字段）"

#: ../../reference/views.rst:1163
msgid "if the field can provide an auto-completion (e.g. :class:`~openerp.fields.Many2one`), filters the possible completion results."
msgstr "如果字段可以提供自动完成（如 :class:`~openerp.fields.Many2one` ）, 过滤可能的完成结果。"

#: ../../reference/views.rst:1216
msgid "``filter``"
msgstr " ``filter`` "

#: ../../reference/views.rst:1168
msgid "a filter is a predefined toggle in the search view, it can only be enabled or disabled. Its main purposes are to add data to the search context (the context passed to the data view for searching/filtering), or to append new sections to the search filter."
msgstr "过滤器在搜索视图中预定义的切换, 它只能启用或禁用。它的主要目的是将数据添加到搜索范围内（通过为搜索/过滤数据视图中的上下文中）, 或追加新章节的搜索过滤器。"

#: ../../reference/views.rst:1173
msgid "Filters can have the following attributes:"
msgstr "过滤器可以具有以下属性:"

#: ../../reference/views.rst:1176
msgid "the label of the filter"
msgstr "过滤器的标签"

#: ../../reference/views.rst:1178
msgid "an Odoo :ref:`domain <reference/orm/domains>`, will be appended to the action's domain as part of the search domain"
msgstr "一个Odoo :ref:'域<reference/orm/domains> `, 将被追加到诉讼的域名作为搜索域的一部分"

#: ../../reference/views.rst:1181
msgid "a Python dictionary, merged into the action's domain to generate the search domain"
msgstr "Python字典, 合并到行动的字段, 以生成搜索域名"

#: ../../reference/views.rst:1184
msgid "logical name for the filter, can be used to :ref:`enable it by default <reference/views/search/defaults>`, can also be used as :ref:`inheritance hook <reference/views/inheritance>`"
msgstr "logical name for the filter, can be used to :ref:`enable it by default <reference/views/search/defaults>` , can also be used as :ref:`inheritance hook <reference/views/inheritance>` "

#: ../../reference/views.rst:1188
msgid "a longer explanatory text for the filter, may be displayed as a tooltip"
msgstr "更长的说明文字过滤器, 可能会显示为一个工具提示"

#: ../../reference/views.rst:1191
msgid "makes a filter only available to specific users"
msgstr "使得只提供给特定用户过滤器"

#: ../../reference/views.rst:1197
msgid "Sequences of filters (without non-filters separating them) are treated as inclusively composited: they will be composed with ``OR`` rather than the usual ``AND``, e.g."
msgstr "过滤器序列（不含非滤波器把它们分开）被视为（含）合成:它们将与 ``OR`` 组成, 而不是通常 ``AND`` , 例如"

#: ../../reference/views.rst:1206
msgid "if both filters are selected, will select the records whose ``state`` is ``draft`` or ``done``, but"
msgstr "如果两个滤光片的选择, 将选择 ``state`` 是 ``draft`` 或 ``done`` 记录, 但"

#: ../../reference/views.rst:1215
msgid "if both filters are selected, will select the records whose ``state`` is ``draft`` **and** ``delay`` is below 15."
msgstr "如果两个滤光片的选择, 将选择 ``state`` 是 ``draft`` **和** ``delay`` 低于15的记录。"

#: ../../reference/views.rst:1219
msgid "can be used to separates groups of filters in simple search views"
msgstr "可用于分离过滤器组简单的搜索视图"

#: ../../reference/views.rst:1221
msgid "can be used to separate groups of filters, more readable than ``separator`` in complex search views"
msgstr "可用于过滤器不同的群体, 比 `更具可读性` separator ``在复杂的搜索视图"

#: ../../reference/views.rst:1227
msgid "Search defaults"
msgstr "默认搜索"

#: ../../reference/views.rst:1229
msgid "Search fields and filters can be configured through the action's ``context`` using :samp:`search_default_{name}` keys. For fields, the value should be the value to set in the field, for filters it's a boolean value. For instance, assuming ``foo`` is a field and ``bar`` is a filter an action context of:"
msgstr ":samp: 搜索字段和筛选器可以通过诉讼的 ``context`` 使用配置 `search_default_ {名}` 键。对于字段, 其值应在现场设置值, 过滤器是一个布尔值。例如, 假定 ``foo`` 是一个字段和 ``bar`` 是过滤器的一个动作的上下文:"

#: ../../reference/views.rst:1241
msgid "will automatically enable the ``bar`` filter and search the ``foo`` field for *acro*."
msgstr "会自动启用 ``bar`` 过滤器和搜索 ``foo`` 字段 * ACRO * 。"

#: ../../reference/views.rst:1249
msgid "QWeb views are standard :ref:`reference/qweb` templates inside a view's ``arch``. They don't have a specific root element."
msgstr "QWeb的视图是标准 :ref: 内部的视图的 ```arch`` 参考/ qweb` 模板。它们不具有特定的根元素。"

#: ../../reference/views.rst:1252
msgid "A QWeb view can only contain a single template\\ [#template_inherit]_, and the template's name *must* match the view's complete (including module name) :term:`external id`."
msgstr "一个QWeb视图只能包含一个模板\\ [#template_inherit] _, 和模板的名称 *必须* 匹配视图的完整（包括模块名称）:短期:`外部ID` 。"

#: ../../reference/views.rst:1256
msgid ":ref:`reference/data/template` should be used as a shortcut to define QWeb views."
msgstr ":ref:`reference/data/template` 应作为界定QWeb意见的快捷方式。"

#: ../../reference/views.rst:1259
msgid "for backwards compatibility reasons"
msgstr "为了向下兼容的原因"

#: ../../reference/views.rst:1260
msgid "an extension function is added for simpler matching in QWeb views: ``hasclass(*classes)`` matches if the context node has all the specified classes"
msgstr "扩展功能增加了简单的匹配在QWeb视图:``hasclass（ *类）`` 匹配。如果该节点已全部指定类"

#: ../../reference/views.rst:1263
msgid "for historical reasons, it has its origin in tree-type views later repurposed to a more table/list-type display"
msgstr "由于历史的原因, 它有它的起源在树型意见后重新利用到多个表/列表式展示"

#: ../../reference/views.rst:1265
msgid "or no template if it's an inherited view, then :ref:`it should only contain xpath elements <reference/views/inheritance>`"
msgstr "or no template if it's an inherited view, then :ref:`it should only contain xpath elements <reference/views/inheritance>` "

#: ../../reference/workflows.rst:4
msgid "Workflows"
msgstr "工作流"

#: ../../reference/workflows.rst:6
msgid "In Odoo, a workflow is a technical artefact to manage a set of \"things to do\" associated to the records of a model. The workflow provides a higher-level way to organize tasks to perform with or on a record."
msgstr "在Odoo, 工作流是一个技术人工制品来管理一组'的事情做'关联模型的记录。工作流提供了一个较高级别的方式来组织任务或上的记录来执行。"

#: ../../reference/workflows.rst:10
msgid "More specifically, a workflow is a directed graph where the nodes are called \"activities\" and the arcs are called \"transitions\"."
msgstr "更具体地, 工作流是一个有向图, 其中节点被称为'活动'和弧称为'跃迁'。"

#: ../../reference/workflows.rst:13
msgid "Activities define work that should be done within the Odoo server, such as changing the state of some records, or sending emails."
msgstr "活动定义应该在Odoo服务器内进行, 比如改变一些记录状态, 或发送电子邮件的工作。"

#: ../../reference/workflows.rst:15
msgid "Transitions control how the workflow progresses from activity to activity."
msgstr "转换控制工作流程, 从活动如何进展到活动。"

#: ../../reference/workflows.rst:17
msgid "In the definition of a workflow, one can attach conditions, signals, and triggers to transitions, so that the behavior of the workflow depends on user actions (such as clicking on a button), changes to records, or arbitrary Python code."
msgstr "在工作​​流的定义中, 可以附加条件, 信号和触发器的转换, 从而使工作流的行为取决于用户动作（诸如点击一个按钮）, 改变的记录, 或任意Python代码。"

#: ../../reference/workflows.rst:22
msgid "All in all, Odoo's workflow system provides:"
msgstr "总而言之, Odoo的工作流系统提供:"

#: ../../reference/workflows.rst:24
msgid "a description of the evolution of a record (document) over time"
msgstr "记录（文件）的演变随着时间的说明"

#: ../../reference/workflows.rst:25
msgid "automatic actions based on various and flexible conditions"
msgstr "基于各种灵活的条件自动操作"

#: ../../reference/workflows.rst:26
msgid "management of company roles and validation steps"
msgstr "公司的角色和验证步骤的管理"

#: ../../reference/workflows.rst:27
msgid "management of interactions between objects"
msgstr "管理对象之间的交互"

#: ../../reference/workflows.rst:28
msgid "a visual representation of document flows through their lifecycle"
msgstr "文件的可视化表示流经它们的生命周期"

#: ../../reference/workflows.rst:30
msgid "For instance, a basic order could have the following flow:"
msgstr "例如, 一个基本的顺序可能具有以下流程:"

#: ../../reference/workflows.rst:39
msgid "Orders start in the *Draft* state, can be *Confirmed* by a user, and then either shipped (*Closed*) or *Canceled*."
msgstr "订单开始在 *选秀* 状态, 可 *确认* 由用户, 然后或者发货（ *逢* ）或 *取消* 。"

#: ../../reference/workflows.rst:42
msgid "A company using Odoo may want to add discount support to orders, where sales staff has discretionary discounting powers up to 15%, but manager validation is required for discounts beyond 15%. The workflow can be altered online to add the relevant steps without editing Python or XML files:"
msgstr "使用Odoo公司可能需要增加贴息支持的定单, 销售人员有自由裁量的权力折扣高达15％, 但经理的验证需要超过15％的折扣。工作流程可以在线修改补充相关步骤, 而无需编辑Python或XML文件:"

#: ../../reference/workflows.rst:50
msgid "Because Activities can perform arbitrary actions, the *Validation* can automatically send a validation request to the relevant employee."
msgstr "由于活动可以执行任意的操作, 在 *验证* 可以自动发送验证请求到相关员工。"

#: ../../reference/workflows.rst:53
msgid "the order view needs to be modified to add an *Accept Discount* button for managers"
msgstr "订单视图需要进行修改, 以添加 *接受折扣* 键经理"

#: ../../reference/workflows.rst:57
msgid "Basics"
msgstr "基础知识"

#: ../../reference/workflows.rst:59
msgid "Defining a workflow with data files is straightforward: a record \"workflow\" is given together with records for the activities and the transitions. For instance, here is a simple sequence of two activities defined in XML"
msgstr "定义与数据文件的工作流程很简单:一个记录'工作流程'与的活动和过渡记录一起给予。例如, 下面是两个活动的XML定义的简单序列"

#: ../../reference/workflows.rst:92
msgid "A worfklow is always defined with respect to a particular model (the model is given by the attribute ``osv`` on the model ``workflow``). Methods specified in the activities or transitions will be called on that model."
msgstr "一个worfklow始终定义相对于特定模型（该模型通过对模型 ``workflow`` 属性 ``osv`` 给出）。在活动或过渡规定的方法将被调用的这种模式。"

#: ../../reference/workflows.rst:96
msgid "In the example code above, a workflow called \"test_workflow\" is created. It is made up of two activies, named \"a\" and \"b\", and one transition, going from \"a\" to \"b\"."
msgstr "在上面的示例代码, 创建了一个名为'test_workflow'的工作流程。它是由两个activies, 名为'一个'和'B', 和一种过渡, 从'一个'打算'B'。"

#: ../../reference/workflows.rst:100
msgid "The first activity has its attribute ``flow_start`` set to ``True`` so that Odoo knows where to start the workflow traversal after it is instanciated. Because ``on_create`` is set to True on the workflow record, the workflow is instanciated for each newly created record. (Otherwise, the workflow should be instanciated by other means, such as from some module Python code.)"
msgstr "第一个活动都有其属性 ``flow_start`` 设置值为 ``True`` , 这样Odoo知道从哪里开始工作流程穿越它被实例化后。因为 ``on_create`` 设置为True工作流的记录, 工作流实例化每个新创建的记录。 （否则, 该工作流程应通过其他方式, 如从一些模块Python代码实例化）。"

#: ../../reference/workflows.rst:106
msgid "When the workflow is instanciated, it begins with activity \"a\". That activity is of kind ``function``, which means that the action ``print_a()`` is a method call on the model ``test.workflow`` (the usual ``cr, uid, ids, context`` arguments are passed for you)."
msgstr "当工作流实例化, 它以活动'一'。这项活动是种 ``function`` , 这意味着行动 ``print_a（）`` 是型号 ``test.workflow`` 一个方法调用（通常的 ``CR, UID, IDS, context`` 参数传递给你）。"

#: ../../reference/workflows.rst:111
msgid "The transition between \"a\" and \"b\" specify a signal but not any condition. This means the workflow instance will immediately transition from \"a\" to \"b\" when the signal ``signal_goto_b`` is recieved and thus processes activity \"b\"'s action ``print_b()``."
msgstr ""

#: ../../reference/workflows.rst:117
msgid "Activities"
msgstr "活动"

#: ../../reference/workflows.rst:119
msgid "While the transitions can be seen as the control structures of the workflows, activities are where everything happens, from changing record states to sending email."
msgstr "虽然转换可以看作是工作流的控制结构, 活动是在那里发生的一切, 更改记录状态, 以发送电子邮件。"

#: ../../reference/workflows.rst:123
msgid "Different kinds of activities exist: ``Dummy``, ``Function``, ``Subflow``, and ``Stop all``, each doing different things when the activity is processed. In addition to their kind, activies have other properties, detailed in the next sections."
msgstr "不同类型的活动有:``Dummy`` , ``Function`` , ``Subflow`` , 和 ``停止all`` , 每做不同的事情, 当活动进行处理。除了他们的善良, activies有其他的属性, 在接下来的章节中详细介绍。"

#: ../../reference/workflows.rst:129
msgid "Flow start and flow stop"
msgstr "流程启动和流程停止"

#: ../../reference/workflows.rst:131
msgid "The attribute ``flow_start`` is a boolean value specifying whether the activity is processed when the workflow is instanciated. Multiple activities can have their attribute ``flow_start`` set to ``True``. When instanciating a workflow for a record, Odoo simply processes all of them, and evaluate all their outgoing transitions afterwards."
msgstr "属性 ``flow_start`` 是一个布尔值, 指明是否当工作流实例化活动进行处理。多活动可以有自己的属性 ``flow_start`` 设置值为 ``True`` 。当为记录instanciating工作流程, Odoo只是处理所有这些, 并评估所有的输出转移之后。"

#: ../../reference/workflows.rst:137
msgid "The attribute ``flow_stop`` is a boolean value specifying whether the activity stops the workflow instance. A workflow instance is considered completed when all its activities with the attribute ``flow_stop`` set to ``True`` are completed."
msgstr "属性 ``flow_stop`` 是一个布尔值, 指定活动是否停止工作流实例。工作流实例被认为是当所有的活动属性 ``flow_stop`` 设置值为 ``True`` 完成完成。"

#: ../../reference/workflows.rst:142
msgid "It is important for Odoo to know when a workflow instance is completed. A workflow can have an activity that is actually another workflow (called a subflow); that activity is completed when the subflow is completed."
msgstr "这一点很重要Odoo知道何时工作流实例被完成。工作流可以有一个活动, 实际上是另一个工作流（称为子流）;当子流程完成该活动已完成。"

#: ../../reference/workflows.rst:147
msgid "Subflow"
msgstr "子流程"

#: ../../reference/workflows.rst:149
msgid "An activity can embed a complete workflow, called a subflow (the embedding workflow is called the parent workflow). The workflow to instanciate is specified by attribute ``subflow_id``."
msgstr "活性可以嵌入一个完整的工作流, 称为子流（嵌入工作流称为父工作流程）。工作流实例化是通过属性 ``subflow_id`` 规定。"

#: ../../reference/workflows.rst:153
msgid "In the GUI, that attribute can not be set unless the kind of the activity is ``Subflow``."
msgstr "在GUI中, 该属性不能被设置, 除非那种活性是 ``Subflow`` 。"

#: ../../reference/workflows.rst:156
msgid "The activity is considered completed (and its outgoing transitions ready to be evaluated) when the subflow is completed (see attribute ``flow_stop`` above)."
msgstr "该活动被认为是完成了（和它的外向转移准备进行评估）时, 子流程完成（见属性 ``以上flow_stop`` ）。"

#: ../../reference/workflows.rst:160
msgid "Sending a signal from a subflow"
msgstr "从子流程发送信号"

#: ../../reference/workflows.rst:162
msgid "When a workflow is embedded in an activity (as a subflow) of a workflow, the sublow can send a signal from its own activities to the parent workflow by giving a signal name in the attribute ``signal_send``. Odoo processes those activities by sending the value of ``signal_send`` prefixed by \"subflow.\"  to the parent workflow instance."
msgstr "当工作流被嵌入的活性（作为子流）的工作流的, 该sublow可以通过在属性 ``signal_send`` 给出的信号名从它自己的活动将信号发送到父工作流程。 Odoo通过发送 ``signal_send`` 由前缀值处理这些活动“子流程。'到父工作流实例。"

#: ../../reference/workflows.rst:168
msgid "In other words, it is possible to react and get transitions in the parent workflow as activities are executed in the sublow."
msgstr "换句话说, 有可能作出反应, 并作为活动是以sublow执行获得在父工作流程的转换。"

#: ../../reference/workflows.rst:172
msgid "Server actions"
msgstr "服务器动作"

#: ../../reference/workflows.rst:174
msgid "An activity can run a \"Server Action\" by specifying its ID in the attribute ``action_id``."
msgstr "动作可以通过在属性 ``action_id`` 指定ID 来运行 ``服务器动作`` ."

#: ../../reference/workflows.rst:178
msgid "Python action"
msgstr "Python动作"

#: ../../reference/workflows.rst:180
msgid "An activity can execute some Python code, given by the attribute ``action``. The evaluation environment is the same as the one explained in the section `Conditions`_."
msgstr "一个活动可以执行一些Python代码, 由属性 ``action`` 给出。评估环境是相同的, 在部分 `Conditions` _所述一个说明。"

#: ../../reference/workflows.rst:185
msgid "Split mode"
msgstr "分离模式"

#: ../../reference/workflows.rst:187
msgid "After an activity has been processed, Odoo evaluates its transition to reach the next activity in the flow."
msgstr "后的活性已被处理, Odoo评价其过渡到到达下一个活动中的流动。"

#: ../../reference/workflows.rst:190
msgid "However if an activity has more than one transition, Odoo must decide which activity or activities to follow."
msgstr "但是, 如果一个活动有多个转变, Odoo必须决定要遵循哪些活动或活动。"

#: ../../reference/workflows.rst:196
msgid "This choice is controlled by the ``split_mode`` attribute:"
msgstr "这种选择是由 ``split_mode`` 属性控制:"

#: ../../reference/workflows.rst:199 ../../reference/workflows.rst:224
msgid "``XOR`` (default)"
msgstr " ``XOR`` （默认）"

#: ../../reference/workflows.rst:199
msgid "By default, Odoo will use the first transition (in ``sequence`` order) whose condition is satisfied. All other transitions are ignored."
msgstr "默认情况下, Odoo将使用第一个转换（在 ``sequence`` 顺序）的条件被满足。所有其它的过渡将被忽略。"

#: ../../reference/workflows.rst:203
msgid "``OR``"
msgstr " ``OR`` "

#: ../../reference/workflows.rst:202
msgid "In ``OR`` mode, all transitions with a satisfied condition are traversed simultanously. Transitions not yet valid will be ignored, even if they become valid later."
msgstr "在 ``OR`` 模式, 所有满足条件的转换同时遍历。无效的转换将被忽略, 即使他们之后可能会变成合法的。"

#: ../../reference/workflows.rst:207 ../../reference/workflows.rst:228
msgid "``AND``"
msgstr " ``AND`` "

#: ../../reference/workflows.rst:206
msgid "In ``AND`` mode, Odoo will wait until *all* transitions are satisfied, and will traverse all of them (much like the ``OR`` mode)."
msgstr "在 ``AND`` 模式, Odoo 将会等待直到 *所有* 转换都以满足, 并将会遍历所有的转换 (有些像 ``OR`` 模式)."

#: ../../reference/workflows.rst:209
msgid "Both ``OR`` and ``AND`` mode will lead to activities being active in the same workflow."
msgstr "两个 ``OR`` 和 ``AND`` 模式将导致活动是活跃在相同的工作流程。"

#: ../../reference/workflows.rst:213
msgid "Join mode"
msgstr "加盟模式"

#: ../../reference/workflows.rst:215
msgid "Just like outgoing transition conditions can be combined together to decide whether they can be traversed or not, incoming transitions can be combined together to decide if and when an activity may be processed."
msgstr "就像向外的转移条件可被组合在一起, 以决定它们是否可以遍历或没有, 进入转移可以结合在一起, 以决定是否以及何时活动可被处理。"

#: ../../reference/workflows.rst:222
msgid "The ``join_mode`` attribute controls that behavior:"
msgstr "该 ``join_mode`` 属性控制的行为:"

#: ../../reference/workflows.rst:225
msgid "Any incoming transition enables the activity and starts its processing."
msgstr "任何传入的转换启用活动, 并开始它的处理。"

#: ../../reference/workflows.rst:227
msgid "The activity is enabled and processed only once *all* incoming transitions have been traversed."
msgstr "该活动已启用, 并且只处理一次 **所有进入转移已经走过。"

#: ../../reference/workflows.rst:231
msgid "Kinds"
msgstr "种类"

#: ../../reference/workflows.rst:233
msgid "An activity's kind defines the type of work an activity can perform."
msgstr "一个活动的一种定义工作的一个活动可以执行的任务类型。"

#: ../../reference/workflows.rst:236
msgid "Dummy (``dummy``, default)"
msgstr "虚拟（ ``dummy`` , 默认）"

#: ../../reference/workflows.rst:236
msgid "Do nothing at all, or call a server action. Often used as dispatch or gather \"hubs\" for transitions."
msgstr "什么也不做, 或者调用服务器动作. 通常用作分发, 或做为转换的收集 ``hub`` ."

#: ../../reference/workflows.rst:238
msgid "Function (``function``)"
msgstr "功能（ ``function`` ）"

#: ../../reference/workflows.rst:239
msgid "Run some python code, execute a server action."
msgstr "运行Python代码, 执行服务器动作。"

#: ../../reference/workflows.rst:240
msgid "Stop all (``stopall``)"
msgstr "停止所有（ ``stopall`` ）"

#: ../../reference/workflows.rst:241
msgid "Completely stops the workflow instance and marks it as completed."
msgstr "完全停止工作流实例并将其标记为已完成。"

#: ../../reference/workflows.rst:250
msgid "Subflow (``subflow``)"
msgstr "子流（ ``subflow`` ）"

#: ../../reference/workflows.rst:243
msgid "Starts executing an other workflow, once that workflow is completed the activity is done processing."
msgstr "开始执行的其他工作流, 一旦工作流完成时进行处理的活动。"

#: ../../reference/workflows.rst:246
msgid "By default, the subflow is instanciated for the same record as the parent workflow. It is possible to change that behavior by providing Python code that returns a record ID (of the same data model as the subflow). The embedded subflow instance is then the one of the given record."
msgstr "默认情况下, 子流实例化在同一记录作为父母的工作流程。它也可能通过提供Python代码返回（相同的数据模型作为子流）记录ID来改变该行为。嵌入子流实例被给定记录中的一个。"

#: ../../reference/workflows.rst:253
msgid "Transitions"
msgstr "转换"

#: ../../reference/workflows.rst:255
msgid "Transitions provide the control structures to orchestrate a workflow. When an activity is completed, the workflow engine tries to get across transitions departing from the completed activity, towards the next activities. In their simplest form (as in the example above), they link activities sequentially: activities are processed as soon as the activities preceding them are completed."
msgstr "转换提供控制结构来协调的工作流。当活动结束后, 工作流引擎试图传达的过渡, 从已完成的活动出发, 朝着下一个活动。在其最简单的形式（如在上面的例子中）, 他们链接活动顺序:活动只要它们之前的活动完成处理。"

#: ../../reference/workflows.rst:262
msgid "Instead of running all activities in one fell swoop, it is also possible to wait on transitions, going through them only when some criteria are met. The criteria are the conditions, the signals, and the triggers. They are detailed in the following sections."
msgstr "而不是运行一举所有活动, 它也有可能等待过渡, 经过他们只有在满足某些条件​​。标准的条件是, 信号, 和所述触发器。它们在以下部分中详细说明。"

#: ../../reference/workflows.rst:268
msgid "Conditions"
msgstr "条件"

#: ../../reference/workflows.rst:270
msgid ""
"When an activity has been completed, its outgoing transitions are inspected to determine whether it is possible for the workflow instance to proceed through them and reach the next activities. When only a condition is defined (i.e., no signal or trigger is defined), the condition is evaluated by Odoo, and if it evaluates to ``True``, the worklfow instance progresses through the transition.  If the condition is not met, it will be reevaluated every time the associated record is modified, or by an "
"explicit method call to do it."
msgstr "当一个活动已完成, 其输出转换被检验, 以确定它是否是可能的工作流实例以继续通过它们和到达下一个活动。当只有一个条件被定义（即没有信号或触发定义）, 条件是由Odoo计算, 如果计算结果为 ``True`` , 那么通过过渡worklfow实例进展。如果条件不被满足, 它会在每个相关的记录被修改的时间重新评估, 或通过显式方法调用做。"

#: ../../reference/workflows.rst:278
msgid "By default, the attribute ``condition`` (i.e., the expression to be evaluated) is just \"True\", which trivially evaluates to ``True``. Note that the condition may be several lines long; in that case, the value of the last one determines whether the transition can be taken."
msgstr "默认情况下, 该属性 ``condition`` （即要计算的表达式）只是'真正的', 这平凡的计算结果为值为 ``True`` 。注意, 条件可以是几行长;在那种情况下, 最后一个的值确定过渡是否可以采取。"

#: ../../reference/workflows.rst:283
msgid "In the condition evaluation environment, several symbols are conveniently defined (in addition to the Odoo ``safe_eval`` environment):"
msgstr "在条件评估环境, 几个符号便利定义（除了Odoo ``safe_eval`` 环境）:"

#: ../../reference/workflows.rst:286
msgid "all the model column names, and"
msgstr "所有型号的列名, 和"

#: ../../reference/workflows.rst:287
msgid "all the browse record's attributes."
msgstr "浏览记录的所有属性"

#: ../../reference/workflows.rst:292
msgid "Signals"
msgstr "信号"

#: ../../reference/workflows.rst:294
msgid "In addition to a condition, a transition can specify a signal name. When such a signal name is present, the transition is not taken directly, even if the condition evaluates to ``True``. Instead the transition blocks, waiting to be woken up."
msgstr "除了一个条件, 过渡可以指定信号名称。当这种信号的名字出现, 过渡不采取直接, 即使条件为值为 ``True`` 。取而代之的是过渡块, 等待被唤醒。"

#: ../../reference/workflows.rst:299
msgid "In order to wake up a transition with a defined signal name, the signal must be sent to the workflow instance. A common way to send a signal is to use a button in the user interface, using the element ``<button/>`` with the signal name as the attribute ``name`` of the button. Once the button is clicked, the signal is sent to the workflow instance of the current record."
msgstr "为了唤醒具有限定信号名称的过渡时, 信号必须被发送到工作流实例。发送信号的一般方法是在用户界面中使用的一个按钮, 利用所述元素 ``<button/>`` 与作为按钮的属性 ``name`` 的信号名称。一旦按钮被点击时, 信号被发送到当前记录的工作流实例。"

#: ../../reference/workflows.rst:305
msgid "The condition is still evaluated when the signal is sent to the workflow instance."
msgstr "当该信号被发送到工作流实例中的条件仍然是评价。"

#: ../../reference/workflows.rst:309
msgid "Triggers"
msgstr "触发器"

#: ../../reference/workflows.rst:311
msgid ""
"With conditions that evaluate to ``False``, transitions are not taken (and thus the activity it leads to is not processed immediately). Still, the workflow instance can get new chances to progress across that transition by providing so-called triggers. The idea is that when the condition is not satisfied, triggers are recorded in database. Later, it is possible to wake up specifically the workflow instances that installed those triggers, offering them to reevaluate their transition conditions. This "
"mechanism makes it cheaper to wake up workflow instances by targetting just a few of them (those that have installed the triggers) instead of all of them."
msgstr "与评价条件 ``False`` , 过渡不采取（以及因此的活动它导致不立即处理）。不过, 工作流实例可以得到新的机会, 通过提供所谓的触发器跨越这种转变的进展。这个想法是, 当条件不成立时, 触发器被记录在数据库中。后来, 有可能唤醒特别是安装这些触发器, 为他们提供重新评估他们的转移条件的工作流实例。这种机制使得它更便宜的通过目标定位只是一小部分, 而不是全部的人（那些已经安装了触发器）醒来的工作流实例。"

#: ../../reference/workflows.rst:321
msgid "Triggers are recorded in database as record IDs (together with the model name) and refer to the workflow instance waiting for those records. The transition definition provides a model name (attribute ``trigger_model``) and a Python expression (attribute ``trigger_expression``) that evaluates to a list of record IDs in the given model. Any of those records can wake up the workflow instance they are associated with."
msgstr "触发器都记录在数据库中记录的ID（连同型号名称）, 指的是工作流实例等待这些记录。过渡定义提供计算结果为给定的模型中记录ID列表的型号名称（属性 ``trigger_model`` ）和Python表达式（属性 ``trigger_expression`` ）。任何的这些记录可以唤醒它们与相关联的工作流实例。"

#: ../../reference/workflows.rst:328
msgid "triggers are not re-installed whenever the transition is re-tried."
msgstr "转换器没有重试之前, 触发器是不会重新安装的。"
