# SOME DESCRIPTIVE TITLE.
# Copyright (C) Odoo S.A.
# This file is distributed under the same license as the odoo package.
# 
# Translators:
# Damon Liu <315276651@qq.com>, 2016
# Jeffery Chenn <jeffery9@gmail.com>, 2015
# Jeffery Chenn <jeffery9@gmail.com>, 2015-2016
# Uming Peng <umingpeng@gmail.com>, 2015
msgid ""
msgstr ""
"Project-Id-Version: odoo documentation technical\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2016-05-30 19:35+0800\n"
"PO-Revision-Date: 2016-06-11 12:08+0000\n"
"Last-Translator: Jeffery Chenn <jeffery9@gmail.com>\n"
"Language-Team: Chinese (China) (http://www.transifex.com/odoo-cn/odoo-documentation-technical/language/zh_CN/)\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Language: zh_CN\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#: ../../howtos/backend.rst:7
msgid "Building a Module"
msgstr "构建模块"

#: ../../howtos/backend.rst:11
msgid "This tutorial requires :ref:`having installed Odoo <setup/install>`"
msgstr "此教程需要 :ref:`有已安装的Odoo <setup/install>` "

#: ../../howtos/backend.rst:14
msgid "Start/Stop the Odoo server"
msgstr "启动/停止Odoo服务器"

#: ../../howtos/backend.rst:16
msgid ""
"Odoo uses a client/server architecture in which clients are web browsers "
"accessing the Odoo server via RPC."
msgstr "Odoo使用客户机/服务器体系结构, 其中客户端是web浏览器访问通过RPC访问Odoo服务器。"

#: ../../howtos/backend.rst:19
msgid ""
"Business logic and extension is generally performed on the server side, "
"although supporting client features (e.g. new data representation such as "
"interactive maps) can be added to the client."
msgstr "业务逻辑和扩展一般进行在服务器端, 虽然支持客户端功能（例如, 新的数据表示诸如交互式地图）可以被添加到客户端。"

#: ../../howtos/backend.rst:23
msgid ""
"In order to start the server, simply invoke the command :ref:`odoo.py "
"<reference/cmdline>` in the shell, adding the full path to the file if "
"necessary:"
msgstr "启动服务器, 只需在Shell调用命令 :ref:`odoo.py <reference/cmdline>` , 如果有必要, 加入的完整路径到文件里:"

#: ../../howtos/backend.rst:31
msgid ""
"The server is stopped by hitting ``Ctrl-C`` twice from the terminal, or by "
"killing the corresponding OS process."
msgstr "服务器发生碰撞停止 ``按Ctrl-C`` 两次从终端, 或者通过杀死相应的操作系统进程。"

#: ../../howtos/backend.rst:35
msgid "Build an Odoo module"
msgstr "构建Odoo模块"

#: ../../howtos/backend.rst:37
msgid ""
"Both server and client extensions are packaged as *modules* which are "
"optionally loaded in a *database*."
msgstr "服务器和客户端扩展封装成 *模块* ，它在 *数据库* 中可选加载。"

#: ../../howtos/backend.rst:40
msgid ""
"Odoo modules can either add brand new business logic to an Odoo system, or "
"alter and extend existing business logic: a module can be created to add "
"your country's accounting rules to Odoo's generic accounting support, while "
"the next module adds support for real-time visualisation of a bus fleet."
msgstr "Odoo模块可以添加全新的业务逻辑的Odoo系统, 或修改和扩展现有的业务逻辑:一个模块可以创建你的国家的会计规则添加到Odoo的通用会计支持, 而下一个模块增加了实时可视化支持的公交车队。"

#: ../../howtos/backend.rst:45
msgid "Everything in Odoo thus starts and ends with modules."
msgstr "在Odoo所有的一切都以模块开始和结束。"

#: ../../howtos/backend.rst:48
msgid "Composition of a module"
msgstr "一个模块的组成"

#: ../../howtos/backend.rst:50
msgid "An Odoo module can contain a number of elements:"
msgstr "一个Odoo模块可以包含几个要素:"

#: ../../howtos/backend.rst:54
msgid "Business objects"
msgstr "业务对象"

#: ../../howtos/backend.rst:53
msgid ""
"declared as Python classes, these resources are automatically persisted by "
"Odoo based on their configuration"
msgstr "声明为Python类, 这些资源会自动Odoo根据其配置的坚持"

#: ../../howtos/backend.rst:58 ../../howtos/backend.rst:219
msgid "Data files"
msgstr "数据文件"

#: ../../howtos/backend.rst:57
msgid ""
"XML or CSV files declaring metadata (views or workflows), configuration data"
" (modules parameterization), demonstration data and more"
msgstr "XML或CSV文件中声明元数据（意见或工作流）, 配置数据（模块参数）, 演示数据和更多"

#: ../../howtos/backend.rst:61
msgid "Web controllers"
msgstr "网络控制器"

#: ../../howtos/backend.rst:61
msgid "Handle requests from web browsers"
msgstr "处理来自Web浏览器的请求"

#: ../../howtos/backend.rst:64
msgid "Static web data"
msgstr "静态网页数据"

#: ../../howtos/backend.rst:64
msgid "Images, CSS or javascript files used by the web interface or website"
msgstr "用于Web界面或网站的图像, CSS以及JavaScript文件"

#: ../../howtos/backend.rst:67
msgid "Module structure"
msgstr "模块结构"

#: ../../howtos/backend.rst:69
msgid ""
"Each module is a directory within a *module directory*. Module directories "
"are specified by using the :option:`--addons-path <odoo.py --addons-path>` "
"option."
msgstr "Each module is a directory within a *module directory* . Module directories are specified by using the :option:`--addons-path <odoo.py --addons-path>` option."

#: ../../howtos/backend.rst:76
msgid ""
"most command-line options can also be set using :ref:`a configuration file "
"<reference/cmdline/config>`"
msgstr "大多数命令行选项也可以使用 :ref:`配置文件<reference/cmdline/config> `  设置"

#: ../../howtos/backend.rst:79
msgid ""
"An Odoo module is declared by its :ref:`manifest "
"<reference/module/manifest>`. See the :ref:`manifest documentation "
"<reference/module/manifest>` information about it."
msgstr "Odoo 模块通过它的 :ref:`manifest <reference/module/manifest>` 声明 . 查看 :ref:`manifest文档 <reference/module/manifest>` 关于它的信息."

#: ../../howtos/backend.rst:83
msgid ""
"A module is also a `Python package "
"<http://docs.python.org/2/tutorial/modules.html#packages>`_ with a "
"``__init__.py`` file, containing import instructions for various Python "
"files in the module."
msgstr "每个模块都是一个` Python包 \n<http ://docs.python.org/2/tutorial/modules.html#packages>` 包含一个 ``__init__.py`` 文件, 内容为 Python文件导入指令。"

#: ../../howtos/backend.rst:88
msgid ""
"For instance, if the module has a single ``mymodule.py`` file "
"``__init__.py`` might contain::"
msgstr "举例来说, 如果模块有一个 ``mymodule.py`` 文件 ``__init__.py`` 可能包含 ::"

#: ../../howtos/backend.rst:93
msgid ""
"Odoo provides a mechanism to help set up a new module, :ref:`odoo.py "
"<reference/cmdline/server>` has a subcommand :ref:`scaffold "
"<reference/cmdline/scaffold>` to create an empty module:"
msgstr "Odoo提供了一个机制帮助建立一个新的模块, :ref:`odoo.py <reference/cmdline/server>` 有一个子命令 :ref:`scaffold<reference/cmdline/scaffold>` 用来创建一个空的模块:"

#: ../../howtos/backend.rst:101
msgid ""
"The command creates a subdirectory for your module, and automatically "
"creates a bunch of standard files for a module. Most of them simply contain "
"commented code or XML. The usage of most of those files will be explained "
"along this tutorial."
msgstr "该命令为你的模块的子目录, 并自动为模块创建了一堆的标准文件。他们大多只包含注释代码或XML。大部分这些文件的使用将沿着这个教程来解释。"

#: ../../howtos/backend.rst:105
msgid "Module creation"
msgstr "模块创建"

#: ../../howtos/backend.rst:107
msgid ""
"Use the command line above to  create an empty module Open Academy, and "
"install it in Odoo."
msgstr "使用上面的命令行创建一个空的模块开放学院, 并在Odoo安装。"

#: ../../howtos/backend.rst:112
msgid "Invoke the command ``odoo.py scaffold openacademy addons``."
msgstr "调用命令 ``odoo.py支架openacademy addons`` 。"

#: ../../howtos/backend.rst:113
msgid "Adapt the manifest file to your module."
msgstr "为你的模块适配清单文件。"

#: ../../howtos/backend.rst:114
msgid "Don't bother about the other files."
msgstr "不要理会其他文件。"

#: ../../howtos/backend.rst:119
msgid "Object-Relational Mapping"
msgstr "对象 - 关系映射"

#: ../../howtos/backend.rst:121
msgid ""
"A key component of Odoo is the :abbr:`ORM (Object-Relational Mapping)` "
"layer. This layer avoids having to write most :abbr:`SQL (Structured Query "
"Language)` by hand and provides extensibility and security services\\ "
"[#rawsql]_."
msgstr "Odoo的一个关键组成部分是 :abbr:`ORM（对象关系映射）` 层。这一层避免了编写大部分 :abbr:`SQL（结构化查询语言）` 手, 并提供可扩展性和安全服务\\ [#rawsql] _。"

#: ../../howtos/backend.rst:125
msgid ""
"Business objects are declared as Python classes extending "
":class:`~openerp.models.Model` which integrates them into the automated "
"persistence system."
msgstr "业务对象被声明为扩展Python类 :class:`~openerp.models.Model` 它集成到他们的自动化系统的持久性。"

#: ../../howtos/backend.rst:129
msgid ""
"Models can be configured by setting a number of attributes at their "
"definition. The most important attribute is "
":attr:`~openerp.models.Model._name` which is required and defines the name "
"for the model in the Odoo system. Here is a minimally complete definition of"
" a model::"
msgstr "模型可以通过设置多个属性在它们的定义进行配置。最重要的属性是 :attr:`~这是必需的, 定义了名称模式在Odoo系统openerp.models.Model._name` 。这里有一个模型的最小完整的定义 ::"

#: ../../howtos/backend.rst:140
msgid "Model fields"
msgstr "模型字段"

#: ../../howtos/backend.rst:142
msgid ""
"Fields are used to define what the model can store and where. Fields are "
"defined as attributes on the model class::"
msgstr "字段被用来定义该模型可以存储在哪里。字段定义的模型类属性 ::"

#: ../../howtos/backend.rst:153
msgid "Common Attributes"
msgstr "公共属性"

#: ../../howtos/backend.rst:155
msgid ""
"Much like the model itself, its fields can be configured, by passing "
"configuration attributes as parameters::"
msgstr "很像模型本身, 它的字段可以被配置, 通过使配置属性作为参数 ::"

#: ../../howtos/backend.rst:160
msgid ""
"Some attributes are available on all fields, here are the most common ones:"
msgstr "有些属性是适用于所有字段, 这里是最常见的:"

#: ../../howtos/backend.rst:162
msgid ""
":attr:`~openerp.fields.Field.string` (``unicode``, default: field's name)"
msgstr ":attr:`~openerp.fields.Field.string` (``unicode``, default: field's name)"

#: ../../howtos/backend.rst:163
msgid "The label of the field in UI (visible by users)."
msgstr "该场的UI上的标签（由用户可见）。"

#: ../../howtos/backend.rst:165
msgid ":attr:`~openerp.fields.Field.required` (``bool``, default: ``False``)"
msgstr ":attr:`~openerp.fields.Field.required` (``bool``, default: ``False``)"

#: ../../howtos/backend.rst:165
msgid ""
"If ``True``, the field can not be empty, it must either have a default value"
" or always be given a value when creating a record."
msgstr "如果 ``True`` , 那么该字段不能为空, 它必须拥有一个默认值或总是创建一个记录时被赋予的值。"

#: ../../howtos/backend.rst:167
msgid ":attr:`~openerp.fields.Field.help` (``unicode``, default: ``''``)"
msgstr ":attr:`~openerp.fields.Field.help` (``unicode``, default: ``''``)"

#: ../../howtos/backend.rst:168
msgid "Long-form, provides a help tooltip to users in the UI."
msgstr "长的形式, 提供了一种帮助工具提示用户在UI中。"

#: ../../howtos/backend.rst:170
msgid ":attr:`~openerp.fields.Field.index` (``bool``, default: ``False``)"
msgstr ":attr:`~openerp.fields.Field.index` (``bool``, default: ``False``)"

#: ../../howtos/backend.rst:170
msgid "Requests that Odoo create a `database index`_ on the column"
msgstr "请在列Odoo创建'数据库index `_"

#: ../../howtos/backend.rst:173
msgid "Simple fields"
msgstr "简单字段"

#: ../../howtos/backend.rst:175
msgid ""
"There are two broad categories of fields: \"simple\" fields which are atomic"
" values stored directly in the model's table and \"relational\" fields "
"linking records (of the same model or of different models)."
msgstr "有场分为两大 :class:'简单的'字段其连接记录（不同型号的同型号或）直接存储在模型中的表和'关系'字段中原子值。"

#: ../../howtos/backend.rst:179
msgid ""
"Example of simple fields are :class:`~openerp.fields.Boolean`, "
":class:`~openerp.fields.Date`, :class:`~openerp.fields.Char`."
msgstr "简单的字段例子有 :class:`~openerp.fields.Boolean` , :class:`~openerp.fields.Date` , :class:`~openerp.fields.Char` 。"

#: ../../howtos/backend.rst:183
msgid "Reserved fields"
msgstr "保留字段"

#: ../../howtos/backend.rst:185
msgid ""
"Odoo creates a few fields in all models\\ [#autofields]_. These fields are "
"managed by the system and shouldn't be written to. They can be read if "
"useful or necessary:"
msgstr "Odoo创建在所有模型\\ [#autofields]一些字段_。这些字段由系统管理, 并且不应被写入。他们可以, 如果有用或需要时阅读:"

#: ../../howtos/backend.rst:189
msgid ":attr:`~openerp.fields.Model.id` (:class:`~openerp.fields.Id`)"
msgstr ":attr:`~openerp.fields.Model.id` (:class:`~openerp.fields.Id`)"

#: ../../howtos/backend.rst:190
msgid "the unique identifier for a record in its model"
msgstr "记录在其模型中的唯一标识符"

#: ../../howtos/backend.rst:191
msgid ""
":attr:`~openerp.fields.Model.create_date` "
"(:class:`~openerp.fields.Datetime`)"
msgstr ":attr:`~openerp.fields.Model.create_date` (:class:`~openerp.fields.Datetime`)"

#: ../../howtos/backend.rst:192
msgid "creation date of the record"
msgstr "记录的创建日期"

#: ../../howtos/backend.rst:193
msgid ""
":attr:`~openerp.fields.Model.create_uid` (:class:`~openerp.fields.Many2one`)"
msgstr ":attr:`~openerp.fields.Model.create_uid` (:class:`~openerp.fields.Many2one`)"

#: ../../howtos/backend.rst:194
msgid "user who created the record"
msgstr "创建记录的用户"

#: ../../howtos/backend.rst:195
msgid ""
":attr:`~openerp.fields.Model.write_date` (:class:`~openerp.fields.Datetime`)"
msgstr ":attr:`~openerp.fields.Model.write_date` (:class:`~openerp.fields.Datetime`)"

#: ../../howtos/backend.rst:196
msgid "last modification date of the record"
msgstr "记录的最后修改日期"

#: ../../howtos/backend.rst:198
msgid ""
":attr:`~openerp.fields.Model.write_uid` (:class:`~openerp.fields.Many2one`)"
msgstr ":attr:`~openerp.fields.Model.write_uid` (:class:`~openerp.fields.Many2one`)"

#: ../../howtos/backend.rst:198
msgid "user who last modified the record"
msgstr "最后修改记录的用户"

#: ../../howtos/backend.rst:201
msgid "Special fields"
msgstr "特殊字段"

#: ../../howtos/backend.rst:203
msgid ""
"By default, Odoo also requires a ``name`` field on all models for various "
"display and search behaviors. The field used for these purposes can be "
"overridden by setting :attr:`~openerp.models.Model._rec_name`."
msgstr "默认情况下, Odoo还要求所有的模型有``name`` 字段用于各种显示和搜索行为。用于这些目的的字段可以通过设置 :attr:`~openerp.models.Model._rec_name` 来覆盖 。"

#: ../../howtos/backend.rst:207
msgid "Define a model"
msgstr "定义一个模型"

#: ../../howtos/backend.rst:209
msgid ""
"Define a new data model *Course* in the *openacademy* module. A course has a"
" title and a description. Courses must have a title."
msgstr "定义一个新的数据模型 *课程* 的 * openacademy * 模块内。一个疗程有一个标题和描述。课程必须有一个标题。"

#: ../../howtos/backend.rst:214
msgid "Edit the file ``openacademy/models.py`` to include a *Course* class."
msgstr "编辑文件 ``openacademy / models.py`` 为包括 *课程* 类。"

#: ../../howtos/backend.rst:221
msgid ""
"Odoo is a highly data driven system. Although behavior is customized using "
"Python_ code part of a module's value is in the data it sets up when loaded."
msgstr "Odoo是一个高度数据驱动的系统。虽然行为是使用一个模块的价值Python_代码的一部分定制是它建立加载时的数据。"

#: ../../howtos/backend.rst:224
msgid "some modules exist solely to add data into Odoo"
msgstr "一些模块的存在仅仅将数据添加到Odoo"

#: ../../howtos/backend.rst:227
msgid ""
"Module data is declared via :ref:`data files <reference/data>`, XML files "
"with ``<record>`` elements. Each ``<record>`` element creates or updates a "
"database record."
msgstr ":ref:`数据文件<reference/data>` , 用 ``<record>`` 元素的XML文件模块数据通过声明。每个 ``<record>`` 元素创建或更新数据库记录。"

#: ../../howtos/backend.rst:241
msgid "``model`` is the name of the Odoo model for the record"
msgstr " ``model`` 是记录的Odoo模型的名称"

#: ../../howtos/backend.rst:242
msgid ""
"``id`` is an :term:`external identifier`, it allows referring to the record "
"(without having to know its in-database identifier)"
msgstr " ``id`` 是一个 :term:`外部标示符` , 它允许参照某个记录（不必知道它在数据库中的ID）"

#: ../../howtos/backend.rst:244
msgid ""
"``<field>`` elements have a ``name`` which is the name of the field in the "
"model (e.g. ``description``). Their body is the field's value."
msgstr " ``<field>`` elements have a ``name`` which is the name of the field in the model (e.g. ``description`` ). Their body is the field's value."

#: ../../howtos/backend.rst:247
msgid ""
"Data files have to be declared in the manifest file to be loaded, they can "
"be declared in the ``'data'`` list (always loaded) or in the ``'demo'`` list"
" (only loaded in demonstration mode)."
msgstr "数据文件已在清单文件中声明要加载, 他们可以在 ``声明为“data'`` 名单（总是加载）或在 ``'demo'`` 名单（只能在演示模式下加载） 。"

#: ../../howtos/backend.rst:251
msgid "Define demonstration data"
msgstr "定义演示数据"

#: ../../howtos/backend.rst:253
msgid ""
"Create demonstration data filling the *Courses* model with a few "
"demonstration courses."
msgstr "创建演示数据填充 *课程* 模型有一些示范课程。"

#: ../../howtos/backend.rst:258
msgid "Edit the file ``openacademy/demo.xml`` to include some data."
msgstr "编辑文件 ``openacademy / demo.xml`` , 包括一些数据。"

#: ../../howtos/backend.rst:263
msgid "Actions and Menus"
msgstr "动作和菜单"

#: ../../howtos/backend.rst:265
msgid ""
"Actions and menus are regular records in database, usually declared through "
"data files. Actions can be triggered in three ways:"
msgstr "动作和菜单都是在数据库中普通记录, 通常通过数据文件声明。动作可以通过三种方式触发:"

#: ../../howtos/backend.rst:268
msgid "by clicking on menu items (linked to specific actions)"
msgstr "通过点击菜单项（链接到具体行动）"

#: ../../howtos/backend.rst:269
msgid "by clicking on buttons in views (if these are connected to actions)"
msgstr "通过在视图中单击按钮（如果这些连接动作）"

#: ../../howtos/backend.rst:270
msgid "as contextual actions on object"
msgstr "作为对象的上下文动作"

#: ../../howtos/backend.rst:272
msgid ""
"Because menus are somewhat complex to declare there is a ``<menuitem>`` "
"shortcut to declare an ``ir.ui.menu`` and connect it to the corresponding "
"action more easily."
msgstr "Because menus are somewhat complex to declare there is a ``<menuitem>`` shortcut to declare an ``ir.ui.menu`` and connect it to the corresponding action more easily."

#: ../../howtos/backend.rst:289
msgid ""
"The action must be declared before its corresponding menu in the XML file."
msgstr "动作一定XML文件中其相应的菜单之前声明。"

#: ../../howtos/backend.rst:291
msgid ""
"Data files are executed sequentially, the action's ``id`` must be present in"
" the database before the menu can be created."
msgstr "数据的文件被顺序执行时, 动作的 ``id`` 必须存在在数据库中, 可以创建菜单之前。"

#: ../../howtos/backend.rst:294
msgid "Define new menu entries"
msgstr "定义新的菜单项"

#: ../../howtos/backend.rst:296
msgid ""
"Define new menu entries to access courses under the OpenAcademy menu entry. "
"A user should be able to"
msgstr "Define new menu entries to access courses under the OpenAcademy menu entry. A user should be able to"

#: ../../howtos/backend.rst:299
msgid "display a list of all the courses"
msgstr "显示所有课程的列表"

#: ../../howtos/backend.rst:300
msgid "create/modify courses"
msgstr "创建/修改课程"

#: ../../howtos/backend.rst:304
msgid ""
"Create ``openacademy/views/openacademy.xml`` with an action and the menus "
"triggering the action"
msgstr "创建 ``openacademy /视图/ openacademy.xml`` 与动作和菜单触发动作"

#: ../../howtos/backend.rst:306
msgid "Add it to the ``data`` list of ``openacademy/__openerp__.py``"
msgstr "将它添加到了 ``openacademy / __ __ OpenERP的。py`` 的 ``data`` 名单"

#: ../../howtos/backend.rst:311
msgid "Basic views"
msgstr "基本视图"

#: ../../howtos/backend.rst:313
msgid ""
"Views define the way the records of a model are displayed. Each type of view"
" represents a mode of visualization (a list of records, a graph of their "
"aggregation, …). Views can either be requested generically via their type "
"(e.g. *a list of partners*) or specifically via their id. For generic "
"requests, the view with the correct type and the lowest priority will be "
"used (so the lowest-priority view of each type is the default view for that "
"type)."
msgstr "视图定义显示模型的记录的方式。每一种类型的视图表示的可视化的模式（记录列表, 它们的聚集的曲线图, ...）。视图既可以通过一般的类型要求（如: *合作伙伴名单* ）或专门通过其ID。对于一般的请求, 用正确的类型和优先级最低的视图将被用来（所以每个类型的优先级最低的看法是该类型的默认视图）。"

#: ../../howtos/backend.rst:321
msgid ""
":ref:`View inheritance <reference/views/inheritance>` allows altering views "
"declared elsewhere (adding or removing content)."
msgstr ":ref:`视图继承<reference/views/inheritance>' 允许在任何地方改变视图声明（添加或删除内容）。"

#: ../../howtos/backend.rst:325
msgid "Generic view declaration"
msgstr "通用视图声明"

#: ../../howtos/backend.rst:327
msgid ""
"A view is declared as a record of the model ``ir.ui.view``. The view type is"
" implied by the root element of the ``arch`` field:"
msgstr "视图声明为模型 ``ir.ui.view`` 的记录。视图类型通过 ``arch`` 字段的根元素指示:"

#: ../../howtos/backend.rst:341
msgid "The view's content is XML."
msgstr "该视图的内容是XML。"

#: ../../howtos/backend.rst:344
msgid ""
"The ``arch`` field must thus be declared as ``type=\"xml\"`` to be parsed "
"correctly."
msgstr "该 ``arch`` 场因此必须声明为 ``型='XML'`` 要正确分析。"

#: ../../howtos/backend.rst:348 ../../howtos/backend.rst:980
msgid "Tree views"
msgstr "树状视图"

#: ../../howtos/backend.rst:350
msgid "Tree views, also called list views, display records in a tabular form."
msgstr "树视图, 也称为列表视图, 以表格的形式显示记录。"

#: ../../howtos/backend.rst:352
msgid ""
"Their root element is ``<tree>``. The simplest form of the tree view simply "
"lists all the fields to display in the table (each field as a column):"
msgstr "Their root element is ``<tree>`` . The simplest form of the tree view simply lists all the fields to display in the table (each field as a column) :"

#: ../../howtos/backend.rst:363
msgid "Form views"
msgstr "表单视图"

#: ../../howtos/backend.rst:365
msgid "Forms are used to create and edit single records."
msgstr "表单用于创建和编辑单个记录。"

#: ../../howtos/backend.rst:368
msgid ""
"Their root element is ``<form>``. They composed of high-level structure "
"elements (groups, notebooks) and interactive elements (buttons and fields):"
msgstr "他们的根元素是 ``的<form>`` 。它们组成的高级别结构元件（基团, 笔记本）和交互元素（按钮和字段）:"

#: ../../howtos/backend.rst:397
msgid "Customise form view using XML"
msgstr "使用XML自定义表单视图"

#: ../../howtos/backend.rst:399
msgid ""
"Create your own form view for the Course object. Data displayed should be: "
"the name and the description of the course."
msgstr "创建课程对象自己的表单视图。数据显示应该是:名和过程的描述。"

#: ../../howtos/backend.rst:406
msgid "Notebooks"
msgstr "笔记本"

#: ../../howtos/backend.rst:408
msgid ""
"In the Course form view, put the description field under a tab, such that it"
" will be easier to add other tabs later, containing additional information."
msgstr "在课程表视图, 把描述字段选项卡下, 这样它会更容易在以后添加其他标签, 包含附加信息。"

#: ../../howtos/backend.rst:414
msgid "Modify the Course form view as follows:"
msgstr "修改课程形式视图如下:"

#: ../../howtos/backend.rst:418
msgid "Form views can also use plain HTML for more flexible layouts:"
msgstr "表格视图也可以使用纯HTML更灵活的布局:"

#: ../../howtos/backend.rst:445 ../../howtos/backend.rst:1068
#: ../../howtos/backend.rst:1110
msgid "Search views"
msgstr "搜索视图"

#: ../../howtos/backend.rst:447
msgid ""
"Search views customize the search field associated with the list view (and "
"other aggregated views). Their root element is ``<search>`` and they're "
"composed of fields defining which fields can be searched on:"
msgstr "Search views customize the search field associated with the list view (and other aggregated views). Their root element is ``<search>`` and they're composed of fields defining which fields can be searched on :"

#: ../../howtos/backend.rst:458
msgid ""
"If no search view exists for the model, Odoo generates one which only allows"
" searching on the ``name`` field."
msgstr "如果没有搜索视图存在的模式, Odoo生成一个只允许搜索的 ``name`` 字段。"

#: ../../howtos/backend.rst:461
msgid "Search courses"
msgstr "搜索课程"

#: ../../howtos/backend.rst:463
msgid "Allow searching for courses based on their title or their description."
msgstr "允许搜索基于其标题或对它们的描述课程。"

#: ../../howtos/backend.rst:470 ../../howtos/website.rst:367
msgid "Relations between models"
msgstr "模型之间的关系"

#: ../../howtos/backend.rst:472
msgid ""
"A record from a model may be related to a record from another model. For "
"instance, a sale order record is related to a client record that contains "
"the client data; it is also related to its sale order line records."
msgstr "从模型的记录, 可能与从另一个模型的记录。例如, 一个销售订单记录是与一个包含客户端数据的客户记录;这也关系到其销售订单行记录。"

#: ../../howtos/backend.rst:476
msgid "Create a session model"
msgstr "创建一个会话模型"

#: ../../howtos/backend.rst:478
msgid ""
"For the module Open Academy, we consider a model for *sessions*: a session "
"is an occurrence of a course taught at a given time for a given audience."
msgstr "对于模块开放学院, 我们认为一款型号为 *会* :一个会话课程讲授在给定时间对给定观众的发生。"

#: ../../howtos/backend.rst:481
msgid ""
"Create a model for *sessions*. A session has a name, a start date, a "
"duration and a number of seats. Add an action and a menu item to display "
"them. Make the new model visible via a menu item."
msgstr "建立一个模型 *会* 。会话有一个名字, 开始日期, 持续时间和数量的席位。添加一个动作, 一个菜单项来显示它们。请通过菜单项的新模式可见。"

#: ../../howtos/backend.rst:487
msgid "Create the class *Session* in ``openacademy/models.py``."
msgstr "在 ``openacademy / models.py`` 创建类 *会话* 。"

#: ../../howtos/backend.rst:488
msgid ""
"Add access to the session object in ``openacademy/view/openacademy.xml``."
msgstr "添加访问会话对象中 ``openacademy /视图/ openacademy.xml`` 。"

#: ../../howtos/backend.rst:492
msgid ""
"``digits=(6, 2)`` specifies the precision of a float number: 6 is the total "
"number of digits, while 2 is the number of digits after the comma. Note that"
" it results in the number digits before the comma is a maximum 4"
msgstr " ``位数=（6, 2）`` 指定的一个浮点数精度:6是总位数, 而2是逗号后的位数。需要注意的是它导致号码数字逗号之前为最大4"

#: ../../howtos/backend.rst:498
msgid "Relational fields"
msgstr "关系字段"

#: ../../howtos/backend.rst:500
msgid ""
"Relational fields link records, either of the same model (hierarchies) or "
"between different models."
msgstr "关系字段的链接记录, 无论是同一型号（等级）或不同型号之间。"

#: ../../howtos/backend.rst:503
msgid "Relational field types are:"
msgstr "关系字段类型有 :"

#: ../../howtos/backend.rst:510
msgid ""
":class:`Many2one(other_model, ondelete='set null') "
"<openerp.fields.Many2one>`"
msgstr ":class:`Many2one（other_model, ondelete ='设置为空“）<openerp.fields.Many2one>` "

#: ../../howtos/backend.rst:506
msgid "A simple link to an other object::"
msgstr "到其他对象一个简单的链接 ::"

#: ../../howtos/backend.rst:510
msgid ""
"`foreign keys <http://www.postgresql.org/docs/9.3/static/tutorial-fk.html>`_"
msgstr "`外键 <http://www.postgresql.org/docs/9.3/static/tutorial-fk.html>`_"

#: ../../howtos/backend.rst:524
msgid ""
":class:`One2many(other_model, related_field) <openerp.fields.One2many>`"
msgstr ":class:`One2many(other_model, related_field) <openerp.fields.One2many>`"

#: ../../howtos/backend.rst:513
msgid ""
"A virtual relationship, inverse of a :class:`~openerp.fields.Many2one`. A "
":class:`~openerp.fields.One2many` behaves as a container of records, "
"accessing it results in a (possibly empty) set of records::"
msgstr "一个虚拟的关系, 一反 :class:`~openerp.fields.Many2one` 。答 :class:`~openerp.fields.One2many` 表现为记录的容器, 访问它导致（可能为空）的记录集 ::"

#: ../../howtos/backend.rst:522
msgid ""
"Because a :class:`~openerp.fields.One2many` is a virtual relationship, there"
" *must* be a :class:`~openerp.fields.Many2one` field in the "
":samp:`{other_model}`, and its name *must* be :samp:`{related_field}`"
msgstr "因为 :class:`~openerp.fields.One2many` 是一个虚拟的关系, 有 *必须* 是 :class:`~openerp.fields.Many2one` 字段中 :samp:`{other_model}` , 它的名字 *必须* 是 :samp:`{related_field}` "

#: ../../howtos/backend.rst:532
msgid ":class:`Many2many(other_model) <openerp.fields.Many2many>`"
msgstr ":class:`Many2many(other_model) <openerp.fields.Many2many>`"

#: ../../howtos/backend.rst:527
msgid ""
"Bidirectional multiple relationship, any record on one side can be related "
"to any number of records on the other side. Behaves as a container of "
"records, accessing it also results in a possibly empty set of records::"
msgstr "双向倍数关系, 在一侧上的任何记录可以与任何数量的在另一侧的记录。表现为记录一个容器, 访问它也导致一个可能是空的组记录 ::"

#: ../../howtos/backend.rst:534
msgid "Many2one relations"
msgstr "Many2one关系"

#: ../../howtos/backend.rst:536
msgid ""
"Using a many2one, modify the *Course* and *Session* models to reflect their "
"relation with other models:"
msgstr "使用many2one, 修改 *课程* 和 *会话* 模型, 以反映他们与其他型号的关系:"

#: ../../howtos/backend.rst:539
msgid ""
"A course has a *responsible* user; the value of that field is a record of "
"the built-in model ``res.users``."
msgstr "一个疗程有 *负责* 用户;该字段的值是内置的模型 ``res.users`` 的记录。"

#: ../../howtos/backend.rst:541
msgid ""
"A session has an *instructor*; the value of that field is a record of the "
"built-in model ``res.partner``."
msgstr "会话有一个 *教练* ;该字段的值是内置的模型 ``res.partner`` 的记录。"

#: ../../howtos/backend.rst:543
msgid ""
"A session is related to a *course*; the value of that field is a record of "
"the model ``openacademy.course`` and is required."
msgstr "会话涉及到 *课程* ;该字段的值是模型的 ``openacademy.course`` 的记录, 是必需的。"

#: ../../howtos/backend.rst:545
msgid "Adapt the views."
msgstr "适配视图。"

#: ../../howtos/backend.rst:549
msgid "Add the relevant ``Many2one`` fields to the models, and"
msgstr "有关 ``Many2one`` 字段添加到模型,"

#: ../../howtos/backend.rst:550
msgid "add them in the views."
msgstr "在视图中加入它们。"

#: ../../howtos/backend.rst:554
msgid "Inverse one2many relations"
msgstr "反向one2many关系"

#: ../../howtos/backend.rst:556
msgid ""
"Using the inverse relational field one2many, modify the models to reflect "
"the relation between courses and sessions."
msgstr "使用逆关系字段one2many, 修改模型, 以反映课程和会议之间的关系。"

#: ../../howtos/backend.rst:561
msgid "Modify the ``Course`` class, and"
msgstr "修改 ``Course`` 类,"

#: ../../howtos/backend.rst:562
msgid "add the field in the course form view."
msgstr "在使用过程中表单视图添加字段。"

#: ../../howtos/backend.rst:566
msgid "Multiple many2many relations"
msgstr "多重many2many关系"

#: ../../howtos/backend.rst:568
msgid ""
"Using the relational field many2many, modify the *Session* model to relate "
"every session to a set of *attendees*. Attendees will be represented by "
"partner records, so we will relate to the built-in model ``res.partner``. "
"Adapt the views accordingly."
msgstr "使用关系字段many2many, 修改 *会话* 模型的每一个会议涉及到一组 *与会者* 。与会者将通过合作伙伴的记录来表示, 因此我们将涉及到内置的模型 ``res.partner`` 。相应修改意见。"

#: ../../howtos/backend.rst:575
msgid "Modify the ``Session`` class, and"
msgstr "修改 ``Session`` 类,"

#: ../../howtos/backend.rst:576
msgid "add the field in the form view."
msgstr "在表单视图中添加字段。"

#: ../../howtos/backend.rst:581
msgid "Inheritance"
msgstr "继承"

#: ../../howtos/backend.rst:584
msgid "Model inheritance"
msgstr "模型继承"

#: ../../howtos/backend.rst:586
msgid ""
"Odoo provides two *inheritance* mechanisms to extend an existing model in a "
"modular way."
msgstr "Odoo提供了两个 **继承** 机制，以模块化的方式来扩展现有的模型。"

#: ../../howtos/backend.rst:589
msgid ""
"The first inheritance mechanism allows a module to modify the behavior of a "
"model defined in another module:"
msgstr "第一继承机制允许模块修改在另一个模块中定义的模型的行为:"

#: ../../howtos/backend.rst:592
msgid "add fields to a model,"
msgstr "字段添加到模型,"

#: ../../howtos/backend.rst:593
msgid "override the definition of fields on a model,"
msgstr "覆盖在模型字段的定义,"

#: ../../howtos/backend.rst:594
msgid "add constraints to a model,"
msgstr "添加约束到一个模型,"

#: ../../howtos/backend.rst:595
msgid "add methods to a model,"
msgstr "添加方法到模型,"

#: ../../howtos/backend.rst:596
msgid "override existing methods on a model."
msgstr "覆盖模型上已有的方法。"

#: ../../howtos/backend.rst:598
msgid ""
"The second inheritance mechanism (delegation) allows to link every record of"
" a model to a record in a parent model, and provides transparent access to "
"the fields of the parent record."
msgstr "第二个继承机制（委托）允许链接模型的每一个记录到父模型的记录, 提供对父记录的透明访问。"

#: ../../howtos/backend.rst:607
msgid ":attr:`~openerp.models.Model._inherit`"
msgstr ":attr:`~openerp.models.Model._inherit`"

#: ../../howtos/backend.rst:608
msgid ":attr:`~openerp.models.Model._inherits`"
msgstr ":attr:`~openerp.models.Model._inherits`"

#: ../../howtos/backend.rst:611
msgid "View inheritance"
msgstr "视图继承"

#: ../../howtos/backend.rst:613
msgid ""
"Instead of modifying existing views in place (by overwriting them), Odoo "
"provides view inheritance where children \"extension\" views are applied on "
"top of root views, and can add or remove content from their parent."
msgstr "而不是修改替代现有的意见（通过覆盖他们）的, Odoo提供了那里的儿童'扩展'的视图被应用在根本视图上, 可以添加或删除其父内容视图继承。"

#: ../../howtos/backend.rst:617
msgid ""
"An extension view references its parent using the ``inherit_id`` field, and "
"instead of a single view its ``arch`` field is composed of any number of "
"``xpath`` elements selecting and altering the content of their parent view:"
msgstr "使用 ``inherit_id`` 字段的扩展视图引用其父, 并代替单一视图的 ``arch`` 场由任意数量的 ``xpath`` 元件选择和改变其父视图的内容:"

#: ../../howtos/backend.rst:638
msgid "``expr``"
msgstr " ``expr`` "

#: ../../howtos/backend.rst:638
msgid ""
"An XPath_ expression selecting a single element in the parent view. Raises "
"an error if it matches no element or more than one"
msgstr "一个XPath_表情选择在父视图中的单个元素。引发错误, 如果它没有元素或多于一个的匹配"

#: ../../howtos/backend.rst:653
msgid "``position``"
msgstr " ``position`` "

#: ../../howtos/backend.rst:641
msgid "Operation to apply to the matched element:"
msgstr "操作, 以适用于匹配元素:"

#: ../../howtos/backend.rst:643
msgid "``inside``"
msgstr " ``inside`` "

#: ../../howtos/backend.rst:644
msgid "appends ``xpath``'s body at the end of the matched element"
msgstr "追加 ``在匹配元素的结束xpath`` 的身体"

#: ../../howtos/backend.rst:645
msgid "``replace``"
msgstr "``replace``"

#: ../../howtos/backend.rst:646
msgid "replaces the matched element by the ``xpath``'s body"
msgstr "由 ``xpath`` 的身体替换匹配元素"

#: ../../howtos/backend.rst:647
msgid "``before``"
msgstr " ``before`` "

#: ../../howtos/backend.rst:648
msgid "inserts the ``xpath``'s body as a sibling before the matched element"
msgstr "插入 ``xpath`` 的身体匹配的元素之前同级"

#: ../../howtos/backend.rst:649
msgid "``after``"
msgstr "``after``"

#: ../../howtos/backend.rst:650
msgid "inserts the ``xpaths``'s body as a sibling after the matched element"
msgstr "插入 ``xpaths`` 的身体作为匹配的元素后, 同级"

#: ../../howtos/backend.rst:653
msgid "``attributes``"
msgstr "``attributes``"

#: ../../howtos/backend.rst:652
msgid ""
"alters the attributes of the matched element using special ``attribute`` "
"elements in the ``xpath``'s body"
msgstr "改变匹配元素的使用特殊的 ``attribute`` 元素的属性在 ``xpath`` 的身体"

#: ../../howtos/backend.rst:657
msgid ""
"When matching a single element, the ``position`` attribute can be set "
"directly on the element to be found. Both inheritances below will give the "
"same result."
msgstr "When matching a single element, the ``position`` attribute can be set directly on the element to be found. Both inheritances below will give the same result."

#: ../../howtos/backend.rst:671
msgid "Alter existing content"
msgstr "改变现有内容"

#: ../../howtos/backend.rst:673
msgid ""
"Using model inheritance, modify the existing *Partner* model to add an "
"``instructor`` boolean field, and a many2many field that corresponds to the "
"session-partner relation"
msgstr "使用模型继承, 修改现有的 *合作伙伴* 模型添加一个 ``instructor`` 布尔字段, 以及对应于会话伙伴关系的many2many场"

#: ../../howtos/backend.rst:676
msgid "Using view inheritance, display this fields in the partner form view"
msgstr "使用视图继承,  在partner表单视图显示此字段"

#: ../../howtos/backend.rst:682
msgid ""
"This is the opportunity to introduce the developer mode to inspect the view,"
" find its external ID and the place to put the new field."
msgstr "这是机遇, 引进开发模式进行考察的视图, 发现其外部标识, 并把新的字段的地方。"

#: ../../howtos/backend.rst:686
msgid ""
"Create a file ``openacademy/partner.py`` and import it in ``__init__.py``"
msgstr "创建一个文件 ``openacademy / partner.py`` 并将其导入 ``__init __。py`` "

#: ../../howtos/backend.rst:688
msgid ""
"Create a file ``openacademy/views/partner.xml`` and add it to "
"``__openerp__.py``"
msgstr "创建一个文件 ``openacademy /视图/ partner.xml`` , 并把它添加到 ``__openerp __。py`` "

#: ../../howtos/backend.rst:694
msgid "Domains"
msgstr "域"

#: ../../howtos/backend.rst:696
msgid ""
"In Odoo, :ref:`reference/orm/domains` are values that encode conditions on "
"records. A domain is a  list of criteria used to select a subset of a "
"model's records. Each criteria is a triple with a field name, an operator "
"and a value."
msgstr "在Odoo, :ref:`reference/orm/domains` 了编码备案条件的值。域是用来选择模型的记录子集标准清单。每个标准是三与字段名称, 运算符和值。"

#: ../../howtos/backend.rst:700
msgid ""
"For instance, when used on the *Product* model the following domain selects "
"all *services* with a unit price over *1000*::"
msgstr "例如, 在 *产品* 模型中使用时, 下列域选择所有 *服务* 有单价超过 * 1000 * ::"

#: ../../howtos/backend.rst:705
msgid ""
"By default criteria are combined with an implicit AND. The logical operators"
" ``&`` (AND), ``|`` (OR) and ``!`` (NOT) can be used to explicitly combine "
"criteria. They are used in prefix position (the operator is inserted before "
"its arguments rather than between). For instance to select products \"which "
"are services *OR* have a unit price which is *NOT* between 1000 and 2000\"::"
msgstr "默认情况下标准相结合, 与含蓄蕴借的。逻辑运算符 ``＆`` （AND）, ``|`` （OR）和 ```` （NOT）可以用来显式地组合标准！它们被用在前缀位置（操作者插入之前它的参数, 而不是之间）。比如选择产品', 这是服务 *或* 有一个单价是 *不* 1000至2000'::"

#: ../../howtos/backend.rst:717
msgid ""
"A ``domain`` parameter can be added to relational fields to limit valid "
"records for the relation when trying to select records in the client "
"interface."
msgstr "``domain`` 参数可以添加到关系字段，用来在客户端界面选择记录时，为关系限制有效的记录。"

#: ../../howtos/backend.rst:720
msgid "Domains on relational fields"
msgstr "关系字段上的域"

#: ../../howtos/backend.rst:722
msgid ""
"When selecting the instructor for a *Session*, only instructors (partners "
"with ``instructor`` set to ``True``) should be visible."
msgstr "当为 *会话* 选择导师, 导师只（合作伙伴 ``instructor`` 设置值为 ``True`` ）应该是可见的。"

#: ../../howtos/backend.rst:731
msgid ""
"A domain declared as a literal list is evaluated server-side and can't refer"
" to dynamic values on the right-hand side, a domain declared as a string is "
"evaluated client-side and allows field names on the right-hand side"
msgstr "声明为文字列表的域的求服务器端和不能引用动态值在右侧, 一个域声明为一个字符串被评估的客户端, 并允许在右侧字段名"

#: ../../howtos/backend.rst:736
msgid "More complex domains"
msgstr "更复杂的域"

#: ../../howtos/backend.rst:738
msgid ""
"Create new partner categories *Teacher / Level 1* and *Teacher / Level 2*. "
"The instructor for a session can be either an instructor or a teacher (of "
"any level)."
msgstr "创建新的合作伙伴类别 *教师/ 1级* 和 *教师/ 2级* 。该讲师会话可以是一个教练或老师（任何级别）。"

#: ../../howtos/backend.rst:744
msgid "Modify the *Session* model's domain"
msgstr "修改 *会话* 模型的域"

#: ../../howtos/backend.rst:745
msgid ""
"Modify ``openacademy/view/partner.xml`` to get access to *Partner "
"categories*:"
msgstr "修改 ``openacademy /视图/ partner.xml`` 才能访问 *合作伙伴类别* :"

#: ../../howtos/backend.rst:751
msgid "Computed fields and default values"
msgstr "计算字段和默认值"

#: ../../howtos/backend.rst:753
msgid ""
"So far fields have been stored directly in and retrieved directly from the "
"database. Fields can also be *computed*. In that case, the field's value is "
"not retrieved from the database but computed on-the-fly by calling a method "
"of the model."
msgstr "到目前为止字段被直接存储在并直接从数据库中检索。字段也可以 *计算* 。在这种情况下, 该字段的值不从数据库检索, 但通过调用模型的方法来计算关于即时。"

#: ../../howtos/backend.rst:758
msgid ""
"To create a computed field, create a field and set its attribute "
":attr:`~openerp.fields.Field.compute` to the name of a method. The "
"computation method should simply set the value of the field to compute on "
"every record in ``self``."
msgstr "要创建一个计算字段, 创建一个字段并设置其属性 :attr:`~openerp.fields.Field.compute` 一个方法的名称。该计算方法应该简单地设置字段的值来计算在 ``self`` 每个记录。"

#: ../../howtos/backend.rst:763
msgid "``self`` is a collection"
msgstr " ``self`` 是一家集合"

#: ../../howtos/backend.rst:766
msgid ""
"The object ``self`` is a *recordset*, i.e., an ordered collection of "
"records. It supports the standard Python operations on collections, like "
"``len(self)`` and ``iter(self)``, plus extra set operations like ``recs1 + "
"recs2``."
msgstr "对象 ``self`` 是 *记录* , 即记录的有序集合。它支持对收藏品的标准Python操作, 比如像 ``recs1 + recs2````len个（个体经营）`` 和 ``ITER（个体经营）`` , 再加上额外的设置操作。"

#: ../../howtos/backend.rst:771
msgid ""
"Iterating over ``self`` gives the records one by one, where each record is "
"itself a collection of size 1. You can access/assign fields on single "
"records by using the dot notation, like ``record.name``."
msgstr "迭代 ``self`` 给人的记录一个接一个, 其中每个记录本身尺寸1.集合您可以访问/使用点符号分配在单记录中的字段, 如 ``record.name`` 。"

#: ../../howtos/backend.rst:792
msgid "Dependencies"
msgstr "依赖"

#: ../../howtos/backend.rst:794
msgid ""
"The value of a computed field usually depends on the values of other fields "
"on the computed record. The ORM expects the developer to specify those "
"dependencies on the compute method with the decorator "
":func:`~openerp.api.depends`. The given dependencies are used by the ORM to "
"trigger the recomputation of the field whenever some of its dependencies "
"have been modified::"
msgstr "一个计算字段的值通常取决于所计算的记录的其他字段的值。在ORM希望开发人员指定在与装饰计算方法的相关性 :func:`~openerp.api.depends` 。给定的依赖关系所使用的ORM触发字段的重新计算每当它的一些依赖已被修改 ::"

#: ../../howtos/backend.rst:813
msgid "Computed fields"
msgstr "计算字段"

#: ../../howtos/backend.rst:815
msgid "Add the percentage of taken seats to the *Session* model"
msgstr "加入所采取的席位比例为 *会话* 模型"

#: ../../howtos/backend.rst:816
msgid "Display that field in the tree and form views"
msgstr "显示该字段中的树, 并形成意见"

#: ../../howtos/backend.rst:817
msgid "Display the field as a progress bar"
msgstr "将字段作为进度条显示"

#: ../../howtos/backend.rst:821
msgid "Add a computed field to *Session*"
msgstr "添加一个计算字段 *会话*"

#: ../../howtos/backend.rst:822
msgid "Show the field in the *Session* view:"
msgstr "显示字段中的 *会话* 看法:"

#: ../../howtos/backend.rst:827
msgid "Default values"
msgstr "默认值"

#: ../../howtos/backend.rst:829
msgid ""
"Any field can be given a default value. In the field definition, add the "
"option ``default=X`` where ``X`` is either a Python literal value (boolean, "
"integer, float, string), or a function taking a recordset and returning a "
"value::"
msgstr "任何字段可以给出一个默认值。在字段定义, 添加选项  ``default=X`` ， 其中 ``X`` 要么是一个Python的文字值（布尔, 整数, 浮点数, 字符串）, 要么是一个函数，取一个记录或返回一个值 ::"

#: ../../howtos/backend.rst:838
msgid ""
"The object ``self.env`` gives access to request parameters and other useful "
"things:"
msgstr "对象 ``self.env`` 可以访问请求参数和其他有用的东西:"

#: ../../howtos/backend.rst:841
msgid ""
"``self.env.cr`` or ``self._cr`` is the database *cursor* object; it is used "
"for querying the database"
msgstr " ``self.env.cr`` 或 ``self._cr`` 是数据库 *光标* 对象;它是用于查询数据库"

#: ../../howtos/backend.rst:843
msgid "``self.env.uid`` or ``self._uid`` is the current user's database id"
msgstr " ``self.env.uid`` 或 ``self._uid`` 是当前用户的数据库ID"

#: ../../howtos/backend.rst:844
msgid "``self.env.user`` is the current user's record"
msgstr " ``self.env.user`` 是当前用户的记录"

#: ../../howtos/backend.rst:845
msgid "``self.env.context`` or ``self._context`` is the context dictionary"
msgstr " ``self.env.context`` 或 ``self._context`` 是上下文字典"

#: ../../howtos/backend.rst:846
msgid "``self.env.ref(xml_id)`` returns the record corresponding to an XML id"
msgstr "``self.env.ref(xml_id)`` 返回一个XML ID对应的记录"

#: ../../howtos/backend.rst:847
msgid "``self.env[model_name]`` returns an instance of the given model"
msgstr " ``self.env [MODEL_NAME]`` 返回给定模型的实例"

#: ../../howtos/backend.rst:849
msgid "Active objects – Default values"
msgstr "活动对象 - 默认值"

#: ../../howtos/backend.rst:851
msgid ""
"Define the start_date default value as today (see "
":class:`~openerp.fields.Date`)."
msgstr "定义 start_date 默认值为今天 (see :class:`~openerp.fields.Date`)."

#: ../../howtos/backend.rst:853
msgid ""
"Add a field ``active`` in the class Session, and set sessions as active by "
"default."
msgstr "添加一个字段 ``active`` 在上课, 并默认设置会为活动。"

#: ../../howtos/backend.rst:862
msgid ""
"Odoo has built-in rules making fields with an ``active`` field set to "
"``False`` invisible."
msgstr "Odoo有 ``False`` 隐形内置的规则制定与 ``active`` 字段集的字段。"

#: ../../howtos/backend.rst:866
msgid "Onchange"
msgstr "Onchange"

#: ../../howtos/backend.rst:868
msgid ""
"The \"onchange\" mechanism provides a way for the client interface to update"
" a form whenever the user has filled in a value in a field, without saving "
"anything to the database."
msgstr "所述'的onchange'机制提供了一种用于在客户端接口来更新的一种形式, 每当用户已填充在一个字段中的值, 而不保存任何东西到数据库。"

#: ../../howtos/backend.rst:872
msgid ""
"For instance, suppose a model has three fields ``amount``, ``unit_price`` "
"and ``price``, and you want to update the price on the form when any of the "
"other fields is modified. To achieve this, define a method where ``self`` "
"represents the record in the form view, and decorate it with "
":func:`~openerp.api.onchange` to specify on which field it has to be "
"triggered. Any change you make on ``self`` will be reflected on the form."
msgstr "例如, 假设一个模型有三个字段 ``amount`` , ``unit_price`` 和 ``price`` , 以及要更新的价格表上, 当其他任何字段的修改。为了实现这一目标, 定义在那里 ``self`` 代表在表单视图记录的方法, 并与装饰它 :func:`~openerp.api.onchange` 指定在其字段它必须被触发。你所做的任何变化对 ``self`` 将反映在表格上。"

#: ../../howtos/backend.rst:901
msgid ""
"For computed fields, valued ``onchange`` behavior is built-in as can be seen"
" by playing with the *Session* form: change the number of seats or "
"participants, and the ``taken_seats`` progressbar is automatically updated."
msgstr "对于计算字段, 价值 ``onchange`` 行为是内置的可以通过与 *会话* 形式播放中可以看出:改变座位或参与者的数量和 ``taken_seats`` 进度会自动更新。"

#: ../../howtos/backend.rst:905
msgid "Warning"
msgstr "警示"

#: ../../howtos/backend.rst:907
msgid ""
"Add an explicit onchange to warn about invalid values, like a negative "
"number of seats, or more participants than seats."
msgstr "添加一个明确的onchange来发出警告无效的值, 像一个负数的座位, 或更多的参与者比座位。"

#: ../../howtos/backend.rst:915
msgid "Model constraints"
msgstr "模型的约束"

#: ../../howtos/backend.rst:917
msgid ""
"Odoo provides two ways to set up automatically verified invariants: "
":func:`Python constraints <openerp.api.constrains>` and :attr:`SQL "
"constraints <openerp.models.Model._sql_constraints>`."
msgstr "Odoo提供了两种方法来设置自动验证不变量: :func:`Python的限制<openerp.api.constrains>` 和 :attr:`SQL约束<openerp.models.Model._sql_constraints>` 。"

#: ../../howtos/backend.rst:921
msgid ""
"A Python constraint is defined as a method decorated with "
":func:`~openerp.api.constrains`, and invoked on a recordset. The decorator "
"specifies which fields are involved in the constraint, so that the "
"constraint is automatically evaluated when one of them is modified. The "
"method is expected to raise an exception if its invariant is not satisfied::"
msgstr "一个Python约束被定义为一种方法装饰有 :func:`~openerp.api.constrains` , 并在记录调用。装饰指定哪些字段涉及的约束, 这样, 当其中的一个被修改的约束被自动评估。该方法有望引发异常, 如果它的不变不满意 ::"

#: ../../howtos/backend.rst:936
msgid "Add Python constraints"
msgstr "加入Python的限制"

#: ../../howtos/backend.rst:938
msgid ""
"Add a constraint that checks that the instructor is not present in the "
"attendees of his/her own session."
msgstr "补充一下, 检查该教师没有出现在他/她自己的会议的与会者的约束。"

#: ../../howtos/backend.rst:945
msgid ""
"SQL constraints are defined through the model attribute "
":attr:`~openerp.models.Model._sql_constraints`. The latter is assigned to a "
"list of triples of strings ``(name, sql_definition, message)``, where "
"``name`` is a valid SQL constraint name, ``sql_definition`` is a "
"table_constraint_ expression, and ``message`` is the error message."
msgstr ":attr: SQL约束是通过模型属性定义的 `~openerp.models.Model._sql_constraints` 。后者被分配到串 ``（姓名, sql_definition, 消息）`` , 在那里 ``name`` 是一个有效的SQL约束名的三元组的列表, ``sql_definition`` 是一个table_constraint_表达, ``消息`` 是错误消息。"

#: ../../howtos/backend.rst:951
msgid "Add SQL constraints"
msgstr "加入SQL约束"

#: ../../howtos/backend.rst:953
msgid ""
"With the help of `PostgreSQL's documentation`_ , add the following "
"constraints:"
msgstr "随着 `PostgreSQL的documentation` _的帮助下, 添加以下限制:"

#: ../../howtos/backend.rst:956
msgid "CHECK that the course description and the course title are different"
msgstr "检查过程描述和课程名称不同"

#: ../../howtos/backend.rst:957
msgid "Make the Course's name UNIQUE"
msgstr "使课程的名称唯一"

#: ../../howtos/backend.rst:963
msgid "Exercise 6 - Add a duplicate option"
msgstr "练习6 - 添加一个重复的选项"

#: ../../howtos/backend.rst:965
msgid ""
"Since we added a constraint for the Course name uniqueness, it is not "
"possible to use the \"duplicate\" function anymore (:menuselection:`Form -->"
" Duplicate`)."
msgstr "由于我们增加了课程名称唯一性的约束, 就不可能使用'重复'功能了（ :menuselection:`表 - > Duplicate` ）。"

#: ../../howtos/backend.rst:969
msgid ""
"Re-implement your own \"copy\" method which allows to duplicate the Course "
"object, changing the original name into \"Copy of [original name]\"."
msgstr "重新实现自己的'复制'的方法, 它允许复制的课程目标, 改变了原来的名称为'[原名]的复制'。"

#: ../../howtos/backend.rst:977
msgid "Advanced Views"
msgstr "高级视图"

#: ../../howtos/backend.rst:982
msgid ""
"Tree views can take supplementary attributes to further customize their "
"behavior:"
msgstr "树视图可以采取辅助属性进一步自定义其行为:"

#: ../../howtos/backend.rst:1006
msgid "``decoration-{$name}``"
msgstr " ``decoration-{$name}`` "

#: ../../howtos/backend.rst:986
msgid ""
"allow changing the style of a row's text based on the corresponding record's"
" attributes."
msgstr "允许更改行的文本的基础上, 相应的记录的属性的风格。"

#: ../../howtos/backend.rst:989
msgid ""
"Values are Python expressions. For each record, the expression is evaluated "
"with the record's attributes as context values and if ``true``, the "
"corresponding style is applied to the row. Other context values are ``uid`` "
"(the id of the current user) and ``current_date`` (the current date as a "
"string of the form ``yyyy-MM-dd``)."
msgstr "值是Python表达式。对于每一个记录, 表达式的值与记录的属性为背景值, 如果 ``True`` , 那么相应的样式应用到该行。其他情况下的值是 ``uid`` （当前用户的ID）和 ``current_date`` （当前日期的形式 ``YYYY-MM-dd`` 的字符串）。"

#: ../../howtos/backend.rst:995
msgid ""
"``{$name}`` can be ``bf`` (``font-weight: bold``), ``it`` (``font-style: "
"italic``), or any `bootstrap contextual color "
"<http://getbootstrap.com/components/#available-variations>`_ (``danger``, "
"``info``, ``muted``, ``primary``, ``success`` or ``warning``)."
msgstr "``{$name}`` can be ``bf`` (``font-weight: bold``), ``it`` (``font-style: italic``), or any `bootstrap contextual color <http://getbootstrap.com/components/#available-variations>`_ (``danger``, ``info``, ``muted``, ``primary``, ``success`` or ``warning``)."

#: ../../howtos/backend.rst:1011
msgid "``editable``"
msgstr " ``editable`` "

#: ../../howtos/backend.rst:1009
msgid ""
"Either ``\"top\"`` or ``\"bottom\"``. Makes the tree view editable in-place "
"(rather than having to go through the form view), the value is the position "
"where new rows appear."
msgstr "无论是 ``'顶'`` 或 ``'下'`` 。使树视图编辑就地（而不是去通过表格视图）, 这个值就是新行出现的位置。"

#: ../../howtos/backend.rst:1013
msgid "List coloring"
msgstr "列表着色"

#: ../../howtos/backend.rst:1015
msgid ""
"Modify the Session tree view in such a way that sessions lasting less than 5"
" days are colored blue, and the ones lasting more than 15 days are colored "
"red."
msgstr "修改会话树视图中的会话持续时间少于5天蓝色这样的方式, 和那些持续15天以上为红色。"

#: ../../howtos/backend.rst:1021
msgid "Modify the session tree view:"
msgstr "修改会话树状视图:"

#: ../../howtos/backend.rst:1026
msgid "Calendars"
msgstr "日历"

#: ../../howtos/backend.rst:1028
msgid ""
"Displays records as calendar events. Their root element is ``<calendar>`` "
"and their most common attributes are:"
msgstr "显示记录为日历活动. 根元素是 ``<calendar>`` 以及他们大多数共用的属性有 :"

#: ../../howtos/backend.rst:1034
msgid "``color``"
msgstr " ``color`` "

#: ../../howtos/backend.rst:1032
msgid ""
"The name of the field used for *color segmentation*. Colors are "
"automatically distributed to events, but events in the same color segment "
"(records which have the same value for their ``@color`` field) will be given"
" the same color."
msgstr "中使用的字段的名称 *颜色分割* 。颜色被自动分发到的事件, 但在相同的颜色段的事件（其对他们的 ``@ color`` 字段相同的值的记录）将被给予相同的颜色。"

#: ../../howtos/backend.rst:1036
msgid "``date_start``"
msgstr " ``date_start`` "

#: ../../howtos/backend.rst:1037
msgid "record's field holding the start date/time for the event"
msgstr "记录的字段持有活动的开始日期/时间"

#: ../../howtos/backend.rst:1039
msgid "``date_stop`` (optional)"
msgstr " ``date_stop`` (可选)"

#: ../../howtos/backend.rst:1039
msgid "record's field holding the end date/time for the event"
msgstr "记录的字段持有活动的结束日期/时间"

#: ../../howtos/backend.rst:1041
msgid "field (to define the label for each calendar event)"
msgstr "字段（定义标签为每个日历事件）"

#: ../../howtos/backend.rst:1049
msgid "Calendar view"
msgstr "日历视图"

#: ../../howtos/backend.rst:1051
msgid ""
"Add a Calendar view to the *Session* model enabling the user to view the "
"events associated to the Open Academy."
msgstr "添加日历视图的 **会话模型使用户能够查看关联到打开科学院的事件。"

#: ../../howtos/backend.rst:1056
msgid ""
"Add an ``end_date`` field computed from ``start_date`` and ``duration``"
msgstr "添加 ``end_date`` 字段从计算 ``start_date`` 和 ``duration`` "

#: ../../howtos/backend.rst:1059
msgid ""
"the inverse function makes the field writable, and allows moving the "
"sessions (via drag and drop) in the calendar view"
msgstr "相反的功能, 使现场可写, 并允许（通过拖放）在日历视图中移动会议"

#: ../../howtos/backend.rst:1062
msgid "Add a calendar view to the *Session* model"
msgstr "添加日历视图的 *会话* 模型"

#: ../../howtos/backend.rst:1063
msgid "And add the calendar view to the *Session* model's actions"
msgstr "并添加日历视图到 *会话* 模型的行动"

#: ../../howtos/backend.rst:1070
msgid ""
"Search view ``<field>`` elements can have a ``@filter_domain`` that "
"overrides the domain generated for searching on the given field. In the "
"given domain, ``self`` represents the value entered by the user. In the "
"example below, it is used to search on both fields ``name`` and "
"``description``."
msgstr "Search view ``<field>`` elements can have a ``@filter_domain`` that overrides the domain generated for searching on the given field. In the given domain, ``self`` represents the value entered by the user. In the example below, it is used to search on both fields ``name`` and ``description`` ."

#: ../../howtos/backend.rst:1075
msgid ""
"Search views can also contain ``<filter>`` elements, which act as toggles "
"for predefined searches. Filters must have one of the following attributes:"
msgstr "Search views can also contain ``<filter>`` elements, which act as toggles for predefined searches. Filters must have one of the following attributes :"

#: ../../howtos/backend.rst:1078
msgid "``domain``"
msgstr "``domain``"

#: ../../howtos/backend.rst:1079
msgid "add the given domain to the current search"
msgstr "给定域添加到当前搜索"

#: ../../howtos/backend.rst:1082 ../../howtos/web.rst:1703
msgid "``context``"
msgstr " ``context`` "

#: ../../howtos/backend.rst:1081
msgid ""
"add some context to the current search; use the key ``group_by`` to group "
"results on the given field name"
msgstr "添加一些上下文当前的搜索;使用密钥 ``group_by`` 分组结果在给定的字段名"

#: ../../howtos/backend.rst:1101
msgid ""
"To use a non-default search view in an action, it should be linked using the"
" ``search_view_id`` field of the action record."
msgstr "要在操作使用非默认的搜索来看, 它应该使用动作记录的 ``search_view_id`` 域链接。"

#: ../../howtos/backend.rst:1104
msgid ""
"The action can also set default values for search fields through its "
"``context`` field: context keys of the form "
":samp:`search_default_{field_name}` will initialize *field_name* with the "
"provided value. Search filters must have an optional ``@name`` to have a "
"default and behave as booleans (they can only be enabled by default)."
msgstr "表格的背景下键 :samp: 该动作也可以通过它的 ``context`` 字段设置为搜索字段的默认值 `search_default_ {FIELD_NAME}` 将初始化 **FIELD_NAME与所提供的价值。搜索过滤器必须有一个可选的 ``@ name`` 有一个默认值, 表现为布尔（只能默认启用）。"

#: ../../howtos/backend.rst:1112
msgid ""
"Add a button to filter the courses for which the current user is the "
"responsible in the course search view. Make it selected by default."
msgstr "添加一个按钮来过滤为当前用户是负责在使用过程中搜索视图的课程。使它成为默认选项。"

#: ../../howtos/backend.rst:1114
msgid "Add a button to group courses by responsible user."
msgstr "负责用户添加一个按钮组的课程。"

#: ../../howtos/backend.rst:1121
msgid "Gantt"
msgstr "甘特"

#: ../../howtos/backend.rst:1123
msgid ""
"Horizontal bar charts typically used to show project planning and "
"advancement, their root element is ``<gantt>``."
msgstr "Horizontal bar charts typically used to show project planning and advancement, their root element is ``<gantt>`` ."

#: ../../howtos/backend.rst:1134
msgid "Gantt charts"
msgstr "甘特图"

#: ../../howtos/backend.rst:1136
msgid ""
"Add a Gantt Chart enabling the user to view the sessions scheduling linked "
"to the Open Academy module. The sessions should be grouped by instructor."
msgstr "添加甘特图使用户能够查看会议计划联系到开放学院模块。该会议应该由教师进行分组。"

#: ../../howtos/backend.rst:1141
msgid "Create a computed field expressing the session's duration in hours"
msgstr "创建一个计算字段表示以小时为单位的会话持续时间"

#: ../../howtos/backend.rst:1142
msgid ""
"Add the gantt view's definition, and add the gantt view to the *Session* "
"model's action"
msgstr "添加甘特图视图的定义, 和甘特视图添加到 *会话* 模型的行动"

#: ../../howtos/backend.rst:1148
msgid "Graph views"
msgstr "图形视图"

#: ../../howtos/backend.rst:1150
msgid ""
"Graph views allow aggregated overview and analysis of models, their root "
"element is ``<graph>``."
msgstr "Graph views allow aggregated overview and analysis of models, their root element is ``<graph>`` ."

#: ../../howtos/backend.rst:1154
msgid ""
"Pivot views (element ``<pivot>``) a multidimensional table, allows the "
"selection of filers and dimensions to get the right aggregated dataset "
"before moving to a more graphical overview. The pivot view shares the same "
"content definition as graph views."
msgstr "Pivot views (element ``<pivot>``) a multidimensional table, allows the selection of filers and dimensions to get the right aggregated dataset before moving to a more graphical overview. The pivot view shares the same content definition as graph views."

#: ../../howtos/backend.rst:1159
msgid ""
"Graph views have 4 display modes, the default mode is selected using the "
"``@type`` attribute."
msgstr "图形视图有4个显示模式, 默认模式是使用 ``@ type`` 属性选定。"

#: ../../howtos/backend.rst:1166
msgid "Bar (default)"
msgstr "栏（默认）"

#: ../../howtos/backend.rst:1163
msgid ""
"a bar chart, the first dimension is used to define groups on the horizontal "
"axis, other dimensions define aggregated bars within each group."
msgstr "条形图, 第一维是用来定义在横轴上基, 其它尺寸确定每个组内的凝集条。"

#: ../../howtos/backend.rst:1166
msgid ""
"By default bars are side-by-side, they can be stacked by using "
"``@stacked=\"True\"`` on the ``<graph>``"
msgstr "By default bars are side-by-side, they can be stacked by using ``@stacked=`` True ```` on the ``<graph>`` "

#: ../../howtos/backend.rst:1168
msgid "Line"
msgstr "线条"

#: ../../howtos/backend.rst:1169
msgid "2-dimensional line chart"
msgstr "2维线图"

#: ../../howtos/backend.rst:1171
msgid "Pie"
msgstr "饼图"

#: ../../howtos/backend.rst:1171
msgid "2-dimensional pie"
msgstr "2维饼图"

#: ../../howtos/backend.rst:1173
msgid ""
"Graph views contain ``<field>`` with a mandatory ``@type`` attribute taking "
"the values:"
msgstr "Graph views contain ``<field>`` with a mandatory ``@type`` attribute taking the values :"

#: ../../howtos/backend.rst:1176
msgid "``row`` (default)"
msgstr " ``row`` （默认）"

#: ../../howtos/backend.rst:1177
msgid "the field should be aggregated by default"
msgstr "现场默认情况下应汇总"

#: ../../howtos/backend.rst:1179
msgid "``measure``"
msgstr " ``measure`` "

#: ../../howtos/backend.rst:1179
msgid "the field should be aggregated rather than grouped on"
msgstr "该字段应该聚集, 而不是分组上"

#: ../../howtos/backend.rst:1190
msgid ""
"Graph views perform aggregations on database values, they do not work with "
"non-stored computed fields."
msgstr "图形视图上执行数据库值聚合, 它们不与非存储计算字段的工作。"

#: ../../howtos/backend.rst:1193
msgid "Graph view"
msgstr "图形视图"

#: ../../howtos/backend.rst:1195
msgid ""
"Add a Graph view in the Session object that displays, for each course, the "
"number of attendees under the form of a bar chart."
msgstr "添加图表视图中显示的Session对象, 为每门课程, 出席人数柱状图的形式下。"

#: ../../howtos/backend.rst:1200
msgid "Add the number of attendees as a stored computed field"
msgstr "添加出席人数为一个存储计算场"

#: ../../howtos/backend.rst:1201
msgid "Then add the relevant view"
msgstr "然后添加相关的视图"

#: ../../howtos/backend.rst:1206
msgid "Kanban"
msgstr "看板"

#: ../../howtos/backend.rst:1208
msgid ""
"Used to organize tasks, production processes, etc… their root element is "
"``<kanban>``."
msgstr "Used to organize tasks, production processes, etc… their root element is ``<kanban>`` ."

#: ../../howtos/backend.rst:1211
msgid ""
"A kanban view shows a set of cards possibly grouped in columns. Each card "
"represents a record, and each column the values of an aggregation field."
msgstr "看板视图显示了一组卡可能分组列。每张卡片代表一个记录, 每一列的聚集字段的值。"

#: ../../howtos/backend.rst:1214
msgid ""
"For instance, project tasks may be organized by stage (each column is a "
"stage), or by responsible (each column is a user), and so on."
msgstr "例如, 项目任务可以由阶段组织（每列是一个阶段）, 或者由负责（各列是一个用户）, 等等。"

#: ../../howtos/backend.rst:1217
msgid ""
"Kanban views define the structure of each card as a mix of form elements "
"(including basic HTML) and :ref:`reference/qweb`."
msgstr "看板视图定义每张卡片的结构为表单元素（包括基本的HTML）和 :ref:`reference/qweb` 的混合 。"

#: ../../howtos/backend.rst:1220
msgid "Kanban view"
msgstr "看板视图"

#: ../../howtos/backend.rst:1222
msgid ""
"Add a Kanban view that displays sessions grouped by course (columns are thus"
" courses)."
msgstr "添加看板视图显示按课程分组会议（列这样的课程）。"

#: ../../howtos/backend.rst:1227
msgid "Add an integer ``color`` field to the *Session* model"
msgstr "添加一个整数 ``color`` 外地来的 *会话* 模型"

#: ../../howtos/backend.rst:1228
msgid "Add the kanban view and update the action"
msgstr "添加看板查看，并更新​​动作"

#: ../../howtos/backend.rst:1233
msgid "Workflows"
msgstr "工作流程"

#: ../../howtos/backend.rst:1235
msgid ""
"Workflows are models associated to business objects describing their "
"dynamics. Workflows are also used to track processes that evolve over time."
msgstr "工作流是相关的描述它们的动态业务对象模型。工作流也用于跟踪随时间演变的过程。"

#: ../../howtos/backend.rst:1238
msgid "Almost a workflow"
msgstr "几乎一个工作流程"

#: ../../howtos/backend.rst:1240
msgid ""
"Add a ``state`` field to the *Session* model. It will be used to define a "
"workflow-ish."
msgstr "添加了 ``state`` 外地来的 *会话* 模式。它将被用于定义工作流的杂交。"

#: ../../howtos/backend.rst:1243
msgid ""
"A sesion can have three possible states: Draft (default), Confirmed and "
"Done."
msgstr "一个使sesion可以有三种可能的状态:草案（默认）, 确认和完成。"

#: ../../howtos/backend.rst:1246
msgid ""
"In the session form, add a (read-only) field to visualize the state, and "
"buttons to change it. The valid transitions are:"
msgstr "在会议的形式, 添加（只读）字段以可视化的状态, 和按钮进行更改。有效的转换是:"

#: ../../howtos/backend.rst:1249
msgid "Draft -> Confirmed"
msgstr "草案 - >确认"

#: ../../howtos/backend.rst:1250
msgid "Confirmed -> Draft"
msgstr "确认 - >草案"

#: ../../howtos/backend.rst:1251
msgid "Confirmed -> Done"
msgstr "确认 - >完成"

#: ../../howtos/backend.rst:1252
msgid "Done -> Draft"
msgstr "完成 - >草案"

#: ../../howtos/backend.rst:1256
msgid "Add a new ``state`` field"
msgstr "添加一个新的 ``state`` 场"

#: ../../howtos/backend.rst:1257
msgid ""
"Add state-transitioning methods, those can be called from view buttons to "
"change the record's state"
msgstr "加入国家过渡的方法, 这些可以从视图按钮调用来更改记录的状态"

#: ../../howtos/backend.rst:1259
msgid "And add the relevant buttons to the session's form view"
msgstr "并添加相关按钮会话的形式查看"

#: ../../howtos/backend.rst:1263
msgid ""
"Workflows may be associated with any object in Odoo, and are entirely "
"customizable. Workflows are used to structure and manage the lifecycles of "
"business objects and documents, and define transitions, triggers, etc. with "
"graphical tools. Workflows, activities (nodes or actions) and transitions "
"(conditions) are declared as XML records, as usual. The tokens that navigate"
" in workflows are called workitems."
msgstr "工作流可以与在Odoo任何对象相关联, 并且是完全可定制的。工作流是用于构建和管理业务对象和文档的生命周期, 并用图形化工具定义的转换, 触发器等。工作流, 活动（节点或操作）和转换（条件）被声明为XML记录, 像往常一样。该导航在工作流中的标记被称为工作项目。"

#: ../../howtos/backend.rst:1272
msgid ""
"A workflow associated with a model is only created when the model's records "
"are created. Thus there is no workflow instance associated with session "
"instances created before the workflow's definition"
msgstr "与模型相关联的工作流程创建模型的记录时才会产生。因此存在与工作流的定义之前创建的会话实例关联没有工作流实例"

#: ../../howtos/backend.rst:1277
msgid "Workflow"
msgstr "流程"

#: ../../howtos/backend.rst:1279
msgid ""
"Replace the ad-hoc *Session* workflow by a real workflow. Transform the "
"*Session* form view so its buttons call the workflow instead of the model's "
"methods."
msgstr "通过实际的工作流程更换特设 *会话* 工作流程。变换 *会话* 表单视图放在其按钮调用工作流, 而不是模型的方法。"

#: ../../howtos/backend.rst:1289
msgid ""
"In order to check if instances of the workflow are correctly created "
"alongside sessions, go to :menuselection:`Settings --> Technical --> "
"Workflows --> Instances`"
msgstr "为了检查工作流实例的旁边会正确创建, 请访问 :menuselection:`设置 - >技术 - >工作流 - > Instances` "

#: ../../howtos/backend.rst:1295
msgid "Automatic transitions"
msgstr "自动转换"

#: ../../howtos/backend.rst:1297
msgid ""
"Automatically transition sessions from *Draft* to *Confirmed* when more than"
" half the session's seats are reserved."
msgstr "从 **草稿自动转换会话 *确认* 过半时会话的份儿。"

#: ../../howtos/backend.rst:1304
msgid "Server actions"
msgstr "服务器动作"

#: ../../howtos/backend.rst:1306
msgid ""
"Replace the Python methods for synchronizing session state by server "
"actions."
msgstr "更换Python的方法, 由服务器操作同步会话状态。"

#: ../../howtos/backend.rst:1309
msgid ""
"Both the workflow and the server actions could have been created entirely "
"from the UI."
msgstr "两个工作流和服务器的行动可能已经从UI创建完全。"

#: ../../howtos/backend.rst:1317
msgid "Security"
msgstr "安全"

#: ../../howtos/backend.rst:1319
msgid ""
"Access control mechanisms must be configured to achieve a coherent security "
"policy."
msgstr "访问控制机制必须被配置为实现一个连贯的安全策略。"

#: ../../howtos/backend.rst:1323
msgid "Group-based access control mechanisms"
msgstr "基于组的访问控制机制"

#: ../../howtos/backend.rst:1325
msgid ""
"Groups are created as normal records on the model ``res.groups``, and "
"granted menu access via menu definitions. However even without a menu, "
"objects may still be accessible indirectly, so actual object-level "
"permissions (read, write, create, unlink) must be defined for groups. They "
"are usually inserted via CSV files inside modules. It is also possible to "
"restrict access to specific fields on a view or object using the field's "
"groups attribute."
msgstr "组创建为型号 ``res.groups`` , 并授予访问菜单, 通过菜单定义正常的记录。然而即使没有菜单, 对象可能仍然可以访问间接, 因此实际的对象级权限（读, 写, 创建, 取消链接）必须为基团被定义。它们通过内部模块CSV文件通常插入。它也可以限制对特定字段上的视图或使用该字段的群体属性对象。"

#: ../../howtos/backend.rst:1333
msgid "Access rights"
msgstr "访问权限"

#: ../../howtos/backend.rst:1335
msgid ""
"Access rights are defined as records of the model ``ir.model.access``. Each "
"access right is associated to a model, a group (or no group for global "
"access), and a set of permissions: read, write, create, unlink. Such access "
"rights are usually created by a CSV file named after its model: "
"``ir.model.access.csv``."
msgstr "访问权被定义为模型 ``ir.model.access`` 的记录。每个访问权限被关联到一个模型, 一组（或任何集团全球访问）, 以及一组权限:读, 写, 创建, 断开链接。 ``ir.model.access.csv`` :通常是由它的型号命名的CSV文件中创建这种访问权限。"

#: ../../howtos/backend.rst:1347
msgid "Add access control through the OpenERP interface"
msgstr "通过OpenERP的接口添加访问控制"

#: ../../howtos/backend.rst:1349
msgid ""
"Create a new user \"John Smith\". Then create a group \"OpenAcademy / "
"Session Read\" with read access to the *Session* model."
msgstr "创建一个新用户'约翰·史密斯'。然后创建一个组'OpenAcademy /会话阅读'用的 *会话* 模型读取权限。"

#: ../../howtos/backend.rst:1354
msgid ""
"Create a new user *John Smith* through :menuselection:`Settings --> Users "
"--> Users`"
msgstr "创建一个新用户 *约翰·史密斯* 通过 :menuselection:`设置 - >用户 - >雇员` "

#: ../../howtos/backend.rst:1356
msgid ""
"Create a new group ``session_read`` through :menuselection:`Settings --> "
"Users --> Groups`, it should have read access on the *Session* model"
msgstr "创建新组 ``session_read`` 通过 :menuselection:`设置 - >用户 - >上的 *会话* 模型Groups` , 它应该具有读取权限"

#: ../../howtos/backend.rst:1359
msgid "Edit *John Smith* to make them a member of ``session_read``"
msgstr "编辑 *约翰·史密斯* , 使他们的 ``session_read`` 成员"

#: ../../howtos/backend.rst:1360
msgid "Log in as *John Smith* to check the access rights are correct"
msgstr "登录为 *约翰·史密斯* 检查访问权限是否正确"

#: ../../howtos/backend.rst:1362
msgid "Add access control through data files in your module"
msgstr "通过数据文件添加访问控制你的模块"

#: ../../howtos/backend.rst:1364
msgid "Using data files,"
msgstr "使用数据文件,"

#: ../../howtos/backend.rst:1366
msgid ""
"Create a group *OpenAcademy / Manager* with full access to all OpenAcademy "
"models"
msgstr "创建一组 * OpenAcademy /经理* 具有完全访问所有OpenAcademy车型"

#: ../../howtos/backend.rst:1368
msgid "Make *Session* and *Course* readable by all users"
msgstr "让 *会话* 和 *课程* 所有用户可读"

#: ../../howtos/backend.rst:1372
msgid ""
"Create a new file ``openacademy/security/security.xml`` to hold the "
"OpenAcademy Manager group"
msgstr "创建一个新的文件 ``openacademy /安全/ security.xml`` 举行OpenAcademy Manager组"

#: ../../howtos/backend.rst:1374
msgid ""
"Edit the file ``openacademy/security/ir.model.access.csv`` with the access "
"rights to the models"
msgstr "编辑文件 ``openacademy /安全/ ir.model.access.csv`` 的访问权限模型"

#: ../../howtos/backend.rst:1376
msgid ""
"Finally update ``openacademy/__openerp__.py`` to add the new data files to "
"it"
msgstr "最后更新 ``openacademy / __ __ OpenERP的。py`` 到新的数据文件添加到它"

#: ../../howtos/backend.rst:1382
msgid "Record rules"
msgstr "记录规则"

#: ../../howtos/backend.rst:1384
msgid ""
"A record rule restricts the access rights to a subset of records of the "
"given model. A rule is a record of the model ``ir.rule``, and is associated "
"to a model, a number of groups (many2many field), permissions to which the "
"restriction applies, and a domain. The domain specifies to which records the"
" access rights are limited."
msgstr "A记录的规则限制访问权限, 以给定的模型记录的子集。规则是模型 ``ir.rule`` 的记录, 并关联到一个模型中, 若干组（many2many场）, 权限, 该限制适用, 和域。域名指定其中记录的访问权限是有限的。"

#: ../../howtos/backend.rst:1390
msgid ""
"Here is an example of a rule that prevents the deletion of leads that are "
"not in state ``cancel``. Notice that the value of the field ``groups`` must "
"follow the same convention as the method :meth:`~openerp.models.Model.write`"
" of the ORM."
msgstr "这里是防止删除引线不在状态 ``cancel`` 的规则的一个例子。请注意, 场 ``groups`` 的值必须遵循相同约定的方法 :meth:`的ORM的~openerp.models.Model.write` 。"

#: ../../howtos/backend.rst:1407
msgid "Record rule"
msgstr "记录规则"

#: ../../howtos/backend.rst:1409
msgid ""
"Add a record rule for the model Course and the group \"OpenAcademy / "
"Manager\", that restricts ``write`` and ``unlink`` accesses to the "
"responsible of a course. If a course has no responsible, all users of the "
"group must be able to modify it."
msgstr "添加模型课程记录规则和组'OpenAcademy /经理', 制约 ``write`` 和 ``unlink`` 访问负责一个疗程。如果一门课程没有责任, 该组的所有用户必须能够对其进行修改。"

#: ../../howtos/backend.rst:1416
msgid "Create a new rule in ``openacademy/security/security.xml``:"
msgstr "创建于 ``openacademy /安全/ security.xml`` 一个新的规则:"

#: ../../howtos/backend.rst:1421
msgid "Wizards"
msgstr "向导"

#: ../../howtos/backend.rst:1423
msgid ""
"Wizards describe interactive sessions with the user (or dialog boxes) "
"through dynamic forms. A wizard is simply a model that extends the class "
":class:`~openerp.models.TransientModel` instead of "
":class:`~openerp.models.Model`. The class "
":class:`~openerp.models.TransientModel` extends "
":class:`~openerp.models.Model` and reuse all its existing mechanisms, with "
"the following particularities:"
msgstr "奇才描述了与用户（或对话框）, 通过动态形式的互动环节。向导是一个简单的模型, 它扩展了类 :class: 代替~openerp.models.TransientModel ``:class:`~openerp.models.Model` 。类 :class:`~openerp.models.TransientModel` 扩展 :class:`~openerp.models.Model` 和重复使用所有现有的机制, 具有以下特殊性:"

#: ../../howtos/backend.rst:1430
msgid ""
"Wizard records are not meant to be persistent; they are automatically "
"deleted from the database after a certain time. This is why they are called "
"*transient*."
msgstr "向导记录并不意味着是永久性的;它们会自动从数据库一定时间后删除。这就是为什么它们被称为 *瞬时* 。"

#: ../../howtos/backend.rst:1433
msgid ""
"Wizard models do not require explicit access rights: users have all "
"permissions on wizard records."
msgstr "向导模式不需要明确的访问权限:用户对向导记录的所有权限。"

#: ../../howtos/backend.rst:1435
msgid ""
"Wizard records may refer to regular records or wizard records through "
"many2one fields, but regular records *cannot* refer to wizard records "
"through a many2one field."
msgstr "向导记录可以通过指向常规记录，或者通过many2one字段指向向导记录, 但常规记录 *无法* 通过many2one字段指向向导记录。"

#: ../../howtos/backend.rst:1439
msgid ""
"We want to create a wizard that allow users to create attendees for a "
"particular session, or for a list of sessions at once."
msgstr "我们要创建一个向导, 允许用户创建与会者特定会话, 或者会话在一次列表。"

#: ../../howtos/backend.rst:1442
msgid "Define the wizard"
msgstr "定义向导"

#: ../../howtos/backend.rst:1444
msgid ""
"Create a wizard model with a many2one relationship with the *Session* model "
"and a many2many relationship with the *Partner* model."
msgstr "创建具有与 *会话* 模型, 并与 *合作伙伴* 模型many2many关系many2one关系的向导模式。"

#: ../../howtos/backend.rst:1449
msgid "Add a new file ``openacademy/wizard.py``:"
msgstr "添加一个新的文件 ``openacademy / wizard.py`` :"

#: ../../howtos/backend.rst:1454
msgid "Launching wizards"
msgstr "启动向导"

#: ../../howtos/backend.rst:1456
msgid ""
"Wizards are launched by ``ir.actions.act_window`` records, with the field "
"``target`` set to the value ``new``. The latter opens the wizard view into a"
" popup window. The action may be triggered by a menu item."
msgstr "向导是由 ``ir.actions.act_window`` 纪录发起, 同场 ``target`` 的值设置为 ``new`` 。后者将打开向导查看到一个弹出式窗口。该动作可通过一菜单项来触发。"

#: ../../howtos/backend.rst:1460
msgid ""
"There is another way to launch the wizard: using an "
"``ir.actions.act_window`` record like above, but with an extra field "
"``src_model`` that specifies in the context of which model the action is "
"available. The wizard will appear in the contextual actions of the model, "
"above the main view. Because of some internal hooks in the ORM, such an "
"action is declared in XML with the tag ``act_window``."
msgstr "还有另一种方式来启动向导:使用类似上面的 ``ir.actions.act_window`` 纪录, 但其模式与一个额外的字段 ``src_model`` , 指定范围内的动作是可用的。该向导将出现在模型的上下文动作, 主视图上面。因为在ORM一些内部挂钩, 这种诉讼是在XML的标记 ``act_window`` 声明。"

#: ../../howtos/backend.rst:1476
msgid ""
"Wizards use regular views and their buttons may use the attribute "
"``special=\"cancel\"`` to close the wizard window without saving."
msgstr "奇才用常规的视图和他们的按钮可以使用属性 ``特殊='取消'`` 关闭向导窗口而不保存。"

#: ../../howtos/backend.rst:1479
msgid "Launch the wizard"
msgstr "启动向导"

#: ../../howtos/backend.rst:1481
msgid "Define a form view for the wizard."
msgstr "定义为向导的表单视图。"

#: ../../howtos/backend.rst:1482
msgid "Add the action to launch it in the context of the *Session* model."
msgstr "添加的动作来启动它在 *会话* 模式的情况下。"

#: ../../howtos/backend.rst:1483
msgid ""
"Define a default value for the session field in the wizard; use the context "
"parameter ``self._context`` to retrieve the current session."
msgstr "定义为向导中的会话字段的默认值;使用上下文参数 ``self._context`` 检索当前会话。"

#: ../../howtos/backend.rst:1490
msgid "Register attendees"
msgstr "注册参会"

#: ../../howtos/backend.rst:1492
msgid ""
"Add buttons to the wizard, and implement the corresponding method for adding"
" the attendees to the given session."
msgstr "添加按钮到向导, 并实施相应的方法添加与会者给定的会话。"

#: ../../howtos/backend.rst:1499
msgid "Register attendees to multiple sessions"
msgstr "注册与会者多个会话"

#: ../../howtos/backend.rst:1501
msgid ""
"Modify the wizard model so that attendees can be registered to multiple "
"sessions."
msgstr "修改向导模式, 使与会者可以注册多个会话。"

#: ../../howtos/backend.rst:1509
msgid "Internationalization"
msgstr "国际化"

#: ../../howtos/backend.rst:1511
msgid ""
"Each module can provide its own translations within the i18n directory, by "
"having files named LANG.po where LANG is the locale code for the language, "
"or the language and country combination when they differ (e.g. pt.po or "
"pt_BR.po). Translations will be loaded automatically by Odoo for all enabled"
" languages. Developers always use English when creating a module, then "
"export the module terms using Odoo's gettext POT export feature "
"(:menuselection:`Settings --> Translations --> Import/Export --> Export "
"Translation` without specifying a language), to create the module template "
"POT file, and then derive the translated PO files. Many IDE's have plugins "
"or modes for editing and merging PO/POT files."
msgstr "每个模块都可以在国际化目录中提供自己的翻译​​, 通过具有名为LANG.po文件, 其中LANG是语言环境代码的语言, 或者他们在不同的语言和国家的组合（例如pt.po或pt_BR.po）。翻译会自动Odoo加载所有启用的语言。开发人员总是用英语创建模块的时候, 然后导出使用Odoo的gettext的POT导出功能模块术语（ :menuselection:`设置 - >翻译 - >导入/导出 - >导出Translation` 而不指定的语言）, 创建模块模板POT文件, 然后导出翻译PO文件。许多IDE的有插件或模式进行编辑和合并PO / POT文件。"

#: ../../howtos/backend.rst:1522
msgid ""
"The Portable Object files generated by Odoo are published on `Transifex "
"<https://www.transifex.com/odoo/public/>`__, making it easy to translate the"
" software."
msgstr "The Portable Object files generated by Odoo are published on `Transifex <https://www.transifex.com/odoo/public/>`__, making it easy to translate the software."

#: ../../howtos/backend.rst:1537
msgid ""
"By default Odoo's POT export only extracts labels inside XML files or inside"
" field definitions in Python code, but any Python string can be translated "
"this way by surrounding it with the function :func:`openerp._` (e.g. "
"``_(\"Label\")``)"
msgstr "默认情况下Odoo的POT出口仅提取里面的XML文件或Python代码里面的字段定义标签, 但是任何Python字符串可以通过函数周围被翻译这样 :func:`openerp._` （如 ``_（'标签'）`` ）"

#: ../../howtos/backend.rst:1542
msgid "Translate a module"
msgstr "翻译模块"

#: ../../howtos/backend.rst:1544
msgid ""
"Choose a second language for your Odoo installation. Translate your module "
"using the facilities provided by Odoo."
msgstr "选择第二语言为您Odoo安装。翻译你的模块使用由Odoo提供的设施。"

#: ../../howtos/backend.rst:1549
msgid "Create a directory ``openacademy/i18n/``"
msgstr "创建一个目录 ``openacademy /国际化/`` "

#: ../../howtos/backend.rst:1550
msgid ""
"Install whichever language you want ( :menuselection:`Administration --> "
"Translations --> Load an Official Translation`)"
msgstr "安装任何你想要的语言（ :menuselection:'管理 - >翻译 - >加载一个官方Translation `）"

#: ../../howtos/backend.rst:1553
msgid ""
"Synchronize translatable terms (:menuselection:`Administration --> "
"Translations --> Application Terms --> Synchronize Translations`)"
msgstr "同步翻译术语（ :menuselection:'管理 - >翻译 - >应用程序条款 - >同步Translations `）"

#: ../../howtos/backend.rst:1555
msgid ""
"Create a template translation file by exporting ( "
":menuselection:`Administration --> Translations -> Import/Export --> Export "
"Translation`) without specifying a language, save in ``openacademy/i18n/``"
msgstr "通过导出创建模板翻译文件（ :menuselection:'管理 - >翻译 - >导入/导出 - >导出Translation `）没有指定语言, 保存在 ``openacademy /国际化/`` "

#: ../../howtos/backend.rst:1559
msgid ""
"Create a translation file by exporting ( :menuselection:`Administration --> "
"Translations --> Import/Export --> Export Translation`) and specifying a "
"language. Save it in ``openacademy/i18n/``"
msgstr "通过导出创建一个翻译文件（ :menuselection:'管理 - >翻译 - >导入/导出 - >导出Translation `）, 并指定语言。将它保存在 ``openacademy /国际化/`` "

#: ../../howtos/backend.rst:1563
msgid ""
"Open the exported translation file (with a basic text editor or a dedicated "
"PO-file editor e.g. POEdit_ and translate the missing terms"
msgstr "打开导出的翻译文件（用一个基本的文本编辑器或专用PO文件编辑器如POEdit_和翻译失踪条款"

#: ../../howtos/backend.rst:1567
msgid ""
"In ``models.py``, add an import statement for the function ``openerp._`` and"
" mark missing strings as translatable"
msgstr "在 ``models.py`` 上, 添加功能 ``openerp._`` import语句和标记缺少字符串作为翻译"

#: ../../howtos/backend.rst:1570
msgid "Repeat steps 3-6"
msgstr "重复步骤3-6"

#: ../../howtos/backend.rst:1578
msgid "Reporting"
msgstr "报告"

#: ../../howtos/backend.rst:1581
msgid "Printed reports"
msgstr "打印报告"

#: ../../howtos/backend.rst:1583
msgid ""
"Odoo 8.0 comes with a new report engine based on :ref:`reference/qweb`, "
"`Twitter Bootstrap`_ and Wkhtmltopdf_."
msgstr "Odoo 8.0配备了一个基于 :ref:`reference/qweb` , `Twitter Bootstrap`_  以及 Wkhtmltopdf_ 的新报表引擎 。"

#: ../../howtos/backend.rst:1586
msgid "A report is a combination two elements:"
msgstr "报告是一个组合的两个要素:"

#: ../../howtos/backend.rst:1588
msgid ""
"an ``ir.actions.report.xml``, for which a ``<report>`` shortcut element is "
"provided, it sets up various basic parameters for the report (default type, "
"whether the report should be saved to the database after generation,…)"
msgstr "an ``ir.actions.report.xml`` , for which a ``<report>`` shortcut element is provided, it sets up various basic parameters for the report (default type, whether the report should be saved to the database after generation, …)"

#: ../../howtos/backend.rst:1607
msgid ""
"A standard :ref:`QWeb view <reference/views/qweb>` for the actual report:"
msgstr "实际报告的标准 :ref:`QWeb视图<reference/views/qweb>`:"

#: ../../howtos/backend.rst:1629
msgid ""
"Because reports are standard web pages, they are available through a URL and"
" output parameters can be manipulated through this URL, for instance the "
"HTML version of the *Invoice* report is available through "
"http://localhost:8069/report/html/account.report_invoice/1 (if ``account`` "
"is installed) and the PDF version through "
"http://localhost:8069/report/pdf/account.report_invoice/1."
msgstr "由于报告是标准的网页, 他们都可以通过一个URL和输出参数可以通过这个网址进行操作, 在 *发票* 报告可通过HTTP的比如HTML版本://本地主机:8069 /报告/ HTML /帐户.report_invoice / 1（如果 ``account`` 安装）, 并通过HTTP的PDF版本://本地主机:8069 /报告/ PDF / account.report_invoice / 1。"

#: ../../howtos/backend.rst:1640
msgid ""
"If it appears that your PDF report is missing the styles (i.e. the text "
"appears but the style/layout is different from the html version), probably "
"your wkhtmltopdf_ process cannot reach your web server to download them."
msgstr "If it appears that your PDF report is missing the styles (i.e. the text appears but the style/layout is different from the html version), probably your wkhtmltopdf_ process cannot reach your web server to download them."

#: ../../howtos/backend.rst:1644
msgid ""
"If you check your server logs and see that the CSS styles are not being "
"downloaded when generating a PDF report, most surely this is the problem."
msgstr "If you check your server logs and see that the CSS styles are not being downloaded when generating a PDF report, most surely this is the problem."

#: ../../howtos/backend.rst:1647
msgid ""
"The wkhtmltopdf_ process will use the ``web.base.url`` system parameter as "
"the *root path* to all linked files, but this parameter is automatically "
"updated each time the Administrator is logged in. If your server resides "
"behind some kind of proxy, that could not be reachable. You can fix this by "
"adding one of these system parameters:"
msgstr "The wkhtmltopdf_ process will use the ``web.base.url`` system parameter as the *root path* to all linked files, but this parameter is automatically updated each time the Administrator is logged in. If your server resides behind some kind of proxy, that could not be reachable. You can fix this by adding one of these system parameters:"

#: ../../howtos/backend.rst:1653
msgid ""
"``report.url``, pointing to an URL reachable from your server (probably "
"``http://localhost:8069`` or something similar). It will be used for this "
"particular purpose only."
msgstr "``report.url``, pointing to an URL reachable from your server (probably ``http://localhost:8069`` or something similar). It will be used for this particular purpose only."

#: ../../howtos/backend.rst:1657
msgid ""
"``web.base.url.freeze``, when set to ``True``, will stop the automatic "
"updates to ``web.base.url``."
msgstr "``web.base.url.freeze``, 当设置为 ``True`` 时, 将自动停止``web.base.url`` 的自动更新."

#: ../../howtos/backend.rst:1660
msgid "Create a report for the Session model"
msgstr "创建报告的会议模式"

#: ../../howtos/backend.rst:1662
msgid ""
"For each session, it should display session's name, its start and end, and "
"list the session's attendees."
msgstr "对于每个会话, 它应该显示会议的名称, 它的开始和结束, 并列出了会议的与会者。"

#: ../../howtos/backend.rst:1670
msgid "Dashboards"
msgstr "仪表板"

#: ../../howtos/backend.rst:1672
msgid "Define a Dashboard"
msgstr "定义仪表板"

#: ../../howtos/backend.rst:1674
msgid ""
"Define a dashboard containing the graph view you created, the sessions "
"calendar view and a list view of the courses (switchable to a form view). "
"This dashboard should be available through a menuitem in the menu, and "
"automatically displayed in the web client when the OpenAcademy main menu is "
"selected."
msgstr "定义包含您所创建的图形视图, 会议日历视图和课程的列表视图（可切换到表单视图）的仪表板。本仪表盘应可通过在菜单中菜单项, 并且当选择了OpenAcademy主菜单自动显示在web客户端。"

#: ../../howtos/backend.rst:1682
msgid ""
"Create a file ``openacademy/views/session_board.xml``. It should contain the"
" board view, the actions referenced in that view, an action to open the "
"dashboard and a re-definition of the main menu item to add the dashboard "
"action"
msgstr "创建一个文件 ``openacademy /视图/ session_board.xml`` 。它应该包含板视图, 该视图中引用的行动, 以打开仪表板和主菜单项的重新定义一个动作添加仪表盘的动作"

#: ../../howtos/backend.rst:1687
msgid ""
"Available dashboard styles are ``1``, ``1-1``, ``1-2``, ``2-1`` and "
"``1-1-1``"
msgstr "可用的仪表板风格 ``1`` , ``1-1`` , ``1-2`` , ``2-1`` 和 ``1-1-1`` "

#: ../../howtos/backend.rst:1690
msgid "Update ``openacademy/__openerp__.py`` to reference the new data file"
msgstr "更新 ``openacademy / __ __ OpenERP的。py`` 引用新的数据文件"

#: ../../howtos/backend.rst:1696
msgid "WebServices"
msgstr "网络服务"

#: ../../howtos/backend.rst:1698
msgid "The web-service module offer a common interface for all web-services :"
msgstr "该网络服务模块为所有网络服务的提供通用接口:"

#: ../../howtos/backend.rst:1700
msgid "XML-RPC"
msgstr "XML-RPC"

#: ../../howtos/backend.rst:1701
msgid "JSON-RPC"
msgstr "JSON-RPC"

#: ../../howtos/backend.rst:1703
msgid ""
"Business objects can also be accessed via the distributed object mechanism. "
"They can all be modified via the client interface with contextual views."
msgstr "业务对象也可以通过分布式对象机制访问。它们都可以通过与关联视图客户端界面进行修改。"

#: ../../howtos/backend.rst:1707
msgid ""
"Odoo is accessible through XML-RPC/JSON-RPC interfaces, for which libraries "
"exist in many languages."
msgstr "Odoo是通过XML-RPC / JSON-RPC接口, 对于这在许多语言中存在库的访问。"

#: ../../howtos/backend.rst:1711
msgid "XML-RPC Library"
msgstr "XML-RPC库"

#: ../../howtos/backend.rst:1713
msgid ""
"The following example is a Python program that interacts with an Odoo server"
" with the library ``xmlrpclib``::"
msgstr "下面的例子是, 与Odoo服务器与磁带库 ``xmlrpclib`` 交互的Python程序 ::"

#: ../../howtos/backend.rst:1732
msgid "Add a new service to the client"
msgstr "添加一个新的服务给客户端"

#: ../../howtos/backend.rst:1734
msgid ""
"Write a Python program able to send XML-RPC requests to a PC running Odoo "
"(yours, or your instructor's). This program should display all the sessions,"
" and their corresponding number of seats. It should also create a new "
"session for one of the courses."
msgstr "编写Python程序能够XML-RPC请求发送到运行Odoo一台PC（你, 或你的教师）。这个程序应该显示所有会话, 以及座椅的相应数量。它也应该创建一个新的会话的课程之一。"

#: ../../howtos/backend.rst:1770
msgid ""
"Instead of using a hard-coded course id, the code can look up a course by "
"name::"
msgstr "而不是使用硬编码课程编号, 代码可以查找一门课程的名字 ::"

#: ../../howtos/backend.rst:1781
msgid "JSON-RPC Library"
msgstr "JSON-RPC库"

#: ../../howtos/backend.rst:1783
msgid ""
"The following example is a Python program that interacts with an Odoo server"
" with the standard Python libraries ``urllib2`` and ``json``::"
msgstr "下面的例子是, 与Odoo服务器与标准Python库的 ``urllib2`` 和 ``json`` 交互的Python程序 ::"

#: ../../howtos/backend.rst:1820
msgid ""
"Here is the same program, using the library `jsonrpclib "
"<https://pypi.python.org/pypi/jsonrpclib>`_::"
msgstr "这里是相同的程序, 使用该库 `jsonrpclib <https ://pypi.python.org/pypi/jsonrpclib>` _ : :"

#: ../../howtos/backend.rst:1845
msgid "Examples can be easily adapted from XML-RPC to JSON-RPC."
msgstr "例子可以很容易地适应从XML-RPC为JSON-RPC。"

#: ../../howtos/backend.rst:1849
msgid ""
"There are a number of high-level APIs in various languages to access Odoo "
"systems without *explicitly* going through XML-RPC or JSON-RPC, such as:"
msgstr "有许多的不同的语言的高级API访问Odoo系统, 而不显式的经历的XML-RPC或JSON-RPC, 如:"

#: ../../howtos/backend.rst:1852
msgid "https://github.com/akretion/ooor"
msgstr "https ://github.com/akretion/ooor"

#: ../../howtos/backend.rst:1853
msgid "https://github.com/syleam/openobject-library"
msgstr "https ://github.com/syleam/openobject-library"

#: ../../howtos/backend.rst:1854
msgid "https://github.com/nicolas-van/openerp-client-lib"
msgstr "https ://github.com/nicolas-van/openerp-client-lib"

#: ../../howtos/backend.rst:1855
msgid "https://pypi.python.org/pypi/oersted/"
msgstr "https ://pypi.python.org/pypi/oersted/"

#: ../../howtos/backend.rst:1856
msgid "https://github.com/abhishek-jaiswal/php-openerp-lib"
msgstr "https ://github.com/abhishek-jaiswal/php-openerp-lib"

#: ../../howtos/backend.rst:1858
msgid ""
"it is possible to :attr:`disable the automatic creation of some fields "
"<openerp.models.Model._log_access>`"
msgstr "是可能的 :attr:`禁用自动创建的某些字段<openerp.models.Model._log_access>` "

#: ../../howtos/backend.rst:1860
msgid ""
"writing raw SQL queries is possible, but requires care as it bypasses all "
"Odoo authentication and security mechanisms."
msgstr "编写原始的SQL查询是可能的, 但需要小心, 因为它绕过所有Odoo认证和安全机制。"

#: ../../howtos/themes.rst:5
msgid "Theme Tutorial"
msgstr "主题教程"

#: ../../howtos/themes.rst:9
msgid ""
"Odoo celebrates freedom. Freedom for the designer to go further and freedom "
"for the user to customize everything according to their needs."
msgstr "Odoo庆祝自由。自由的设计, 以进一步和自由去为用户根据自己的需求来定制的一切。"

#: ../../howtos/themes.rst:12
msgid ""
"Ready to create your own theme? Great. Here are some things you should know "
"before you begin. This tutorial is a guide to creating an Odoo theme."
msgstr "准备创建自己的主题？太好了。这里有一些事情你应该知道, 然后再开始。本教程是为了创造一个Odoo主题的指南。"

#: ../../howtos/themes.rst:18
msgid "An introduction for web designers"
msgstr "为网页设计师的介绍"

#: ../../howtos/themes.rst:20
msgid ""
"If you are a web designer using Odoo for the first time, you are in the "
"right place. This introduction will outline the basics of Odoo theme "
"creation."
msgstr "如果您是使用Odoo首次一个网页设计师, 你是在正确的地方。此次推出的将概述Odoo主题制作的基本知识。"

#: ../../howtos/themes.rst:25
msgid ""
"Odoo’s team has created a framework that’s powerful and easy to use. There’s"
" no need to know special syntaxes to use this set of tools."
msgstr "Odoo的团队已经创建了一个框架, 功能强大且易于使用。有没有需要知道的特殊语法使用这套工具。"

#: ../../howtos/themes.rst:28
msgid "From common CMS to Odoo"
msgstr "从普通的CMS​​ Odoo"

#: ../../howtos/themes.rst:32
msgid ""
"If you always think and work in the same way, you’ll probably get the same "
"results. If you want something completely new,  then try something "
"different."
msgstr "如果你总是想, 以同样的方式工作, 你可能会得到同样的结果。如果你想要一些全新的东西, 然后尝试不同的东西。"

#: ../../howtos/themes.rst:36
msgid "Where is my header.php file?"
msgstr "我的header.php文件在哪里？"

#: ../../howtos/themes.rst:38
msgid ""
"This is usually the first question from a web designer used to working with "
"Wordpress or Joomla and coming to Odoo for the first time."
msgstr "这通常是用来与WordPress或工作的Joomla和来Odoo首次一个网页设计师的第一个问题。"

#: ../../howtos/themes.rst:46
msgid ""
"Indeed, when using common CMSs, you have to code several files (like "
"header.php, page.php, post.php, etc.) in order to create a basic structure "
"for your website. With those systems, this base structure acts as a design "
"foundation that you have to update over time to ensure compatibility within "
"your CMS. So, even after you have spent hours coding the files, you have not"
" even started on the design yet."
msgstr "事实上, 使用通用的CMS的时候, 你必须代码的几个文件（如header.php文件, page.php, post.php中, 等）, 以创建一个基本的结构, 为您的网站。有了这些系统, 这个基础结构作为设计基础, 则必须更新随着时间的推移, 以确保您的CMS内的兼容性。所以, 你已经花了几个小时编码的文件, 即使以后, 你甚至还没有开始的设计呢。"

#: ../../howtos/themes.rst:48
msgid "This **does not** apply to creating Odoo themes."
msgstr "这 **不** 适用于创建Odoo主题。"

#: ../../howtos/themes.rst:54
msgid ""
"We think that theme design should be simple (and powerful). When we created "
"our Website Builder, we decided to start from scratch instead of relying on "
"what already existed. This approach gave us the freedom to focus on the "
"things that are really important for designers: styles, content and the "
"logic behind them. No more struggling with technical stuff."
msgstr "我们认为, 主题设计要简单（和强大）。当我们创建了网站制作, 我们决定从头开始, 而不是依靠什么已经存在。这种做法给了我们自由地专注于对设计师真正重要的事情:样式, 内容及其背后的逻辑。没有更多的技术的东西苦苦挣扎。"

#: ../../howtos/themes.rst:57
msgid "Odoo default theme structure"
msgstr "Odoo默认主题结构"

#: ../../howtos/themes.rst:61
msgid ""
"Odoo comes with a default theme structure. It is a very basic “theme” that "
"provides minimal structure and layout. When you create a new theme, you are "
"actually extending this. Indeed it’s always enabled in your setup and it "
"acts exactly like the CMS’s base structure we mentioned above, except that "
"you don’t have to create or maintain it. It will upgrade automatically "
"within your Odoo installation and, since it is included in the Website "
"Builder module, everything is smoothly integrated by default."
msgstr "Odoo带有一个默认的主题结构。这是一个非常基本的“主题\" , 提供了最小的结构和布局。当你创建一个新的主题, 你实际上是扩展这一点。事实上, 它总是在你的安装启用, 它的行为完全像我们上面提到的CMS的基本结构, 不同之处在于您不必创建或维护。它会将你的Odoo安装在自动升级, 因为它包含了网站制作模块中, 一切都顺利通过缺省的集成。 "

#: ../../howtos/themes.rst:66
msgid ""
"As a result, you are totally free to focus on design while this structure "
"does the job of providing integrations and functionality."
msgstr "这样一来, 你是完全自由地专注于设计, 而这样的结构确实提供集成和功能性的工作。"

#: ../../howtos/themes.rst:74
msgid "**Main features:**"
msgstr " **主要特点:** "

#: ../../howtos/themes.rst:76
msgid "Basic layouts for pages, blog and eCommerce"
msgstr "基本布局的网页, 博客, 电子商务"

#: ../../howtos/themes.rst:77
msgid "Website Builder integration"
msgstr "网站生成器整合"

#: ../../howtos/themes.rst:78
msgid "Basic Snippets"
msgstr "基本片段"

#: ../../howtos/themes.rst:79
msgid "Automatic Less/Sass compiling"
msgstr "自动减/萨斯编译"

#: ../../howtos/themes.rst:80
msgid "Automatic Js and CSS minification and combination"
msgstr "自动JS和CSS压缩和组合"

#: ../../howtos/themes.rst:84
msgid "**Main technologies:**"
msgstr " **主要技术:** "

#: ../../howtos/themes.rst:86
msgid "Twitter Bootstrap"
msgstr "Twitter的引导"

#: ../../howtos/themes.rst:87
msgid "jQuery"
msgstr "jQuery的"

#: ../../howtos/themes.rst:88
msgid "jQuery UI"
msgstr "jQuery用户界面"

#: ../../howtos/themes.rst:89
msgid "underscore.js"
msgstr "underscore.js"

#: ../../howtos/themes.rst:92
msgid "Thinking \"modular\""
msgstr "思考'模块化'"

#: ../../howtos/themes.rst:94
msgid ""
"An Odoo theme is not a folder containing HTML or PHP files, it’s a modular "
"framework written in XML. Never worked with XML files before? Don’t worry, "
"after following the tutorial, you’ll be able to create your first theme with"
" only basic knowledge of HTML."
msgstr "一个Odoo主题不包含HTML或PHP文件的文件夹, 它是用XML编写一个模块化的框架。从来没有与XML文件之前？别担心, 下面的教程后, 您就可以使用HTML, 只有基础知识创建您的第一个主题。"

#: ../../howtos/themes.rst:96
msgid ""
"Using classical web design workflows, you usually code the layout of the "
"entire page. The result of this is a “static” web page. You can update the "
"content, of course, but your client will need you to work on making even "
"basic changes."
msgstr "采用经典的网页设计工作流程, 你通常编写整个页面的布局。这样做的结果是一个“静态\" 的网页。您可以更新课程内容, 而是你的客户会需要你地努力, 让连基本的变化。 "

#: ../../howtos/themes.rst:98
msgid ""
"Creating themes for Odoo is a total change of perspective. Instead of "
"defining the complete layout for a page, you can create blocks (snippets) at"
" let the user choose where to “drag&drop” them, creating the page layout on "
"their own. We call this modular design."
msgstr "创建主题Odoo是透视的总变化。而不是定义完整的布局页面, 您可以创建块（片段）, 在让用户选择在哪里“拖放\" 出来的, 创造自己的页面布局。我们把这种模块化设计。 "

#: ../../howtos/themes.rst:101
msgid ""
"Imagine an Odoo theme as a “list” of elements and options that you have to "
"create and style. As a designer, your goal is to style these elements in "
"order to achieve a wonderful result, regardless of where the end user "
"chooses to place them."
msgstr "想象一下, 一个Odoo主题, 你必须创建和风格元素和选项的“清单\" 。作为一个设计师, 你的目标是为了实现一个美妙的结果, 而不管最终用户选择把他们的风格这些元素。 "

#: ../../howtos/themes.rst:104
msgid "Let’s take a tour of our “list” elements:"
msgstr "让我们以我们的“名单\" 元素之旅: "

#: ../../howtos/themes.rst:111
msgid "Snippets (or building-blocks)"
msgstr "片段（或建筑块）"

#: ../../howtos/themes.rst:113
msgid ""
"A piece of HTML code.  The user  will  drag&drop, modify and combine them "
"using our built-in Website Builder interface. You can define sets of options"
" and styles for each snippet. The user will choose from them according to "
"their needs."
msgstr "一段HTML代码。用户将拖拽, 修改和使用我们的内置网站Builder界面将它们结合起来。您可以定义的选项集和风格的每个片段。用户将从他们根据自己的需求进行选择。"

#: ../../howtos/themes.rst:118
msgid "Pages"
msgstr "网页"

#: ../../howtos/themes.rst:120
msgid ""
"These are normal web pages, except that they will be editable by the final "
"user and that you can define an empty area that the user can “fill” by "
"dragging snippets into it."
msgstr "这些都是正常的网页, 但他们将可以编辑的最终用户, 你可以定义一个空白区域, 用户可以“补\" 通过拖动片段进去。 "

#: ../../howtos/themes.rst:130
msgid "Styles"
msgstr "样式"

#: ../../howtos/themes.rst:132
msgid ""
"Styles are defined using standard CSS files (or Less/Sass). You can define a"
" style as **default** or **optional**. The default styles are always active "
"in your theme, the optional styles can be enabled or disabled by the user."
msgstr "样式使用的是标准的CSS文件（或更少/萨斯）定义。你可以定义一个风格 **默认** 或 **可选** 。默认样式始终活跃在你的主题, 可选的款式, 可以启用或由用户禁用。"

#: ../../howtos/themes.rst:137
msgid "Functionalities"
msgstr "功能"

#: ../../howtos/themes.rst:139
msgid ""
"Thanks to Odoo’s modularity, everything can be personalized even more. This "
"means there are endless possibilities for your creativity. Adding "
"functionalities is easy and it’s simple to provide the end user with "
"customizable options."
msgstr "由于Odoo的模块化, 一切都可以更加个性化。这意味着对你的创意无限的可能性。添加的功能是容易的, 它是简单的提供最终用户提供可自定义的选项。"

#: ../../howtos/themes.rst:144
msgid "Odoo's XML files, an overview"
msgstr "Odoo XML文件的概述"

#: ../../howtos/themes.rst:146
msgid ""
"Any Odoo XML file starts with encoding specifications. After that, you have "
"to write your code inside a ``<data>`` tag, placed into an ``</openerp>`` "
"tag."
msgstr "Any Odoo XML file starts with encoding specifications. After that, you have to write your code inside a ``<data>`` tag, placed into an ``</openerp>`` tag."

#: ../../howtos/themes.rst:159
msgid ""
"Almost every element and option that you create has to be placed inside a "
"``<template>`` tag, like in this example."
msgstr "Almost every element and option that you create has to be placed inside a ``<template>`` tag, like in this example."

#: ../../howtos/themes.rst:171
msgid ""
"don't misunderstand what ``template`` means. A template tag only defines a "
"piece of html code or options - but it does not necessarily coincide with a "
"visual arrangement of elements."
msgstr "不要误解了 ``template`` 手段。甲模板标记仅定义一块HTML代码或选项 - 但它不一定与元件的视觉装置重合。"

#: ../../howtos/themes.rst:175
msgid ""
"The previous code defines a title, but it will not be displayed anywhere "
"because that *template* is not associated with any part of the **Odoo "
"default structure**.  In order to do that you can use **xpath**, **qWeb** or"
" a combination of both."
msgstr "前面的代码定义了一个标题，但它不会显示，因为*template* 没有**Odoo 默认结构** 的任何一部分关联.  为了做到这一点，你可以 使用 **xpath**, **qWeb** 或者二者组合。"

#: ../../howtos/themes.rst:180
msgid ""
"Keep reading the tutorial to learn to how properly extend it with your own "
"code."
msgstr "请继续阅读本教程学习如何正确地使用自己的代码扩展它。"

#: ../../howtos/themes.rst:183 ../../howtos/themes.rst:358
#: ../../howtos/themes.rst:469 ../../howtos/themes.rst:565
#: ../../howtos/themes.rst:836
msgid "Update your theme"
msgstr "更新你的主题"

#: ../../howtos/themes.rst:187
msgid ""
"Since XML files are only loaded when you install the theme, you will have to"
" force reloading every time you make changes on an xml file."
msgstr "因为当你安装的主题只加载XML文件, 你将不得不强制重新加载每次做出一个XML文件的更改时间。"

#: ../../howtos/themes.rst:189
msgid "To do that, click on the Upgrade button in the module’s page."
msgstr "要做到这一点, 请单击该模块的页面升级按钮。"

#: ../../howtos/themes.rst:200
msgid "Create a theme module"
msgstr "创建一个主题模块"

#: ../../howtos/themes.rst:202
msgid ""
"Odoo’s themes are packaged like modules. Even if you are designing a very "
"simple website for your company or client, you need to package the theme "
"like an Odoo module."
msgstr "Odoo的主题是包装类似的模块。即使你设计一个非常简单的网站为您的公司或客户, 您需要像Odoo模块那样封装主题。"

#: ../../howtos/themes.rst:206
msgid "``main folder``"
msgstr " ``主folder`` "

#: ../../howtos/themes.rst:205
msgid ""
"Create a folder and name it like this: ``theme_`` followed by your theme's "
"name."
msgstr "创建一个文件夹并将其命名为这样的:``theme_`` 其次是你的主题的名字。"

#: ../../howtos/themes.rst:211
msgid "``__openerp__.py``"
msgstr "``__openerp__.py``"

#: ../../howtos/themes.rst:209
msgid ""
"Create an empty document and save it to your folder as ``__openerp__.py``. "
"This will contain the configuration info for your theme."
msgstr "创建一个空文件并将其保存到您的文件夹 ``__openerp __。py`` 。这将包含为主题的配置信息。"

#: ../../howtos/themes.rst:215
msgid "``__init__.py``"
msgstr " ``__init __。py`` "

#: ../../howtos/themes.rst:214
msgid ""
"Create another empty file and name it ``__init__.py``. It's a mandatory "
"system file. Create and leave it blank."
msgstr "创建另一个空文件并将其命名为 ``__init __。py`` 。这是一个强制性的制度文件。创建并让它空白。"

#: ../../howtos/themes.rst:221
msgid "``views`` and ``static`` folders"
msgstr " ``views`` 和 ``static`` 文件夹"

#: ../../howtos/themes.rst:218
msgid ""
"Create them in the main folder. In ``views`` you'll place your xml files "
"that define your snippets, your pages and your options. ``static`` folder is"
" the right place for your style , images and custom js code."
msgstr "在主文件夹中创建他们。在 ``views`` 你会放置了定义片段, 您的网页和你的选择你的XML文件。 ``static`` 文件夹是正确的地方为你的风格, 图片和自定义的JS代码。"

#: ../../howtos/themes.rst:225
msgid ""
"Use two underscore characters at the beginning and two at the end of openerp"
" and init file names."
msgstr "使用两个下划线字符在两个开始在OpenERP的和init文件名末尾。"

#: ../../howtos/themes.rst:228
msgid "The final result should be something like this:"
msgstr "最终的结果应该是这样的:"

#: ../../howtos/themes.rst:233
msgid "Edit ``__openerp__.py``"
msgstr "编辑 ``__openerp __。py`` "

#: ../../howtos/themes.rst:235
msgid "Open the ``__openerp__.py`` you created and copy/paste the following:"
msgstr "打开 ``__openerp __ py`` 您创建和复制/粘贴以下:"

#: ../../howtos/themes.rst:251
msgid ""
"Replace the first four property’s values with anything you like. These "
"values will be used to identify your new theme in Odoo’s backend."
msgstr "与任何你喜欢更换前四个属性的值。这些值将被用来识别在Odoo的后端新主题。"

#: ../../howtos/themes.rst:254
msgid ""
"The ``data`` property will contain the xml files list. Right now it’s empty,"
" but we will add any new files created."
msgstr "该 ``data`` 属性将包含XML的文件列表。现在它是空的, 但我们将添加任何新创建的文件。"

#: ../../howtos/themes.rst:256
msgid "``application: True`` is mandatory."
msgstr " ``应用程序:True`` 是强制性的。"

#: ../../howtos/themes.rst:258
msgid ""
"``category`` defines your module category (always “Theme”) and, after a "
"slash, the subcategory. You can use one subcategory from the Odoo Apps "
"categories list. (https://www.odoo.com/apps/themes)"
msgstr " ``category`` 定义你的模块类（总是“主题\" ）, 以及斜线的子类别后。您可以使用一个子类别从Odoo应用程序的类别列表。 （https ://www.odoo.com/apps/themes） "

#: ../../howtos/themes.rst:261
msgid ""
"``depends`` specifies the modules needed by our theme to work properly. For "
"our tutorial theme, we only need website. If you need blogging or eCommerce "
"features as well, you have to add those modules too."
msgstr "``depends`` specifies the modules needed by our theme to work properly. For our tutorial theme, we only need website. If you need blogging or eCommerce features as well, you have to add those modules too."

#: ../../howtos/themes.rst:272
msgid "Installing your theme"
msgstr "安装你的主题"

#: ../../howtos/themes.rst:274
msgid ""
"To install your theme, you just place your theme folder inside addons in "
"your Odoo installation."
msgstr "要安装你的主题, 你只要把里面的插件你的主题文件夹中Odoo安装。"

#: ../../howtos/themes.rst:276
msgid ""
"After that, navigate to the Settings page, look for your theme and click on "
"the install button."
msgstr "在此之后, 导航到设置页面, 寻找你的主题, 然后点击安装按钮。"

#: ../../howtos/themes.rst:279
msgid "Structure of an Odoo page"
msgstr "Odoo的页面结构"

#: ../../howtos/themes.rst:281
msgid ""
"An Odoo page is the visual result of a combination of 2 kind of elements, "
"**cross-pages** and **unique**. By default, Odoo provides you with a "
"**Header** and a **Footer** (cross-pages) and a unique main element that "
"contains the content that makes your page unique."
msgstr "一个Odoo页面是2种元素, **跨页** 组合的视觉效果和 **** 独特。默认情况下, Odoo为您提供了一个 **头** 和 **页脚** （跨页）, 包含让你的页面的独特内容独特的主元素。"

#: ../../howtos/themes.rst:286
msgid ""
"Cross-pages elements will be the same on every page. Unique elements are "
"related to a specific page only."
msgstr "跨页面的元素将在每个页面上相同。独特的元素相关的仅一个特定页面。"

#: ../../howtos/themes.rst:290
msgid ""
"To inspect the default layout, simply create a new page using the Website "
"Builder.  Click on :menuselection:`Content --> New Page` and add a page "
"name.  Inspect the page using your browser."
msgstr "要检查的默认布局, 只需创建一个使用该网站制作了新的一页。点击 :menuselection:'内容 - >新建Page `并添加一个页面名称。使用浏览器检查的页面。"

#: ../../howtos/themes.rst:303
msgid "Extend the default Header"
msgstr "扩展默认标题"

#: ../../howtos/themes.rst:305
msgid ""
"By default, Odoo header contains a responsive navigation menu and the "
"company’s logo. You can easily add new elements or style the existing one."
msgstr "默认情况下, Odoo头包含一个负责任的导航菜单和公司的标志。您可以轻松地添加新的元素和风格现有之一。"

#: ../../howtos/themes.rst:307
msgid ""
"To do so, create a **layout.xml** file in your **views** folder and add the "
"default Odoo xml markup."
msgstr "要做到这一点, 创建一个 **layout.xml** 文件在你的 **** 的意见文件夹, 并添加默认Odoo XML标记。"

#: ../../howtos/themes.rst:318
msgid ""
"Create a new template into the ``<data>`` tag, copy-pasting the following "
"code."
msgstr "Create a new template into the ``<data>`` tag, copy-pasting the following code."

#: ../../howtos/themes.rst:341
msgid ""
"The first xpath will add the id ``my_header`` to the header. It’s the best "
"option if you want to target css rules to that element and avoid these "
"affecting other content on the page."
msgstr "第一的xpath将中的id ``my_header`` 添加到头部。这是最好的选择, 如果你想要瞄准的CSS规则的元素, 避免在页面上这些影响其他内容。"

#: ../../howtos/themes.rst:346
msgid ""
"Be careful replacing default elements attributes. As your theme will extend "
"the default one, your changes will take priority in any future Odoo’s "
"update."
msgstr "小心替换默认的元素属性。当你的主题将扩展默认的, 您的更改将优先在未来Odoo的更新。"

#: ../../howtos/themes.rst:349
msgid ""
"The second xpath will add a welcome message just after the navigation menu."
msgstr "第二个XPath的只是导航菜单后添加一个值得欢迎的消息。"

#: ../../howtos/themes.rst:351
msgid ""
"The last step is to add layout.xml to the list of xml files used by the "
"theme. To do that, edit your ``__openerp__.py`` file like this"
msgstr "最后一步是添加layout.xml到所使用的主题的xml文件的列表。为了做到这一点, 编辑你的 ``__openerp __。py`` 这样的文件"

#: ../../howtos/themes.rst:362
msgid ""
"Great! We successfully added an id to the header and an element after the "
"navigation menu. These changes will be applied to each page of the website."
msgstr "太棒了！我们成功地添加一个id到页眉和导航菜单后一个元素。这些改变将被施加到网站的每个页面。"

#: ../../howtos/themes.rst:370
msgid "Create a specific page layout"
msgstr "创建一个特定的页面布局"

#: ../../howtos/themes.rst:372
msgid ""
"Imagine that we want to create a specific layout for a Services page. For "
"this page, we need to add a list of services to the top and give the client "
"the possibility of setting the rest of the page’s layout using snippets."
msgstr "试想一下, 我们要创建一个服务页面的特定布局。对于这个页面, 我们需要的服务列表添加到顶部, 并给客户端设置使用片段页面的布局的其余部分的可能性。"

#: ../../howtos/themes.rst:375
msgid ""
"Inside your *views* folder, create a **pages.xml** file and add the default "
"Odoo markup.  Inside ``<data>`` create a ``<template>`` tag, set the "
"``page`` attribute to ``True`` and add your code into it."
msgstr "Inside your *views* folder, create a **pages.xml** file and add the default Odoo markup. Inside ``<data>`` create a ``<template>`` tag, set the ``page`` attribute to ``True`` and add your code into it."

#: ../../howtos/themes.rst:396
msgid ""
"The page title will be the template ID. In our case *Services* (from "
"``website.services``)"
msgstr "页面标题将是模板ID。在我们的例子 *服务* （来自 ``website.services`` ）"

#: ../../howtos/themes.rst:398
msgid ""
"We successfully created a new page layout, but we haven't told the system "
"**how to use it**. To do that, we can use **QWeb**. Wrap the html code into "
"a ``<t>`` tag, like in this example."
msgstr "我们成功的创建了一个新页面布局, 但我们还没有告诉系统 **如何使用它** . 要做到它, 我们可以使用 **QWeb** . 包装 html 代码到 ``<t>`` 标签, 像这个例子。"

#: ../../howtos/themes.rst:420
msgid ""
"Using ``<t t-call=\"website.layout\">`` we will extend the Odoo default page"
" layout with our code."
msgstr "Using ``<t t-call=`` website.layout ``>`` we will extend the Odoo default page layout with our code."

#: ../../howtos/themes.rst:423
msgid ""
"As you can see, we wrapped our code into two ``<div>``,  one with ID "
"``wrap`` and the other one with class ``container``. This is to provide a "
"minimal layout."
msgstr "As you can see, we wrapped our code into two ``<div>`` , one with ID ``wrap`` and the other one with class ``container`` . This is to provide a minimal layout."

#: ../../howtos/themes.rst:425
msgid ""
"The next step is to add an empty area that the user can fill with snippets. "
"To achieve this, just create a ``div`` with ``oe_structure`` class just "
"before closing the ``div#wrap`` element."
msgstr "下一步骤是添加的用户可以与片断填充的空白区域。要做到这一点, 刚刚闭幕的 ``DIV＃wrap`` 元素之前, 只需创建一个 ``div`` 与 ``oe_structure`` 类。"

#: ../../howtos/themes.rst:458
msgid ""
"You can create as many snippet areas as you like and place them anywhere in "
"your pages."
msgstr "只要你喜欢, 你可以创建许多片断字段和任何地方将它们放置在您的网页。"

#: ../../howtos/themes.rst:460
msgid ""
"Our page is almost ready. Now all we have to do is add **pages.xml** in our "
"**__openerp__.py** file"
msgstr "我们的网页几乎准备就绪。现在我们需要做的就是增加 **** pages.xml中我们 **__ __ OpenERP的。PY** 文件"

#: ../../howtos/themes.rst:473
msgid ""
"Great, our Services page is ready and you’ll be able to access it by "
"navigating to ``/yourwebsite/page/services``."
msgstr "太好了, 我们的服务页面准备就绪, 你就可以浏览到 ``/ yourwebsite /页/ services`` 访问它。"

#: ../../howtos/themes.rst:475
msgid ""
"You will notice that it's possible to drag/drop snippets underneath the *Our"
" Services* list."
msgstr "你会发现, 它可能拖/放下面的代码片段 *我们的服务* 名单。"

#: ../../howtos/themes.rst:481
msgid ""
"Now let's go back to our *pages.xml* and, after our page template, "
"copy/paste the following code."
msgstr "现在, 让我们回到我们的 * pages.xml中* 和, 我们的页面模板后, 复制/粘贴下面的代码。"

#: ../../howtos/themes.rst:493
msgid "This code will add a link to the main menu."
msgstr "此代码将链接添加到主菜单。"

#: ../../howtos/themes.rst:498
msgid ""
"The **sequence** attribute defines the link’s position in the top menu. In "
"our example, we set the value to ``99`` in order to place it last. I you "
"want to place it in a particular position, you have to replace the value "
"according to your needs."
msgstr " **的** 顺序属性定义链接的顶部菜单中的位置。在我们的例子中, 我们为了最后把它设置值 ``99`` 。我要放置在一个特定的位置, 你必须根据你的需要来替换值。"

#: ../../howtos/themes.rst:501
msgid ""
"As you can see inspecting the *data.xml* file in the ``website`` module, the"
" **Home** link is set to ``10`` and the **Contact** us one is set to ``60`` "
"by default. If, for example, you want to place your link in the **middle**, "
"you can set your link’s sequence value to ``40``."
msgstr "正如你所看到检查 * data.xml中* 文件中的 ``website`` 模块中, **的** 主页链接设置为 ``10`` 和 **联系** 我们已设置为 ``60`` 默认。如果, 例如, 要放置在中间 **** 你的链接, 你可以在你的链接的序列值设置为 ``40`` 。"

#: ../../howtos/themes.rst:505
msgid "Add Styles"
msgstr "添加样式"

#: ../../howtos/themes.rst:507
msgid ""
"Odoo includes Bootstrap by default. This means that you can take advantage "
"of all Bootstrap styles and layout functionalities out of the box."
msgstr "Odoo包括引导默认情况下。这意味着, 你可以充分利用所有的引导风格和布局功能的开箱即用。"

#: ../../howtos/themes.rst:509
msgid ""
"Of course Bootstrap is not enough if you want to provide a unique design. "
"The following steps will guide you through how to add custom styles to your "
"theme. The final result won't be pretty, but will provide you with enough "
"information to build upon on your own."
msgstr "如果你想提供一个独特的设计当然引导是不够的。下面的步骤将指导您如何自定义样式添加到您的主题。最终的结果将不漂亮, 但会为你提供足够的信息来建立在你自己的。"

#: ../../howtos/themes.rst:512
msgid ""
"Let’s start by creating an empty file called **style.less** and place it in "
"a folder called **less** in your static folder. The following rules will "
"style our *Services* page. Copy and paste it, then save the file."
msgstr "让我们先创建一个名为 **style.less的空文件** 并将其放在一个名为文件夹中的 **** 少在您的静态文件夹中。下面的规则将我们的样式 *服务* 页面。复制和粘贴, 然后保存文件。"

#: ../../howtos/themes.rst:533
msgid "Our file is ready but it is not included in our theme yet."
msgstr "我们的文件准备好, 但它不包括在我们的主题呢。"

#: ../../howtos/themes.rst:535
msgid ""
"Let’s navigate to the view folder and create an XML file called "
"*assets.xml*. Add the default Odoo xml markup and copy/paste the following "
"code. Remember to replace ``theme folder`` with your theme’s main folder "
"name."
msgstr "让我们浏览到视图文件夹, 并创建一个名为 * assets.xml * XML文件。添加默认Odoo XML标记和复制/粘贴下面的代码。请用您的主题的主文件夹名称替换 ``主题folder`` 。"

#: ../../howtos/themes.rst:545
msgid ""
"We just created a template specifying our less file. As you can see, our "
"template has a special attribute called ``inherit_id``.  This attribute "
"tells Odoo that our template is referring to another one in order to "
"operate."
msgstr "我们刚刚创建的模板, 指定我们用较少的文件。正如你所看到的, 我们的模板有一个名为 ``inherit_id`` 一个特殊的属性。此属性告诉Odoo我们模板是指另一个, 以便操作。"

#: ../../howtos/themes.rst:550
msgid ""
"In this case, we are referring to ``assets_frontend`` template, located in "
"the ``website`` module. ``assets_frontend`` specifies the list of assets "
"loaded by the website builder and our goal is to add our less file to this "
"list."
msgstr "在这种情况下, 我们指的是 ``assets_frontend`` 模板, 位于 ``website`` 模块内。 ``assets_frontend`` 指定的网站建设者加载资源列表, 我们的目标是我们不太文件添加到列表中。"

#: ../../howtos/themes.rst:555
msgid ""
"This can be achieved using xpath with the attributes "
"``expr=\"link[last()]\"`` and ``position=\"after\"``, which means \"*take my"
" style file and place it after the last link in the list of the assets*\"."
msgstr "这可以使用XPath的属性 ``EXPR ='链接[最后（）]'`` 和实现 ``位置='后'`` , 这意味着'*把我的风格文件, 并将其后在资产*'的列表中的最后一个环节。"

#: ../../howtos/themes.rst:560
msgid ""
"Placing it after the last one, we ensure that our file will be loaded at the"
" end and take priority."
msgstr "经过最后一个放置它, 我们保证我们的文件将在年底被加载, 并采取优先。"

#: ../../howtos/themes.rst:563
msgid "Finally add **assets.xml** in your **__openerp__.py** file."
msgstr "最后补充 **** assets.xml在你的 **__ __ OpenERP的。PY** 文件。"

#: ../../howtos/themes.rst:570
msgid ""
"Our less file is now included in our theme, it will be automatically "
"compiled, minified and combined with all Odoo’s assets."
msgstr "现在我们用较少的文件已包含在我们的主题, 它会自动编译, 精缩并结合所有Odoo资产。"

#: ../../howtos/themes.rst:576
msgid "Create Snippets"
msgstr "创建片段"

#: ../../howtos/themes.rst:578
msgid ""
"Since snippets are how users design and layout pages, they are the most "
"important element of your design. Let’s create a snippet for our Service "
"page. The snippet will display three testimonials and it will be editable by"
" the end user using the Website Builder UI. Navigate to the view folder and "
"create an XML file called **snippets.xml**. Add the default Odoo xml markup "
"and copy/paste the following code. The template contains the HTML markup "
"that will be displayed by the snippet."
msgstr "由于片段是用户如何设计和布局的网页, 他们是你的设计中最重要的元素。让我们创建一个片段为我们的服务页面。该片段将显示三种褒奖, 这将可以编辑使用本网站生成器用户界面, 最终用户。导航到视图文件夹, 并创建一个名为 **snippets.xml XML文件** 。添加默认Odoo XML标记和复制/粘贴下面的代码。该模板包含将由片段显示HTML标记。"

#: ../../howtos/themes.rst:610
msgid ""
"As you can see, we used Bootstrap default classes for our three columns. "
"It’s not just about layout, these classes **will be triggered by the Website"
" Builder to make them resizable by the user**."
msgstr "正如你所看到的, 我们使用默认的Bootstrap类我们的三列。这不只是布局, 这些类 **将通过网站生成器被触发, 使他们由用户调整大小** 。"

#: ../../howtos/themes.rst:612
msgid ""
"The previous code will create the snippet’s content, but we still need to "
"place it into the editor bar, so the user will be able to drag&drop it into "
"the page. Copy/paste this template in your **snippets.xml** file."
msgstr "上面的代码将创建片段的内容, 但我们仍然需要将其放置到编辑栏中, 这样用户就可以拖放到页面。复制/粘贴这个模板在你的 **snippets.xml** 文件。"

#: ../../howtos/themes.rst:625
msgid ""
"Using xpath, we are targeting a particular element with id "
"``snippet_structure``. This means that the snippet will appear in the "
"Structure tab. If you want to change the destination tab, you have just to "
"replace the ``id`` value in the xpath expression."
msgstr "使用XPath, 我们的目标是一个特定元素id为 ``snippet_structure`` 。这意味着该片段将出现在结构选项卡。如果您想更改目的地选项卡, 你只需替换XPath表达式的 ``id`` 值。"

#: ../../howtos/themes.rst:637
msgid "Tab Name"
msgstr "标签名称"

#: ../../howtos/themes.rst:637
msgid "Xpath expression"
msgstr "XPath表达式"

#: ../../howtos/themes.rst:639
msgid "Structure"
msgstr "结构体"

#: ../../howtos/themes.rst:639
msgid "``//div[@id='snippet_structure']``"
msgstr "``//div[@id='snippet_structure']``"

#: ../../howtos/themes.rst:640
msgid "Content"
msgstr "内容"

#: ../../howtos/themes.rst:640
msgid "``//div[@id='snippet_content']``"
msgstr "``//div[@id='snippet_content']``"

#: ../../howtos/themes.rst:641
msgid "Feature"
msgstr "特点"

#: ../../howtos/themes.rst:641
msgid "``//div[@id='snippet_feature']``"
msgstr "``//div[@id='snippet_feature']``"

#: ../../howtos/themes.rst:642
msgid "Effect"
msgstr "功效"

#: ../../howtos/themes.rst:642
msgid "``//div[@id='snippet_effect']``"
msgstr "``//div[@id='snippet_effect']``"

#: ../../howtos/themes.rst:645
msgid ""
"The ``<t>`` tag will call our snippet's template and will assign a thumbnail"
" placed in the img folder. You can now drag your snippet from the snippet "
"bar, drop it in your page and see the result."
msgstr "The ``<t>`` tag will call our snippet's template and will assign a thumbnail placed in the img folder. You can now drag your snippet from the snippet bar, drop it in your page and see the result."

#: ../../howtos/themes.rst:652
msgid "Snippet options"
msgstr "片段选项"

#: ../../howtos/themes.rst:654
msgid ""
"Options allow publishers to edit a snippet’s appearance using the Website "
"Builder’s UI. Using Website Builder functionalities, you can create snippet "
"options easily and automatically add them to the UI."
msgstr "选项​​允许出版商使用本网站生成器的UI编辑片段的外观。利用网站制作功能, 您可以轻松地创建片段选项, 并自动将它们添加到用户界面。"

#: ../../howtos/themes.rst:658
msgid "Options group properties"
msgstr "选项​​组属性"

#: ../../howtos/themes.rst:660
msgid ""
"Options are wrapped in groups. Groups can have properties that define how "
"the included options will interact with the user interface."
msgstr "选项​​被包裹在组。基团可以具有定义如何包含选项将与用户界面进行交互属性。"

#: ../../howtos/themes.rst:662
msgid "``data-selector=\" css selector(s) \"``"
msgstr " ``数据选择器='CSS选择器（S）'`` "

#: ../../howtos/themes.rst:663
msgid "Bind all the options included into the group to a particular element."
msgstr "绑定所有纳入该集团的特定元素的选项。"

#: ../../howtos/themes.rst:664
msgid "``data-js=\" custom method name \"``"
msgstr " ``数据-JS ='自定义方法名'`` "

#: ../../howtos/themes.rst:665
msgid "Is used to bind custom Javascript methods."
msgstr "用于绑定的自定义JavaScript方法。"

#: ../../howtos/themes.rst:666
msgid "``data-drop-in=\" css selector(s) \"``"
msgstr " ``数据插入式='CSS选择器（S）'`` "

#: ../../howtos/themes.rst:667
msgid "Defines the list of elements where the snippet can be dropped into."
msgstr "定义元素, 其中的片段能投进的列表。"

#: ../../howtos/themes.rst:669
msgid "``data-drop-near=\" css selector(s) \"``"
msgstr " ``数据下降 - 近='CSS选择器（S）'`` "

#: ../../howtos/themes.rst:669
msgid "Defines the list of elements that the snippet can be dropped beside."
msgstr "限定元件, 该片段可以旁丢弃列表。"

#: ../../howtos/themes.rst:672
msgid "Default option methods"
msgstr "默认选项方法"

#: ../../howtos/themes.rst:674
msgid ""
"Options apply standard CSS classes to the snippet. Depending on the method "
"that you choose, the UI will behave differently."
msgstr "选择适用标准的CSS类的代码片段。根据您选择的方法, 用户界面​​将不同的表现。"

#: ../../howtos/themes.rst:677
msgid "``data-select_class=\" class name \"``"
msgstr " ``数据select_class ='类名'`` "

#: ../../howtos/themes.rst:677
msgid ""
"More data-select_class in the same group defines a list of classes that the "
"user can choose to apply. Only one option can be enabled at a time."
msgstr "多个数据select_class在同一组中定义的类, 用户可以选择要应用的列表。可以在同一时间内仅启用一个选项。"

#: ../../howtos/themes.rst:680
msgid "``data-toggle_class=\" class name \"``"
msgstr " ``数据toggle_class ='类名'`` "

#: ../../howtos/themes.rst:680
msgid ""
"The data-toggle_class is used to apply one or more CSS classes from the list"
" to a snippet. Multiple selections can be applied at once."
msgstr "该数据toggle_class用于从列表中的一个片段应用一个或多个CSS类。可选择多个可以一次施用。"

#: ../../howtos/themes.rst:682
msgid "Let's demonstrate how default options work with a basic example."
msgstr "我们来演示默认选项有一个基本的例子是如何工作的。"

#: ../../howtos/themes.rst:684
msgid ""
"We start by adding a new file in our views folder - name it **options.xml** "
"and add the default Odoo XML markup. Create a new template copy/pasting the "
"following"
msgstr "首先, 我们在我们的意见文件夹中添加一个新的文件 - 将其命名为 **options.xml** 并添加默认Odoo XML标记。创建一个新的模板复制/粘贴以下"

#: ../../howtos/themes.rst:706
msgid ""
"The previous template will inherit the default **snippet_options template** "
"adding our options after the **background** options (xpath expr attribute). "
"To place your options in a particular order, inspect the **snippet_options "
"template** from the **website module** and add your options before/after the"
" desired position."
msgstr "以前的模板将继承默认 **snippet_options模板** **的** 背景选项（的XPath expr属性）后加入我们的选择。要放置在一个特定的顺序你的选择, 检查 **snippet_options模板** 的 **网站模块** 之前添加选项/所需位置后。"

#: ../../howtos/themes.rst:709
msgid ""
"As you can see, we wrapped all our options inside a DIV tag that will group "
"our options and that will target them to the right selector (``data-"
"selector=\".snippet_testimonial\"``)."
msgstr "正如你所看到的, 我们都包裹我们的选择的DIV标签内, 将集团我们的选择, 这将他们定位到正确的选择（ ``数据选择器='。snippet_testimonial'`` ）。"

#: ../../howtos/themes.rst:713
msgid ""
"To define our options we applied ``data-select_class`` attributes to the "
"``li`` elements. When the user selects an option, the class contained in the"
" attribute will automatically be applied to the element."
msgstr "要定义我们的选择, 我们采用 ``数据select_class`` 属性的 ``li`` 元素。当用户选择一个选项中, 包含在属性的类将被自动应用到的元素。"

#: ../../howtos/themes.rst:717
msgid ""
"Since ``select_class`` method avoids multiple selections, the last \"empty\""
" option will reset the snippet to default."
msgstr "由于 ``select_class`` 方法避免了多重选择, 最后的'空'选项将重置片断为默认值。"

#: ../../howtos/themes.rst:720
msgid "Add **options.xml** to ``__openerp__.py`` and update your theme."
msgstr "加入 **** options.xml到 ``__openerp __。py`` 并更新你的主题。"

#: ../../howtos/themes.rst:724
msgid ""
"Dropping our snippet onto the page, you will notice that our new options are"
" automatically added to the customize menu. Inspecting the page, you will "
"also notice that the class will be applied to the element when selecting an "
"option."
msgstr "删除我们的片断到页面中, 你会发现, 我们新的选项将自动添加到自定义菜单。检查页面, 你还会发现, 在选择一个选项, 上课的时候​​会被应用到元素。"

#: ../../howtos/themes.rst:728
msgid ""
"Let’s create some css rules in order to provide a visual feedback for our "
"options. Open our **style.less** file and add the following"
msgstr "让我们以提供视觉反馈, 我们的选择创建一些CSS规则。打开我们的 **style.less** 文件, 并添加以下"

#: ../../howtos/themes.rst:756
msgid "Great! We successfully created options for our snippet."
msgstr "太棒了！我们成功创建方案为我们的片断。"

#: ../../howtos/themes.rst:758
msgid ""
"Any time the publisher clicks on an option, the system will add the class "
"specified in the data-select_class attribute."
msgstr "任何时间发行点击一个选项, 该系统会在该数据select_class属性指定的类。"

#: ../../howtos/themes.rst:760
msgid ""
"By replacing ``data-select_class`` with ``data-toggle_class`` you will be "
"able to select more classes at the same time."
msgstr "通过与替代 ``数据select_class````数据toggle_class`` 您将能够选择更多的类在同一时间。"

#: ../../howtos/themes.rst:765
msgid "Javascript Options"
msgstr "JavaScript选项"

#: ../../howtos/themes.rst:767
msgid ""
"``data-select_class`` and ``data-toggle_class`` are great if you need to "
"perform simple class change operations. But what if your snippet’s "
"customization needs something more?"
msgstr " ``数据select_class`` 和 ``数据toggle_class`` 是伟大的, 如果你需要进行简单的类更改操作。但是, 如果你的代码段的自定义需要更多的东西？"

#: ../../howtos/themes.rst:770
msgid ""
"As we said before, ``data-js`` propriety can be assigned to an options group"
" in order to define a custom method. Let’s create one for our *testimonials "
"snippet* by adding a ``data-js`` attribute to the option’s group div that we"
" created earlier."
msgstr "正如我们之前所说, ``数据js`` 礼可以以定义一个自定义的方法被分配到一个选项组。让我们创建一个为我们的 *见证片断加入了 ``数据js`` 属性, 我们前面创建的选项的组格* 。"

#: ../../howtos/themes.rst:778
msgid ""
"Done. From now on, the Website Builder will look for a "
"``snippet_testimonial_options`` method each time the publisher enters in "
"edit mode."
msgstr "完成。从现在起, 该网站生成器将每个出版商进入编辑模式的时间寻找一个 ``snippet_testimonial_options`` 方法。"

#: ../../howtos/themes.rst:782
msgid ""
"Let's go one step further by creating a javascript file, name it "
"**tutorial_editor.js** and place it into the **static** folder.  Copy/paste "
"the following code"
msgstr "让我们再进一步通过创建一个JavaScript文件, 将其命名为 **tutorial_editor.js** , 并将其放置到 **静态** 文件夹。复制/粘贴以下代码"

#: ../../howtos/themes.rst:794
msgid ""
"Great, we successfully created our javascript editor file. This file will "
"contain all the javascript functions used by our snippets in edit mode. "
"Let’s create a new function for our testimonial snippet using the "
"``snippet_testimonial_options`` method that we created before."
msgstr "太好了, 我们成功地创建了JavaScript编辑器文件。该文件将包含所有在编辑模式下使用我们的片段的JavaScript功能。让我们创建一个新的功能, 为我们的证词片段使用我们之前创建的 ``snippet_testimonial_options`` 方法。"

#: ../../howtos/themes.rst:810
msgid ""
"As you will notice, we used a method called ``on_focus`` to trigger our "
"function. The Website Builder provides several events you can use to trigger"
" your custom functions."
msgstr "正如你会发现, 我们使用了一种名为 ``on_focus`` 方法来触发我们的函数。网站建设者提供了一些事件, 你可以用它来触发您的自定义功能。"

#: ../../howtos/themes.rst:813
msgid "Event"
msgstr "大事"

#: ../../howtos/themes.rst:813
msgid "Description"
msgstr "描写"

#: ../../howtos/themes.rst:815
msgid "``start``"
msgstr " ``start`` "

#: ../../howtos/themes.rst:815
msgid ""
"Fires when the publisher selects the snippet for the first time in an "
"editing session or when the snippet is drag-dropped into the page"
msgstr "当发行选择片段的第一次在编辑会话或当片段是拖落入页火灾"

#: ../../howtos/themes.rst:816
msgid "``on_focus``"
msgstr "``on_focus``"

#: ../../howtos/themes.rst:816
msgid ""
"Fires each time the snippet is selected by the user or when the snippet is "
"drag-dropped into the page."
msgstr "触发代码段由用户选择或当片段是拖落入页各一次。"

#: ../../howtos/themes.rst:817
msgid "``on_blur``"
msgstr "``on_blur``"

#: ../../howtos/themes.rst:817
msgid "This event occurs when a snippet loses focus."
msgstr "当一个片段失去焦点时发生此事件。"

#: ../../howtos/themes.rst:818
msgid "``on_clone``"
msgstr "``on_clone``"

#: ../../howtos/themes.rst:818
msgid ""
"Fires just after a snippet is duplicated. A new js variable is created "
"($clone) containing the cloned element."
msgstr "Fires just after a snippet is duplicated. A new js variable is created ($clone) containing the cloned element."

#: ../../howtos/themes.rst:819
msgid "``on_remove``"
msgstr "``on_remove``"

#: ../../howtos/themes.rst:819
msgid "It occurs just before that the snippet is removed."
msgstr "这只是该段被删除之前发生。"

#: ../../howtos/themes.rst:820
msgid "``drop_and_build_snippet``"
msgstr " ``drop_and_build_snippet`` "

#: ../../howtos/themes.rst:820
msgid ""
"Fires just after that the snippet is drag and dropped into a drop zone. When"
" this event is triggered, the content is already inserted in the page."
msgstr "火灾刚过, 该片段是阻力, 投进一个放置区。当该事件被触发, 内容已插入在页面中。"

#: ../../howtos/themes.rst:821
msgid "``clean_for_save``"
msgstr " ``clean_for_save`` "

#: ../../howtos/themes.rst:821
msgid "It trigger before the publisher save the page."
msgstr "这引发之前发布保存页面。"

#: ../../howtos/themes.rst:824
msgid ""
"Let’s add our new javascript files to the editor assets list. Go back to "
"**assets.xml** and create a new template like the previous one. This time we"
" have to inherit ``assets_editor`` instead of ``assets_frontend``."
msgstr "让我们添加新的JavaScript文件的编辑器的资产清单。回到 **assets.xml** 和创建像上一个新的模板。这一次, 我们要继承 ``assets_editor`` , 而不是 ``assets_frontend`` 。"

#: ../../howtos/themes.rst:841
msgid ""
"Let’s test our new javascript function. Enter in Edit mode and drop into the"
" page. You should now see the javascript alert that we bound on the "
"``on_focus`` event. If you close it, then click outside of your snippet and "
"then click in it again, the event will trigger again."
msgstr "让我们来测试我们新的JavaScript功能。进入编辑模式拖放到页面中。您现在应该看到, 我们绑定在 ``on_focus`` 事件的JavaScript警告。如果你关闭它, 然后单击您的片段之外, 然后再次单击它, 该事件将再次触发。"

#: ../../howtos/themes.rst:851
msgid "Editing Reference Guide"
msgstr "编辑参考指南"

#: ../../howtos/themes.rst:853
msgid ""
"Basically all the elements in a page can be edited by the publisher. Besides"
" that, some element types and css classes will trigger special Website "
"Builder functionalities when edited."
msgstr "基本上在一个页面中的所有元素可以由出版商进行编辑。除此之外, 一些元素类型和CSS类编辑时, 将触发特殊网站制作功能。"

#: ../../howtos/themes.rst:857
msgid "Layout"
msgstr "布局"

#: ../../howtos/themes.rst:860
msgid "``<section />``"
msgstr "``<section />``"

#: ../../howtos/themes.rst:860
msgid ""
"Any section element can be edited like a block of content. The publisher can"
" move or duplicate it. It’s also possible to set a background image or "
"color. Section is the standard main container of any snippet."
msgstr "任何部分元件可以被编辑等的内容的块。发布者可以移动或复制它。它也可以设置一个背景图像或颜色。科任何片段标准的主容器。"

#: ../../howtos/themes.rst:863
msgid "``.row > .col-md-*``"
msgstr "``.row > .col-md-*``"

#: ../../howtos/themes.rst:863
msgid ""
"Any medium  bootstrap columns  directly descending from a .row element, will"
" be resizable by the publisher."
msgstr "任何媒体引导列从.row元直接下降, 将调整大小由出版商。"

#: ../../howtos/themes.rst:866
msgid "``contenteditable=\"False\"``"
msgstr " ``CONTENTEDITABLE ='假'`` "

#: ../../howtos/themes.rst:866
msgid ""
"This attribute will prevent editing to the element and all its children."
msgstr "此属性将防止编辑的元素及其所有子项。"

#: ../../howtos/themes.rst:869
msgid "``contenteditable=\"True\"``"
msgstr " ``CONTENTEDITABLE ='真正的'`` "

#: ../../howtos/themes.rst:869
msgid ""
"Apply it to an element inside a contenteditable=\"False\" element in order "
"to create an exception and make the element and its children editable."
msgstr "为了创建一个例外, 使元件及其子编辑它应用到一个内部CONTENTEDITABLE ='假'元素的元素。"

#: ../../howtos/themes.rst:872
msgid "``<a href=”#” />``"
msgstr "``<a href=”#” />``"

#: ../../howtos/themes.rst:872
msgid ""
"In Edit Mode, any link can be edited and styled. Using the “Link Modal” it’s"
" also possible to replace it with a button."
msgstr "在编辑模式下, 任何一个环节可以编辑和风格。使用“链接莫代尔\" 它也可以将其与一个按钮代替。 "

#: ../../howtos/themes.rst:875
msgid "Media"
msgstr "媒体"

#: ../../howtos/themes.rst:877
msgid "``<span class=”fa” />``"
msgstr " ``<span class=\" fa \"/>`` "

#: ../../howtos/themes.rst:877
msgid ""
"Pictogram elements. Editing this element will open the Pictogram library to "
"replace the icon. It’s also possible to transform the elements using CSS."
msgstr "象形元素。编辑该元素将打开象形库替换图标。它也可以转换使用CSS的元素。"

#: ../../howtos/themes.rst:880
msgid "``<img />``"
msgstr " ``<img />`` "

#: ../../howtos/themes.rst:880
msgid ""
"Once clicked, the Image Library will open and you can replace images. "
"Transformation is also possible for this kind of element."
msgstr "一旦点击, 图片库将打开, 您可以替换的图像。变换也可以用于这种元件的。"

#: ../../howtos/themes.rst:890
msgid ""
"This html structure will create an ``<iframe>`` element editable by the "
"publisher."
msgstr "This html structure will create an ``<iframe>`` element editable by the publisher."

#: ../../howtos/themes.rst:895
msgid "SEO best practice"
msgstr "搜索引擎优化的最佳实践"

#: ../../howtos/themes.rst:898
msgid "Facilitate content insertion"
msgstr "促进内容插入"

#: ../../howtos/themes.rst:900
msgid ""
"Modern search engine algorithms increasingly focus on content, which means "
"there is less focus on **keyword saturation** and more focus on whether or "
"not the content is **actually relevant to the keywords**."
msgstr "现代搜索引擎算法越来越注重内容, 这意味着有不太注重 **关键字饱和** 更加注重与否的内容被 **实际相关的关键字** 。"

#: ../../howtos/themes.rst:902
msgid ""
"As content is so important for SEO, you should concentrate on giving "
"publishers the tools to easily insert it. It is important that your snippets"
" are “content-responsive”, meaning that they should fit the publisher’s "
"content regardless of size."
msgstr "至于内容是搜索引擎优化很重要, 你应该集中精力使出版商的工具很容易插入。重要的是, 你的片段是“内容敏感\" , 这意味着他们应该不管大小适合出版商的内容。 "

#: ../../howtos/themes.rst:904
msgid ""
"Let’s have a look to this example of a classic two column snippet, "
"implemented in two different ways."
msgstr "让我们来看看一个典型的两列片段的这个例子中, 两种不同的方式来实现。"

#: ../../howtos/themes.rst:913
msgid "Bad"
msgstr "糟糕"

#: ../../howtos/themes.rst:915
msgid ""
"Using fixed image, the publisher will be forced to limit the text in order "
"to follow the layout."
msgstr "使用固定的图像, 发布者将被迫限制文本以按照布局。"

#: ../../howtos/themes.rst:924
msgid "Good"
msgstr "优秀"

#: ../../howtos/themes.rst:926
msgid ""
"Using background images that fit the column height, the publisher will be "
"free to add the content regardless of the image’s height."
msgstr "使用适合的柱高的背景图片, 发布者将免费不顾形象的高度来添加内容。"

#: ../../howtos/themes.rst:931
msgid "Page segmentation"
msgstr "页面分割"

#: ../../howtos/themes.rst:933
msgid ""
"Basically, page segmentation means that a page is divided into several "
"separate parts and these parts are treated as separate entries by search "
"engines. When you design pages or snippets, you should be sure to use the "
"right tags in order to facilitate search engine indexing."
msgstr "基本上, 页分割意味着一个页面被分成几个独立的部分和这些部分被作为被搜索引擎单独条目。当你设计网页或片段, 你应该确保使用正确的标签, 以便于搜索引擎索引。"

#: ../../howtos/themes.rst:937
msgid "``<article>``"
msgstr "``<article>``"

#: ../../howtos/themes.rst:937
msgid ""
"Specifies an independent block of content. Within it should be a piece of "
"self-contained content that should make sense on its own. You can nest "
"``<article>`` elements within one another. In this case, it’s implied that "
"the nested elements are related to the outer ``<article>`` element."
msgstr "Specifies an independent block of content. Within it should be a piece of self-contained content that should make sense on its own. You can nest ``<article>`` elements within one another. In this case, it’s implied that the nested elements are related to the outer ``<article>`` element."

#: ../../howtos/themes.rst:940
msgid "``<header>``"
msgstr " ``<header>`` "

#: ../../howtos/themes.rst:940
msgid ""
"Indicates the header section of a self-contained block of content (an "
"``<article>``)."
msgstr "Indicates the header section of a self-contained block of content (an ``<article>`` )."

#: ../../howtos/themes.rst:943
msgid "``<section>``"
msgstr "``<section>``"

#: ../../howtos/themes.rst:943
msgid ""
"Is the snippet default tag and it specifies a subsection of a block of "
"content. It can be used to split ``<article>`` content into several parts. "
"It’s advisable to use a heading element (``<h1>`` – ``<h6>``) to define the "
"section’s topic."
msgstr "Is the snippet default tag and it specifies a subsection of a block of content. It can be used to split ``<article>`` content into several parts. It’s advisable to use a heading element ( ``<h1>`` – ``<h6>`` ) to define the section’s topic."

#: ../../howtos/themes.rst:953
msgid "``<hgroup>``"
msgstr " ``<hgroup>`` "

#: ../../howtos/themes.rst:946
msgid ""
"Is used to wrap a section of headings (``<h1>`` - ``<h6>``). A great example"
" would be an article with both a headline and sub-headline at the top:"
msgstr "Is used to wrap a section of headings ( ``<h1>`` - ``<h6>`` ). A great example would be an article with both a headline and sub-headline at the top :"

#: ../../howtos/themes.rst:956
msgid "Describe your page"
msgstr "描述你的页面"

#: ../../howtos/themes.rst:959
msgid "Define keywords"
msgstr "定义关键字"

#: ../../howtos/themes.rst:960
msgid ""
"You should use appropriate, relevant keywords and synonyms for those "
"keywords. You can define them for each page using the built-in “Promote” "
"function found in the bar at the top."
msgstr "你应该使用合适的, 相关的关键字和同义词这些关键字。你可以将它们定义为使用在酒吧顶部发现内置的“促进\" 作用的每一页。 "

#: ../../howtos/themes.rst:963
msgid "Define a title and a description"
msgstr "定义一个标题和描述"

#: ../../howtos/themes.rst:965
msgid ""
"Define them using the “Promote” function. Keep your page titles short and "
"include the main keyword phrase for the page. Good titles evoke an emotional"
" response, ask a question or promise something."
msgstr "使用“促进\" 的功能定义。保持你的网页标题短, 包括的主要关键字短语的网页。好的标题引起的情绪反应, 问一个问题或承诺的东西。 "

#: ../../howtos/themes.rst:968
msgid ""
"Descriptions, while not important to search engine rankings, are extremely "
"important in gaining user click-through. These are an opportunity to "
"advertise content and to let people searching know exactly whether the given"
" page contains the information they're looking for. It is important that "
"titles and descriptions on each page are unique."
msgstr "说明, 而不是重要的搜索引擎排名, 在获得用户的点击非常重要的。这是一个机会, 宣传的内容, 并让人们知道搜索所给出的页面完全相同是否包含他们正在寻找的信息。重要的是, 在每一页上的标题和描述是唯一的。"

#: ../../howtos/web.rst:5
msgid "Building Interface Extensions"
msgstr "建造界面扩展"

#: ../../howtos/web.rst:11
msgid "This guide is about creating modules for Odoo's web client."
msgstr "本指南是有关Odoo的Web客户端创建模块。"

#: ../../howtos/web.rst:13
msgid ""
"To create websites with Odoo, see :doc:`website`; to add business "
"capabilities or extend existing business systems of Odoo, see "
":doc:`backend`."
msgstr "要创建具有Odoo网站, 看到:文档:`website` ;添加业务功能或扩展Odoo的现有业务系统, 请参阅:DOC:`backend` 。"

#: ../../howtos/web.rst:18
msgid "This guide assumes knowledge of:"
msgstr "本指南假定的知识:"

#: ../../howtos/web.rst:20
msgid "Javascript basics and good practices"
msgstr "Javascript的基础知识和优秀实践"

#: ../../howtos/web.rst:21
msgid "jQuery_"
msgstr "jQuery_"

#: ../../howtos/web.rst:22
msgid "`Underscore.js`_"
msgstr " `Underscore.js` _"

#: ../../howtos/web.rst:24
msgid "It also requires :ref:`an installed Odoo <setup/install>`, and Git_."
msgstr "It also requires :ref:`an installed Odoo <setup/install>` , and Git_."

#: ../../howtos/web.rst:28
msgid "A Simple Module"
msgstr "一个简单的模块"

#: ../../howtos/web.rst:30
msgid ""
"Let's start with a simple Odoo module holding basic web component "
"configuration and letting us test the web framework."
msgstr "让我们从一个简单的Odoo模块保持基本的Web组件的配置, 让我们测试的Web框架。"

#: ../../howtos/web.rst:33
msgid ""
"The example module is available online and can be downloaded using the "
"following command:"
msgstr "这个例子模块可在网上, 可以用下面的命令下载:"

#: ../../howtos/web.rst:40
msgid ""
"This will create a ``petstore`` folder wherever you executed the command. "
"You then need to add that folder to Odoo's :option:`addons path <odoo.py "
"--addons-path>`, create a new database and install the ``oepetstore`` "
"module."
msgstr "This will create a ``petstore`` folder wherever you executed the command. You then need to add that folder to Odoo's :option:`addons path <odoo.py --addons-path>` , create a new database and install the ``oepetstore`` module."

#: ../../howtos/web.rst:45
msgid ""
"If you browse the ``petstore`` folder, you should see the following content:"
msgstr "如果你浏览 ``petstore`` 文件夹, 你应该看到以下内容:"

#: ../../howtos/web.rst:71
msgid ""
"The module already holds various server customizations. We'll come back to "
"these later, for now let's focus on the web-related content, in the "
"``static`` folder."
msgstr "该模块已经拥有各种服务器的自定义。我们再回过头来这些之后, 现在让我们专注于网络相关的内容, 在 ``static`` 文件夹。"

#: ../../howtos/web.rst:75
msgid ""
"Files used in the \"web\" side of an Odoo module must be placed in a "
"``static`` folder so they are available to a web browser, files outside that"
" folder can not be fetched by browsers. The ``src/css``, ``src/js`` and "
"``src/xml`` sub-folders are conventional and not strictly necessary."
msgstr "在使用的文件“网络'的Odoo模块的一侧必须放置在一个 ``static`` 文件夹, 以便它们可用于Web浏览器, 该文件夹之外的文件无法通过浏览器获取。该 ``SRC / css`` , ``SRC / js`` 和 ``的src / xml`` 子文件夹都是常规的, 不是绝对必要的。"

#: ../../howtos/web.rst:80
msgid "``oepetstore/static/css/petstore.css``"
msgstr "``oepetstore/static/css/petstore.css``"

#: ../../howtos/web.rst:81
msgid "Currently empty, will hold the CSS_ for pet store content"
msgstr "Currently empty, will hold the CSS_ for pet store content"

#: ../../howtos/web.rst:82
msgid "``oepetstore/static/xml/petstore.xml``"
msgstr "``oepetstore/static/xml/petstore.xml``"

#: ../../howtos/web.rst:83
msgid "Mostly empty, will hold :ref:`reference/qweb` templates"
msgstr "不多数空白, 将保持 :ref:`reference/qweb` 模板"

#: ../../howtos/web.rst:102
msgid "``oepetstore/static/js/petstore.js``"
msgstr "``oepetstore/static/js/petstore.js``"

#: ../../howtos/web.rst:85
msgid ""
"The most important (and interesting) part, contains the logic of the "
"application (or at least its web-browser side) as javascript. It should "
"currently look like::"
msgstr "最重要的（和有趣）的一部分, 包含应用程序（或者至少其网络浏览器侧）的JavaScript的逻辑。它应该现在看起来像 ::"

#: ../../howtos/web.rst:104
msgid "Which only prints a small message in the browser's console."
msgstr "其中仅打印在浏览器的控制台一个小的消息。"

#: ../../howtos/web.rst:106
msgid ""
"The files in the ``static`` folder, need to be defined within the module in "
"order for them to be loaded correctly. Everything in ``src/xml`` is defined "
"in ``__openerp__.py`` while the contents of ``src/css`` and ``src/js`` are "
"defined in ``petstore.xml``, or a similar file."
msgstr "The files in the ``static`` folder, need to be defined within the module in order for them to be loaded correctly. Everything in ``src/xml`` is defined in ``__openerp__.py`` while the contents of ``src/css`` and ``src/js`` are defined in ``petstore.xml``, or a similar file."

#: ../../howtos/web.rst:110
msgid ""
"All JavaScript files are concatenated and :term:`minified` to improve "
"application load time."
msgstr "所有的JavaScript文件都串联和 :term:`minified` 提高应用程序的加载时间。"

#: ../../howtos/web.rst:113
msgid ""
"One of the drawback is debugging becomes more difficult as individual files "
"disappear and the code is made significantly less readable. It is possible "
"to disable this process by enabling the \"developer mode\": log into your "
"Odoo instance (user *admin* password *admin* by default) open the user menu "
"(in the top-right corner of the Odoo screen) and select :guilabel:`About "
"Odoo` then :guilabel:`Activate the developer mode`:"
msgstr "其中一个缺点就是调试变得更加困难, 因为单个文件消失, 代码显著的可读性进行。它可以通过启用'开发模式'禁用此过程:登录到您的Odoo实例（用户 *管理员密码* 管理 *默认情况下）打开用户菜单（在Odoo屏幕的右上角）并选择 :guilabel:`关于Odoo` 则 :guilabel:`激活开发商mode` :"

#: ../../howtos/web.rst:127
msgid ""
"This will reload the web client with optimizations disabled, making "
"development and debugging significantly more comfortable."
msgstr "这将重新加载Web客户端与优化禁用, 使得开发和调试显著更舒适。"

#: ../../howtos/web.rst:133
msgid "Odoo JavaScript Module"
msgstr "Odoo的JavaScript模块"

#: ../../howtos/web.rst:135
msgid ""
"Javascript doesn't have built-in modules. As a result variables defined in "
"different files are all mashed together and may conflict. This has given "
"rise to various module patterns used to build clean namespaces and limit "
"risks of naming conflicts."
msgstr "JavaScript没有内置模块。其结果是在不同的文件中定义的变量都一起捣碎, 并可能会发生冲突。这已经引起了用于构建清洁命名空间和限制命名冲突的风险, 各种模块的模式。"

#: ../../howtos/web.rst:140
msgid ""
"The Odoo framework uses one such pattern to define modules within web "
"addons, in order to both namespace code and correctly order its loading."
msgstr "该Odoo框架使用这样一个模式的网络插件中定义的模块, 以这两个命名空间的代码并正确责令其装载。"

#: ../../howtos/web.rst:143
msgid "``oepetstore/static/js/petstore.js`` contains a module declaration::"
msgstr " ``oepetstore /静态/ JS / petstore.js`` 包含模块声明 ::"

#: ../../howtos/web.rst:149
msgid ""
"In Odoo web, modules are declared as functions set on the global ``openerp``"
" variable. The function's name must be the same as the addon (in this case "
"``oepetstore``) so the framework can find it, and automatically initialize "
"it."
msgstr "在Odoo网, 模块被声明为对全球 ``openerp`` 变量设置功能。函数名必须是相同的插件（在这种情况下, ``oepetstore`` ）, 以使框架可以找到它, 并自动将其初始化。"

#: ../../howtos/web.rst:153
msgid ""
"When the web client loads your module it will call the root function and "
"provide two parameters:"
msgstr "当Web客户端加载你的模块, 它会调用根的功能, 并提供两个参数:"

#: ../../howtos/web.rst:156
msgid ""
"the first parameter is the current instance of the Odoo web client, it gives"
" access to various capabilities defined by the Odoo (translations, network "
"services) as well as objects defined by the core or by other modules."
msgstr "第一个参数是所述Odoo web客户端的当前实例, 它可以访问由芯, 或者由其他的模块中定义的Odoo（翻译, 网络服务）中所定义的各种功能, 以及对象。"

#: ../../howtos/web.rst:160
msgid ""
"the second parameter is your own local namespace automatically created by "
"the web client. Objects and variables which should be accessible from "
"outside your module (either because the Odoo web client needs to call them "
"or because others may want to customize them) should be set inside that "
"namespace."
msgstr "第二个参数是由web客户端自动创建了自己的局部命名空间。对象和这应该是从你的模块外部访问变量（或者是因为Odoo Web客户端需要打电话给他们, 或者因为其他人可能要对其进行自定义）, 应在该命名空间中设置。"

#: ../../howtos/web.rst:167
msgid "Classes"
msgstr "类"

#: ../../howtos/web.rst:169
msgid ""
"Much as modules, and contrary to most object-oriented languages, javascript "
"does not build in *classes*\\ [#classes]_ although it provides roughly "
"equivalent (if lower-level and more verbose) mechanisms."
msgstr "就像模块, 并与大多数面向对象的语言, JavaScript不建立在 *类* \\ [#classes] _虽然它提供了大致相当于（如果较低水平, 更详细）的机制。"

#: ../../howtos/web.rst:173
msgid ""
"For simplicity and developer-friendliness Odoo web provides a class system "
"based on John Resig's `Simple JavaScript Inheritance`_."
msgstr "为了简单和开发友好，Odoo web提供了基于John Resig 的 `Simple JavaScript Inheritance`_ 的类型系统。"

#: ../../howtos/web.rst:176
msgid ""
"New classes are defined by calling the :func:`~openerp.web.Class.extend` "
"method of :class:`openerp.web.Class`::"
msgstr ":func:`~的openerp.web.Class.extend` 方法 :class: 新类是通过调用定义 `openerp.web.Class` ::"

#: ../../howtos/web.rst:185
msgid ""
"The :func:`~openerp.web.Class.extend` method takes a dictionary describing "
"the new class's content (methods and static attributes). In this case, it "
"will only have a ``say_hello`` method which takes no parameters."
msgstr "本 :func:`~openerp.web.Class.extend` 方法需要一个字典描述新类的内容（方法和静态属性）。在这种情况下, 只会有一个 ``say_hello`` 方法, 它不带任何参数。"

#: ../../howtos/web.rst:189
msgid "Classes are instantiated using the ``new`` operator::"
msgstr "类是使用 ``new`` 操作符创建 ::"

#: ../../howtos/web.rst:195
msgid "And attributes of the instance can be accessed via ``this``::"
msgstr "和实例的属性可以通过 ``this`` 访问 ::"

#: ../../howtos/web.rst:208
msgid ""
"Classes can provide an initializer to perform the initial setup of the "
"instance, by defining an ``init()`` method. The initializer receives the "
"parameters passed when using the ``new`` operator::"
msgstr "类可以提供一个初始执行实例的初始设置, 通过定义一个 ``的init（）`` 方法。在初始化接收使用 ``new`` 运营商时传递的参数 ::"

#: ../../howtos/web.rst:225
msgid ""
"It is also possible to create subclasses from existing (used-defined) "
"classes by calling :func:`~openerp.web.Class.extend` on the parent class, as"
" is done to subclass :class:`~openerp.web.Class`::"
msgstr "它也可以通过调用现有的（使用的定义）的类创建子类 :func:`~openerp.web.Class.extend` 在父类, 如做是为了子类 :class:`~openerp.web.Class` ::"

#: ../../howtos/web.rst:239
msgid ""
"When overriding a method using inheritance, you can use ``this._super()`` to"
" call the original method::"
msgstr "当使用继承覆盖方法时, 你可以使用 ``this._super()``  来调用原始方法 ::"

#: ../../howtos/web.rst:255
msgid ""
"``_super`` is not a standard method, it is set on-the-fly to the next method"
" in the current inheritance chain, if any. It is only defined during the "
"*synchronous* part of a method call, for use in asynchronous handlers (after"
" network calls or in ``setTimeout`` callbacks) a reference to its value "
"should be retained, it should not be accessed via ``this``::"
msgstr " ``_super`` 是不是一个标准的方法, 它被设置在最飞到下一个方法在目前的继承链, 如果有的话。它仅在定义 *同步* 方法调用的一部分, 在异步处理程序使用（在网络电话或 ``setTimeout`` 回调）的引用, 其​​值应予以保留, 不应该通过 ``访问this`` ::"

#: ../../howtos/web.rst:278
msgid "Widgets Basics"
msgstr "挂件基础"

#: ../../howtos/web.rst:280
msgid ""
"The Odoo web client bundles jQuery_ for easy DOM manipulation. It is useful "
"and provides a better API than standard `W3C DOM`_\\ [#dombugs]_, but "
"insufficient to structure complex applications leading to difficult "
"maintenance."
msgstr "该Odoo Web客户端捆绑jQuery_, 方便DOM操作。它是有用的, 并提供了比标准'W3C更好的API DOM `_ \\ [#dombugs] _, 但不足以构建复杂的应用程序, 导致维护困难。"

#: ../../howtos/web.rst:285
msgid ""
"Much like object-oriented desktop UI toolkits (e.g. Qt_, Cocoa_ or GTK_), "
"Odoo Web makes specific components responsible for sections of a page. In "
"Odoo web, the base for such components is the :class:`~openerp.Widget` "
"class, a component specialized in handling a page section and displaying "
"information for the user."
msgstr "很像面向对象的桌面UI工具箱（例如Qt_, Cocoa_或GTK_）, Odoo网络使得特定组件负责一个页面的部分。在Odoo网络, 底座为这些部件是 :class:`~openerp.Widget` 类, 一个专门处理一个页面部分和显示信息的用户组件。"

#: ../../howtos/web.rst:292
msgid "Your First Widget"
msgstr "你的第一个小部件"

#: ../../howtos/web.rst:294
msgid "The initial demonstration module already provides a basic widget::"
msgstr "最初的显示模块已经提供了基本的小部件 ::"

#: ../../howtos/web.rst:302
msgid ""
"It extends :class:`~openerp.Widget` and overrides the standard method "
":func:`~openerp.Widget.start`, which — much like the previous ``MyClass`` — "
"does little for now."
msgstr "它扩展 :class:`~openerp.Widget` 和覆盖的标准方法 :func:`~openerp.Widget.start` , 其中 - 就像以前的 ``MyClass`` - 现在确实很少。"

#: ../../howtos/web.rst:306
msgid "This line at the end of the file::"
msgstr "这条线在文件的结尾 ::"

#: ../../howtos/web.rst:311
msgid ""
"registers our basic widget as a client action. Client actions will be "
"explained later, for now this is just what allows our widget to be called "
"and displayed when we select the :menuselection:`Pet Store --> Pet Store -->"
" Home Page` menu."
msgstr "注册我们的基本部件为一个客户端操作。客户端的操作将在后面解释, 现在这正是让我们的小部件被调用, 显示当我们选择 :menuselection:`宠物商店 - >宠物商店 - >首页Page` 菜单。"

#: ../../howtos/web.rst:318
msgid ""
"because the widget will be called from outside our module, the web client "
"needs its \"fully qualified\" name, not the local version."
msgstr "因为小部件会从我们的模块外部调用, Web客户端需要的'完全合格的'名称, 而不是本地版本。"

#: ../../howtos/web.rst:322
msgid "Display Content"
msgstr "显示内容"

#: ../../howtos/web.rst:324
msgid ""
"Widgets have a number of methods and features, but the basics are simple:"
msgstr "挂件具有许多方法和特征, 但基本是简单:"

#: ../../howtos/web.rst:326
msgid "set up a widget"
msgstr "成立了一个小部件"

#: ../../howtos/web.rst:327
msgid "format the widget's data"
msgstr "格式化挂件的数据"

#: ../../howtos/web.rst:328
msgid "display the widget"
msgstr "显示部件"

#: ../../howtos/web.rst:330
msgid ""
"The ``HomePage`` widget already has a :func:`~openerp.Widget.start` method. "
"That method is part of the normal widget lifecycle and automatically called "
"once the widget is inserted in the page. We can use it to display some "
"content."
msgstr "该 ``HomePage`` 部件已经具备了 :func:`~openerp.Widget.start` 方法。该方法是在正常插件生命周期的一部分, 并且一旦插件被插入在页面自动调用。我们可以用它来显示一些内容。"

#: ../../howtos/web.rst:335
msgid ""
"All widgets have a :attr:`~openerp.Widget.$el` which represents the section "
"of page they're in charge of (as a jQuery_ object). Widget content should be"
" inserted there. By default, :attr:`~openerp.Widget.$el` is an empty "
"``<div>`` element."
msgstr "All widgets have a :attr:`~openerp.Widget.$el` which represents the section of page they're in charge of (as a jQuery_ object). Widget content should be inserted there. By default, :attr:`~openerp.Widget.$el` is an empty ``<div>`` element."

#: ../../howtos/web.rst:340
msgid ""
"A ``<div>`` element is usually invisible to the user if it has no content "
"(or without specific styles giving it a size) which is why nothing is "
"displayed on the page when ``HomePage`` is launched."
msgstr "A ``<div>`` element is usually invisible to the user if it has no content (or without specific styles giving it a size) which is why nothing is displayed on the page when ``HomePage`` is launched."

#: ../../howtos/web.rst:344
msgid "Let's add some content to the widget's root element, using jQuery::"
msgstr "让我们添加一些内容到小部件的根元素, 使用jQuery ::"

#: ../../howtos/web.rst:352
msgid ""
"That message will now appear when you open :menuselection:`Pet Store --> Pet"
" Store --> Home Page`"
msgstr "当你打开将会出现该消息 :menuselection:`宠物商店 - >宠物商店 - >首页Page` "

#: ../../howtos/web.rst:357
msgid ""
"to refresh the javascript code loaded in Odoo Web, you will need to reload "
"the page. There is no need to restart the Odoo server."
msgstr "刷新Odoo网页加载JavaScript代码, 您需要重新加载页面。没有必要重新启动Odoo服务器。"

#: ../../howtos/web.rst:360
msgid ""
"The ``HomePage`` widget is used by Odoo Web and managed automatically. To "
"learn how to use a widget \"from scratch\" let's create a new one::"
msgstr "该 ``HomePage`` 小部件所使用的Odoo网络和自动管理。要了解如何“从头开始'用一个部件让我们创建一个新 ::"

#: ../../howtos/web.rst:369
msgid ""
"We can now add our ``GreetingsWidget`` to the ``HomePage`` by using the "
"``GreetingsWidget``'s :func:`~openerp.Widget.appendTo` method::"
msgstr "现在, 我们可以添加我们的 ``GreetingsWidget`` 的 ``使用`` GreetingsWidget ``的HomePage`` :func:`~openerp.Widget.appendTo` 方法 ::"

#: ../../howtos/web.rst:380
msgid "``HomePage`` first adds its own content to its DOM root"
msgstr " ``HomePage`` 第一添加自己的内容, 它的DOM根"

#: ../../howtos/web.rst:381
msgid "``HomePage`` then instantiates ``GreetingsWidget``"
msgstr " ``HomePage`` 然后实例 ``GreetingsWidget`` "

#: ../../howtos/web.rst:382
msgid ""
"Finally it tells ``GreetingsWidget`` where to insert itself, delegating part"
" of its :attr:`~openerp.Widget.$el` to the ``GreetingsWidget``."
msgstr "Finally it tells ``GreetingsWidget`` where to insert itself, delegating part of its :attr:`~openerp.Widget.$el` to the ``GreetingsWidget`` ."

#: ../../howtos/web.rst:385
msgid ""
"When the :func:`~openerp.Widget.appendTo` method is called, it asks the "
"widget to insert itself at the specified position and to display its "
"content. The :func:`~openerp.Widget.start` method will be called during the "
"call to :func:`~openerp.Widget.appendTo`."
msgstr "当 :func:`~openerp.Widget.appendTo` 方法被调用, 它要求的构件将自身插入到在指定位置, 并显示其内容。本 :func: :func:`~openerp.Widget.start` 方法将被调用过程中调用 `~openerp.Widget.appendTo` 。"

#: ../../howtos/web.rst:390
msgid ""
"To see what happens under the displayed interface, we will use the browser's"
" DOM Explorer. But first let's alter our widgets slightly so we can more "
"easily find where they are, by :attr:`adding a class to their root elements "
"<openerp.Widget.className>`::"
msgstr "要查看显示的界面下会发生什么, 我们将使用浏览器的DOM浏览器。但首先, 让我们改变我们的小部件稍微所以我们可以更容易地找到他们在哪里, 通过 :attr: 属性 `添加一个类的根元素<openerp.Widget.className>` ::"

#: ../../howtos/web.rst:404
msgid ""
"If you can find the relevant section of the DOM (right-click on the text "
"then :guilabel:`Inspect Element`), it should look like this:"
msgstr "如果你能找到的DOM的相关部分（在文本单击右键, 然后 :guilabel:`检查Element` ）, 它应该是这样的:"

#: ../../howtos/web.rst:416
msgid ""
"Which clearly shows the two ``<div>`` elements automatically created by "
":class:`~openerp.Widget`, because we added some classes on them."
msgstr "Which clearly shows the two ``<div>`` elements automatically created by :class:`~openerp.Widget` , because we added some classes on them."

#: ../../howtos/web.rst:419
msgid "We can also see the two message-holding divs we added ourselves"
msgstr "我们也可以看到我们增加了自己的两个消息, 控股的div"

#: ../../howtos/web.rst:421
msgid ""
"Finally, note the ``<div class=\"oe_petstore_greetings\">`` element which "
"represents the ``GreetingsWidget`` instance is *inside* the ``<div "
"class=\"oe_petstore_homepage\">`` which represents the ``HomePage`` "
"instance, since we appended"
msgstr "Finally, note the ``<div class=`` oe_petstore_greetings ``>`` element which represents the ``GreetingsWidget`` instance is *inside* the ``<div class=`` oe_petstore_homepage ``>`` which represents the ``HomePage`` instance, since we appended"

#: ../../howtos/web.rst:427
msgid "Widget Parents and Children"
msgstr "挂件父与子"

#: ../../howtos/web.rst:429
msgid "In the previous part, we instantiated a widget using this syntax::"
msgstr "在前面的部分, 我们实例使用此语法一个widget ::"

#: ../../howtos/web.rst:433
msgid ""
"The first argument is ``this``, which in that case was a ``HomePage`` "
"instance. This tells the widget being created which other widget is its "
"*parent*."
msgstr "第一个参数是 ``this`` , 这在这种情况下, 是一个 ``HomePage`` 实例。这告诉要创建哪些其他部件就是它的 *父* 小部件。"

#: ../../howtos/web.rst:437
msgid ""
"As we've seen, widgets are usually inserted in the DOM by another widget and"
" *inside* that other widget's root element. This means most widgets are "
"\"part\" of another widget, and exist on behalf of it. We call the container"
" the *parent*, and the contained widget the *child*."
msgstr "正如我们所看到的, 小部件通常是插在DOM被另一个小部件和 **内其他部件的根元素。这意味着大多数部件是'部分'另一个工具, 并有代表它。我们所说的容器中的 *母公司* , 和所含插件的子** 。"

#: ../../howtos/web.rst:442
msgid ""
"Due to multiple technical and conceptual reasons, it is necessary for a "
"widget to know who is its parent and who are its children."
msgstr "由于多个技术和概念的原因, 有必要对一个插件知道谁是它的父和谁是其子女。"

#: ../../howtos/web.rst:453
msgid ":func:`~openerp.Widget.getParent`"
msgstr ":func:`~openerp.Widget.getParent` "

#: ../../howtos/web.rst:446
msgid "can be used to get the parent of a widget::"
msgstr "可以用来得到一个小窗口的父 ::"

#: ../../howtos/web.rst:465
msgid ":func:`~openerp.Widget.getChildren`"
msgstr ":func:`~openerp.Widget.getChildren` "

#: ../../howtos/web.rst:456
msgid "can be used to get a list of its children::"
msgstr "可用于获取其子列表 ::"

#: ../../howtos/web.rst:467
msgid ""
"When overriding the :func:`~openerp.Widget.init` method of a widget it is "
"*of the utmost importance* to pass the parent to the ``this._super()`` call,"
" otherwise the relation will not be set up correctly::"
msgstr "当覆盖 :func: 至关重要 `~小部件openerp.Widget.init` 方法是 **的父母传递给 ``this._super（）`` 调用, 否则的关系将不会被设置正确 ::"

#: ../../howtos/web.rst:478
msgid ""
"Finally, if a widget does not have a parent (e.g. because it's the root "
"widget of the application), ``null`` can be provided as parent::"
msgstr "最后, 如​​果小窗口不具有父（例如, 因为它的应用程序的根插件）, ``null`` 可以被提供作为父 ::"

#: ../../howtos/web.rst:484
msgid "Destroying Widgets"
msgstr "销毁挂件"

#: ../../howtos/web.rst:486
msgid ""
"If you can display content to your users, you should also be able to erase "
"it. This is done via the :func:`~openerp.Widget.destroy` method::"
msgstr "如果你能显示的内容给你的用户, 你也应该能够将其删除。 :func: 这是通过做 `~openerp.Widget.destroy` 方法 ::"

#: ../../howtos/web.rst:491
msgid ""
"When a widget is destroyed it will first call "
":func:`~openerp.Widget.destroy` on all its children. Then it erases itself "
"from the DOM. If you have set up permanent structures in "
":func:`~openerp.Widget.init` or :func:`~openerp.Widget.start` which must be "
"explicitly cleaned up (because the garbage collector will not handle them), "
"you can override :func:`~openerp.Widget.destroy`."
msgstr "当小部件被销毁, 将首先调用 :func:`~openerp.Widget.destroy` 其所有的孩子。然后, 它会删除自己从DOM。如果您已经设置了永久的结构 :func:`~openerp.Widget.init` 或 :func:`~openerp.Widget.start` 必须明确清理（因为垃圾收集器将无法处理它们）, 你可以覆盖 :func:`~openerp.Widget.destroy` 。"

#: ../../howtos/web.rst:500
msgid ""
"when overriding :func:`~openerp.Widget.destroy`, ``_super()`` *must always* "
"be called otherwise the widget and its children are not correctly cleaned up"
" leaving possible memory leaks and \"phantom events\", even if no error is "
"displayed"
msgstr "重写时 :func:`~openerp.Widget.destroy` , ``_super（）`` *必须* 被调用, 否则小部件及其子没有正确地清理留下可能的内存泄漏和'幽灵事件', 即使显示没有错误"

#: ../../howtos/web.rst:506
msgid "The QWeb Template Engine"
msgstr "QWeb模板引擎"

#: ../../howtos/web.rst:508
msgid ""
"In the previous section we added content to our widgets by directly "
"manipulating (and adding to) their DOM::"
msgstr "在上一节, 我们添加的内容到我们的小部件通过直接操纵（和增加）其DOM ::"

#: ../../howtos/web.rst:513
msgid ""
"This allows generating and displaying any type of content, but gets unwieldy"
" when generating significant amounts of DOM (lots of duplication, quoting "
"issues, ...)"
msgstr "这允许生成并显示任何类型的内容, 但得到笨重产生显著量的DOM时（大量复制的, 引用的问题, ...）"

#: ../../howtos/web.rst:517
msgid ""
"As many other environments, Odoo's solution is to use a `template engine`_. "
"Odoo's template engine is called :ref:`reference/qweb`."
msgstr "如许多其他的环境, Odoo的解决方案是使用 `模板引擎` _。 Odoo的模板引擎被称为 :ref:`reference/qweb` 。"

#: ../../howtos/web.rst:520
msgid ""
"QWeb is an XML-based templating language, similar to `Genshi "
"<http://en.wikipedia.org/wiki/Genshi_(templating_language)>`_, `Thymeleaf "
"<http://en.wikipedia.org/wiki/Thymeleaf>`_ or `Facelets "
"<http://en.wikipedia.org/wiki/Facelets>`_. It has the following "
"characteristics:"
msgstr "QWeb 基于XML的模板语言, 类似于 `Genshi <http ://en.wikipedia.org/wiki/Genshi_(templating_language)>` _, `Thymeleaf <http: //en.wikipedia.org/wiki/Thymeleaf>` _ 以及 `Facelets <http ://en.wikipedia.org/wiki/Facelets>` _. 它有下面的特征:"

#: ../../howtos/web.rst:526
msgid "It's implemented fully in JavaScript and rendered in the browser"
msgstr "它在JavaScript中全面实施, 并在浏览器中呈现"

#: ../../howtos/web.rst:527
msgid "Each template file (XML files) contains multiple templates"
msgstr "每个模板文件（XML文件）中包含多个模板"

#: ../../howtos/web.rst:528
msgid ""
"It has special support in Odoo Web's :class:`~openerp.Widget`, though it can"
" be used outside of Odoo's web client (and it's possible to use "
":class:`~openerp.Widget` without relying on QWeb)"
msgstr "它在Odoo网络 :class:`~openerp.Widget` 有特殊支持 ,  尽管它可以在Odoo客户端外面使用（可以使用 :class:`~openerp.Widget` 而不依靠QWeb）"

#: ../../howtos/web.rst:534
msgid ""
"The rationale behind using QWeb instead of existing javascript template "
"engines is the extensibility of pre-existing (third-party) templates, much "
"like Odoo :ref:`views <reference/views>`."
msgstr "使用QWeb代替现有的JavaScript模板引擎背后的基本原理是，已存在的（第三方）的模板可扩展性, 就像Odoo :ref:`视图<reference/views>` 。"

#: ../../howtos/web.rst:538
msgid ""
"Most javascript template engines are text-based which precludes easy "
"structural extensibility where an XML-based templating engine can be "
"generically altered using e.g. XPath or CSS and a tree-alteration DSL (or "
"even just XSLT). This flexibility and extensibility is a core characteristic"
" of Odoo, and losing it was considered unacceptable."
msgstr "大多数JavaScript模板引擎是基于文本的, 这就排除方便结构延伸, 其中一个基于XML的模板引擎可以使用, 例如XPath或CSS和一棵树, 改变DSL（甚至只是XSLT）被统一更改。这种灵活性和可扩展性是Odoo的核心特征, 并失去它被认为是不可接受的。"

#: ../../howtos/web.rst:545
msgid "Using QWeb"
msgstr "使用QWeb"

#: ../../howtos/web.rst:547
msgid ""
"First let's define a simple QWeb template in the almost-empty "
"``oepetstore/static/src/xml/petstore.xml`` file:"
msgstr "首先, 让我们在几乎空白的 ``oepetstore/static/src/xml/petstore.xml`` 文件中定义一个简单QWeb模板:"

#: ../../howtos/web.rst:559
msgid ""
"Now we can use this template inside of the ``HomePage`` widget. Using the "
"``QWeb`` loader variable defined at the top of the page, we can call to the "
"template defined in the XML file::"
msgstr "现在我们可以在 ``HomePage`` 窗口小部件内使用这个模板。使用在页面顶部定义的 ``QWeb`` 装载机变量, 我们可以调用在XML文件中定义的模板 ::"

#: ../../howtos/web.rst:569
msgid ""
":func:`QWeb.render` looks for the specified template, renders it to a string"
" and returns the result."
msgstr ":func:`QWeb.render` 查找指定的模板, 将它渲染为一个字符串, 并返回结果。"

#: ../../howtos/web.rst:572
msgid ""
"However, because :class:`~openerp.Widget` has special integration for QWeb "
"the template can be set directly on the widget via its "
":attr:`~openerp.Widget.template` attribute::"
msgstr "但是, 因为 :class:`~openerp.Widget` 对于Qweb具有特殊的集成，模板可以通过小部件 :attr:`~openerp.Widget.template` 属性 直接设置 ::"

#: ../../howtos/web.rst:583
msgid ""
"Although the result looks similar, there are two differences between these "
"usages:"
msgstr "虽然结果看起来类似, 也有这些用法之间的两点不同:"

#: ../../howtos/web.rst:586
msgid ""
"with the second version, the template is rendered right before "
":func:`~openerp.Widget.start` is called"
msgstr "与第二个版本, 模板呈现的右前 :func:`~openerp.Widget.start` 被称为"

#: ../../howtos/web.rst:588
msgid ""
"in the first version the template's content is added to the widget's root "
"element, whereas in the second version the template's root element is "
"directly *set as* the widget's root element. Which is why the \"greetings\" "
"sub-widget also gets a red background"
msgstr "在第一个版本的模板的内容被添加到插件的根元素, 而在第二个版本的模板的根元素被直接 *设定为* 小窗口的根元素。这就是为什么'问候'子部件也得到一个红色背景"

#: ../../howtos/web.rst:595
msgid ""
"templates should have a single non-``t`` root element, especially if they're"
" set as a widget's :attr:`~openerp.Widget.template`. If there are multiple "
"\"root elements\", results are undefined (usually only the first root "
"element will be used and the others will be ignored)"
msgstr "模板应该有一个单一的非 ``t`` 根元素, 尤其是当它们设置为一个小部件的 :attr:`~openerp.Widget.template` 。如果有多个'根元素', 结果是不确定的（通常只有第一根元素将被使用, 其余将被忽略）"

#: ../../howtos/web.rst:601
msgid "QWeb Context"
msgstr "QWeb上下文"

#: ../../howtos/web.rst:603
msgid "QWeb templates can be given data and can contain basic display logic."
msgstr "QWeb模板可以给定数据, 并且可以包含基本的显示逻辑。"

#: ../../howtos/web.rst:605
msgid ""
"For explicit calls to :func:`QWeb.render`, the template data is passed as "
"second parameter::"
msgstr "对于显式调用 :func:`QWeb.render` , 模板数据被作为第二个参数传递 ::"

#: ../../howtos/web.rst:610
msgid "with the template modified to:"
msgstr "与模板修改为:"

#: ../../howtos/web.rst:618
msgid "will result in:"
msgstr "将导致:"

#: ../../howtos/web.rst:624
msgid ""
"When using :class:`~openerp.Widget`'s integration it is not possible to "
"provide additional data to the template. The template will be given a single"
" ``widget`` context variable, referencing the widget being rendered right "
"before :func:`~openerp.Widget.start` is called (the widget's state will "
"essentially be that set up by :func:`~openerp.Widget.init`):"
msgstr "当使用 :class:`~openerp.Widget` 一体化, 不可能提供附加数据的模板。该模板将被赋予一个单一的 ``widget`` 环境变量, 引用权利之前所呈现的部件 :func:`~openerp.Widget.start` 被称为（挂件的状态, 本质上是一个成立 :func:`~openerp.Widget.init` ）:"

#: ../../howtos/web.rst:648
msgid "Result:"
msgstr "结果:"

#: ../../howtos/web.rst:655
msgid "Template Declaration"
msgstr "模板声明"

#: ../../howtos/web.rst:657
msgid ""
"We've seen how to *render* QWeb templates, let's now see the syntax of the "
"templates themselves."
msgstr "我们已经看到了如何 *渲染* QWeb模板, 让我们现在来看看模板本身的语法。"

#: ../../howtos/web.rst:660
msgid ""
"A QWeb template is composed of regular XML mixed with QWeb *directives*. A "
"QWeb directive is declared with XML attributes starting with ``t-``."
msgstr "一个QWeb模板是混合了QWeb *指令* 的常规XML。一个QWeb指令声明是 ``t-`` 开头的XML属性。"

#: ../../howtos/web.rst:663
msgid ""
"The most basic directive is ``t-name``, used to declare new templates in a "
"template file:"
msgstr "最基本的指令是 ``t-name`` , 用来声明在模板文件中的新模板:"

#: ../../howtos/web.rst:674
msgid ""
"``t-name`` takes the name of the template being defined, and declares that "
"it can be called using :func:`QWeb.render`. It can only be used at the top-"
"level of a template file."
msgstr " ``t-name`` 从被定义的模板取名, 并声明它可以使用 :func:`QWeb.render` 调用。它只能用在模板文件的顶层。"

#: ../../howtos/web.rst:679
msgid "Escaping"
msgstr "逃离"

#: ../../howtos/web.rst:681
msgid "The ``t-esc`` directive can be used to output text:"
msgstr "该 ``t-esc`` 指令可以用来输出文本:"

#: ../../howtos/web.rst:687
msgid ""
"It takes a Javascript expression which is evaluated, the result of the "
"expression is then HTML-escaped and inserted in the document. Since it's an "
"expression it's possible to provide just a variable name as above, or a more"
" complex expression like a computation:"
msgstr "它需要一个被求值的表达式，表示的的结果被HTML转义, 并插入到文档中。因为它是一个表达式，它可能像上面一样只提供一个变量名, 或更复杂的表达式，例如一个计算:"

#: ../../howtos/web.rst:696
msgid "or method calls:"
msgstr "或方法调用:"

#: ../../howtos/web.rst:703
msgid "Outputting HTML"
msgstr "输出HTML"

#: ../../howtos/web.rst:705
msgid ""
"To inject HTML in the page being rendered, use ``t-raw``. Like ``t-esc`` it "
"takes an arbitrary Javascript expression as parameter, but it does not "
"perform an HTML-escape step."
msgstr "为了要呈现在页面注入HTML, 使用 ``t-raw`` 。像 ``t-esc`` 接受一个任意JavaScript表达式作为参数, 但是它不执行HTML转义步骤。"

#: ../../howtos/web.rst:715
msgid ""
"``t-raw`` *must not* be used on any data which may contain non-escaped user-"
"provided content as this leads to `cross-site scripting`_ vulnerabilities"
msgstr " ``叔raw`` *不能* 在其上可含有非转义用户提供的内容的任何数据被用作这导致 `跨站点scripting` _漏洞"

#: ../../howtos/web.rst:720
msgid "Conditionals"
msgstr "条件语句"

#: ../../howtos/web.rst:722
msgid ""
"QWeb can have conditional blocks using ``t-if``. The directive takes an "
"arbitrary expression, if the expression is falsy (``false``, ``null``, ``0``"
" or an empty string) the whole block is suppressed, otherwise it is "
"displayed."
msgstr "QWeb可以有条件块，使用 ``t-if`` 。该指令接受一个任意表达式, 如果表达式是否定（ ``false`` , ``null`` , ``0`` ，或空字符串）, 整个块被抑制, 否则它显示出来。"

#: ../../howtos/web.rst:739
msgid ""
"QWeb doesn't have an \"else\" structure, use a second ``t-if`` with the "
"original condition inverted. You may want to store the condition in a local "
"variable if it's a complex or expensive expression."
msgstr "QWeb不具有'else'结构, 使用第二个 ``t-if`` 带上相反原始条件。如果调节是一个复杂或者费时的表达式，你可能想在本地变量里面存储它。"

#: ../../howtos/web.rst:744
msgid "Iteration"
msgstr "迭代"

#: ../../howtos/web.rst:746
msgid ""
"To iterate on a list, use ``t-foreach`` and ``t-as``. ``t-foreach`` takes an"
" expression returning a list to iterate on ``t-as`` takes a variable name to"
" bind to each item during iteration."
msgstr "迭代一个列表, 使用 ``t-foreach`` 和 ``t-as`` 。 ``t-foreach`` 需要一个表达式，返回要迭代的列表， ``t-as`` 将一个变量名绑定到每一个迭代中的项目。"

#: ../../howtos/web.rst:760
msgid "``t-foreach`` can also be used with numbers and objects (dictionaries)"
msgstr " ``叔foreach`` 也可以用数字和对象（字典）中使用"

#: ../../howtos/web.rst:764
msgid "Defining attributes"
msgstr "定义属性"

#: ../../howtos/web.rst:766
msgid ""
"QWeb provides two related directives to define computed attributes: "
":samp:`t-att-{name}` and :samp:`t-attf-{name}`. In either case, *name* is "
"the name of the attribute to create (e.g. ``t-att-id`` defines the attribute"
" ``id`` after rendering)."
msgstr "QWeb提供了两个相关的指令来定义计算的属性 :samp:`t-att- {名}` 和 :samp:`t-attf- {名}` 。在这两种情况下, *名字* 是创建属性的名称（例如, ``t-ATt-id`` 定义渲染后的属性 ``id`` ）。"

#: ../../howtos/web.rst:771
msgid ""
"``t-att-`` takes a javascript expression whose result is set as the "
"attribute's value, it is most useful if all of the attribute's value is "
"computed:"
msgstr " ``t-att-`` 需要一个JavaScript表达式, 其结果被设置为属性的值, 如果所有的属性值是计算的，它是最有用的:"

#: ../../howtos/web.rst:782
msgid ""
"``t-attf-`` takes a *format string*. A format string is literal text with "
"interpolation blocks inside, an interpolation block is a javascript "
"expression between ``{{`` and ``}}``, which will be replaced by the result "
"of the expression. It is most useful for attributes which are partially "
"literal and partially computed such as a class:"
msgstr "``t-attf-`` 需要一个 *格式化字符串* 。格式字符串是含插块的文字文本, 插块是``{{`` 和``}}``之间的一个JavaScript表达式,  它将替换为表达式的值。对于属性是部分文本、部分是计算的很有用处，例如 类： "

#: ../../howtos/web.rst:795
msgid "Calling other templates"
msgstr "调用其他模板"

#: ../../howtos/web.rst:797
msgid ""
"Templates can be split into sub-templates (for simplicity, maintainability, "
"reusability or to avoid excessive markup nesting)."
msgstr "模板可以被分成子模板（为简单起见, 可维护性, 可重用性或避免过多的标记嵌套）。"

#: ../../howtos/web.rst:800
msgid ""
"This is done using the ``t-call`` directive, which takes the name of the "
"template to render:"
msgstr "使用 ``t-call`` 指令, 它采用了模板的名称来呈现这样做的是:"

#: ../../howtos/web.rst:814
msgid "rendering the ``A`` template will result in:"
msgstr "渲染 ``A`` 模板将导致:"

#: ../../howtos/web.rst:822
msgid "Sub-templates inherit the rendering context of their caller."
msgstr "子模板继承其调用者的渲染上下文。"

#: ../../howtos/web.rst:825
msgid "To Learn More About QWeb"
msgstr "学习更多QWeb"

#: ../../howtos/web.rst:827
msgid "For a QWeb reference, see :ref:`reference/qweb`."
msgstr "对于QWeb参考, 查看 :ref:`reference/qweb` 。"

#: ../../howtos/web.rst:830 ../../howtos/web.rst:1096
msgid "Exercise"
msgstr "练习"

#: ../../howtos/web.rst:832
msgid "Usage of QWeb in Widgets"
msgstr "在窗口小部件中的QWeb用法"

#: ../../howtos/web.rst:834
msgid ""
"Create a widget whose constructor takes two parameters aside from "
"``parent``: ``product_names`` and ``color``."
msgstr "创建挂件的构造函数有两个参数, 除了 ``parent`` :``product_names`` 和 ``color`` 。"

#: ../../howtos/web.rst:837
msgid ""
"``product_names`` should an array of strings, each one the name of a product"
msgstr " ``product_names`` 应该字符串数组, 一个产品的每一个名字"

#: ../../howtos/web.rst:839
msgid ""
"``color`` is a string containing a color in CSS color format (ie: "
"``#000000`` for black)."
msgstr " ``color`` 是包含CSS颜色格式颜色的字符串（例如:``＃000000`` 为黑色）。"

#: ../../howtos/web.rst:842
msgid ""
"The widget should display the given product names one under the other, each "
"one in a separate box with a background color with the value of ``color`` "
"and a border. You should use QWeb to render the HTML. Any necessary CSS "
"should be in ``oepetstore/static/src/css/petstore.css``."
msgstr "小部件应该一个接着一个显示给定的产品名称, 每一个在 ``color``  值指定背景颜色以及边框的独立盒子。你应当用Qweb呈现HTML。 任何必要的CSS应该在 ``oepetstore/static/src/css/petstore.css``."

#: ../../howtos/web.rst:847
msgid "Use the widget in ``HomePage`` with half a dozen products."
msgstr "使用Widget在 ``HomePage`` 半打的产品。"

#: ../../howtos/web.rst:911
msgid "Widget Helpers"
msgstr "窗口小部件帮手"

#: ../../howtos/web.rst:914
msgid "``Widget``'s jQuery Selector"
msgstr " ``Widget`` 的jQuery选择"

#: ../../howtos/web.rst:916
msgid ""
"Selecting DOM elements within a widget can be performed by calling the "
"``find()`` method on the widget's DOM root::"
msgstr "挂件中选择DOM元素可以通过调用 ``找到（）`` 方法上的小部件的DOM根开始 ::"

#: ../../howtos/web.rst:921
msgid ""
"But because it's a common operation, :class:`~openerp.Widget` provides an "
"equivalent shortcut through the :func:`~openerp.Widget.$` method::"
msgstr "但由于它是一种常见的操作, :class:`~openerp.Widget` 提供通过一个等效的快捷方式 :func:`~openerp.Widget $` 方法 :: 。"

#: ../../howtos/web.rst:932
msgid ""
"The global jQuery function ``$()`` should *never* be used unless it is "
"absolutely necessary: selection on a widget's root are scoped to the widget "
"and local to it, but selections with ``$()`` are global to the "
"page/application and may match parts of other widgets and views, leading to "
"odd or dangerous side-effects. Since a widget should generally act only on "
"the DOM section it owns, there is no cause for global selection."
msgstr "The global jQuery function ``$()`` should *never* be used unless it is absolutely necessary : selection on a widget's root are scoped to the widget and local to it, but selections with ``$()`` are global to the page/application and may match parts of other widgets and views, leading to odd or dangerous side-effects. Since a widget should generally act only on the DOM section it owns, there is no cause for global selection."

#: ../../howtos/web.rst:940
msgid "Easier DOM Events Binding"
msgstr "更简单的DOM事件绑定"

#: ../../howtos/web.rst:942
msgid ""
"We have previously bound DOM events using normal jQuery event handlers (e.g."
" ``.click()`` or ``.change()``) on widget elements::"
msgstr "我们以前绑定使用正常jQuery的事件处理程序的DOM事件（如 ``。点击（）`` 或 ``.change（）`` ）上的小部件的元素 ::"

#: ../../howtos/web.rst:957
msgid "While this works it has a few issues:"
msgstr "虽然这个工程它有几个问题:"

#: ../../howtos/web.rst:959
msgid "it is rather verbose"
msgstr "这是相当冗长"

#: ../../howtos/web.rst:960
msgid ""
"it does not support replacing the widget's root element at runtime as the "
"binding is only performed when ``start()`` is run (during widget "
"initialization)"
msgstr "它不支持在运行时更换部件的根元素为绑定状态才能完成 ``开始（）`` 运行（在小部件初始化）"

#: ../../howtos/web.rst:963
msgid "it requires dealing with ``this``-binding issues"
msgstr "它需要处理 ``this`` 结合问题"

#: ../../howtos/web.rst:965
msgid ""
"Widgets thus provide a shortcut to DOM event binding via "
":attr:`~openerp.Widget.events`::"
msgstr "窗口小部件于是通过 :attr:`~openerp.Widget.events` 提供DOM事件绑定的快捷方式 ::"

#: ../../howtos/web.rst:977
msgid ""
":attr:`~openerp.Widget.events` is an object (mapping) of an event to the "
"function or method to call when the event is triggered:"
msgstr ":attr:`~openerp.Widget.events` 是事件触发时要调用的事件到函数或方法的对象(映射):"

#: ../../howtos/web.rst:980
msgid ""
"the key is an event name, possibly refined with a CSS selector in which case"
" only if the event happens on a selected sub-element will the function or "
"method run: ``click`` will handle all clicks within the widget, but ``click "
".my_button`` will only handle clicks in elements bearing the ``my_button`` "
"class"
msgstr "关键是事件名称, 可能与精制CSS选择器在这种情况下, 只有当事件选定的子元素将发生在函数或方法运行:``click`` 将处理部件中的所有点击, 但 ``点击.my_button`` 将只处理的点击在元素轴承 ``my_button`` 类"

#: ../../howtos/web.rst:985
msgid "the value is the action to perform when the event is triggered"
msgstr "当事件触发时，值是要执行的动作"

#: ../../howtos/web.rst:987
msgid "It can be either a function::"
msgstr "它可以是一个函数 ::"

#: ../../howtos/web.rst:993
msgid "or the name of a method on the object (see example above)."
msgstr "或对象上的方法的名称（参见上述实施例）。"

#: ../../howtos/web.rst:995
msgid ""
"In either case, the ``this`` is the widget instance and the handler is given"
" a single parameter, the `jQuery event object`_ for the event."
msgstr "在两种情况下, ``this`` 是小部件实例和处理程序被赋予一个参数, 所述 `的jQuery事件object` _为事件。"

#: ../../howtos/web.rst:999
msgid "Widget Events and Properties"
msgstr "挂件事件和属性"

#: ../../howtos/web.rst:1002
msgid "Events"
msgstr "事件"

#: ../../howtos/web.rst:1004
msgid ""
"Widgets provide an event system (separate from the DOM/jQuery event system "
"described above): a widget can fire events on itself, and other widgets (or "
"itself) can bind themselves and listen for these events::"
msgstr "挂件提供了一个事件系统（独立于上述的DOM / jQuery的事件系统）:一个小部件可以在自身触发事件, 以及其他小部件（或自己）能约束自己, 并侦听这些事件 ::"

#: ../../howtos/web.rst:1024
msgid ""
"This widget acts as a facade, transforming user input (through DOM events) "
"into a documentable internal event to which parent widgets can bind "
"themselves."
msgstr "这个挂件充当门面, 转化用户输入（通过DOM事件）成稽​​内部事件到父控件可以绑定自己。"

#: ../../howtos/web.rst:1028
msgid ""
":func:`~openerp.Widget.trigger` takes the name of the event to trigger as "
"its first (mandatory) argument, any further arguments are treated as event "
"data and passed directly to listeners."
msgstr ":func:`~openerp.Widget.trigger` 发生事件的名称来触发作为其第一个（强制性的）的说法, 任何进一步的参数都被视为事件的数据, 并直接传递给听众。"

#: ../../howtos/web.rst:1032
msgid ""
"We can then set up a parent event instantiating our generic widget and "
"listening to the ``user_chose`` event using :func:`~openerp.Widget.on`::"
msgstr "然后, 我们可以设置父事件实例我们的通用部件, 并听取了 ``user_chose`` 事件使用 :func:`~openerp.Widget.on` ::"

#: ../../howtos/web.rst:1050
msgid ""
":func:`~openerp.Widget.on` binds a function to be called when the event "
"identified by ``event_name`` is. The ``func`` argument is the function to "
"call and ``object`` is the object to which that function is related if it is"
" a method. The bound function will be called with the additional arguments "
"of :func:`~openerp.Widget.trigger` if it has any. Example::"
msgstr ":func:`~openerp.Widget.on` 函数绑定时确定的 ``事件是event_name`` 被调用。该 ``func`` 参数是要调用的函数和 ``object`` 是它, 如果它是一个方法, 功能相关的对象。绑定的功能将被调用的附加参数 :func:`~openerp.Widget.trigger` 如果有任何。例如 ::"

#: ../../howtos/web.rst:1069
msgid ""
"Triggering events on an other widget is generally a bad idea. The main "
"exception to that rule is ``openerp.web.bus`` which exists specifically to "
"broadcasts evens in which any widget could be interested throughout the Odoo"
" web application."
msgstr "上其他部件触发事件通常是一个坏主意。主要的例外情况的规则是 ``openerp.web.bus`` 它存在专门为广播埃文斯在其中的任何部件可能是整个Odoo Web应用程序感兴趣。"

#: ../../howtos/web.rst:1075
msgid "Properties"
msgstr "属性"

#: ../../howtos/web.rst:1077
msgid ""
"Properties are very similar to normal object attributes in that they allow "
"storing data on a widget instance, however they have the additional feature "
"that they trigger events when set::"
msgstr "性质非常类似于正常对象属性在于它们允许存储上一个小部件实例的数据, 但是它们具有附加特征, 它们触发事件时设置 ::"

#: ../../howtos/web.rst:1090
msgid ""
":func:`~openerp.Widget.set` sets the value of a property and triggers "
":samp:`change:{propname}` (where *propname* is the property name passed as "
"first parameter to :func:`~openerp.Widget.set`) and ``change``"
msgstr ":func:`~openerp.Widget.set` 设置一个属性的值, 并触发 :samp:`变化:{PROPNAME}` （其中 * PROPNAME * 被作为第一个参数属性名称 :func:`~OpenERP的。 Widget.set` ）和 ``change`` "

#: ../../howtos/web.rst:1093
msgid ":func:`~openerp.Widget.get` retrieves the value of a property."
msgstr ":func:`~openerp.Widget.get` 检索属性的值。"

#: ../../howtos/web.rst:1098
msgid "Widget Properties and Events"
msgstr "控件属性和事件"

#: ../../howtos/web.rst:1100
msgid ""
"Create a widget ``ColorInputWidget`` that will display 3 ``<input "
"type=\"text\">``. Each of these ``<input>`` is dedicated to type a "
"hexadecimal number from 00 to FF. When any of these ``<input>`` is modified "
"by the user the widget must query the content of the three ``<input>``, "
"concatenate their values to have a complete CSS color code (ie: ``#00FF00``)"
" and put the result in a property named ``color``. Please note the jQuery "
"``change()`` event that you can bind on any HTML ``<input>`` element and the"
" ``val()`` method that can query the current value of that ``<input>`` could"
" be useful to you for this exercise."
msgstr "Create a widget `` ColorInputWidget `` that will display 3 `` <input type=``text``> `` . Each of these `` <input> `` is dedicated to type a hexadecimal number from 00 to FF. When any of these `` <input> `` is modified by the user the widget must query the content of the three `` <input> `` ， concatenate their values to have a complete CSS color code (ie :`` #00FF00 `` ) and put the result in a property named `` color `` . Please note the jQuery `` change() `` event that you can bind on any HTML `` <input> `` element and the `` val() `` method that can query the current value of that `` <input> `` could be useful to you for this exercise."

#: ../../howtos/web.rst:1110
msgid ""
"Then, modify the ``HomePage`` widget to instantiate ``ColorInputWidget`` and"
" display it. The ``HomePage`` widget should also display an empty rectangle."
" That rectangle must always, at any moment, have the same background color "
"as the color in the ``color`` property of the ``ColorInputWidget`` instance."
msgstr "然后, 修改 ``HomePage`` 构件实例 ``ColorInputWidget`` 并显示它。该 ``HomePage`` 挂件还应该显示一个空矩形。该矩形必须始终, 在任何时刻, 都有相同的背景色在 ``ColorInputWidget`` 实例的 ``color`` 属性的颜色。"

#: ../../howtos/web.rst:1116
msgid "Use QWeb to generate all HTML."
msgstr "使用QWeb生成所有的HTML。"

#: ../../howtos/web.rst:1189
msgid "Modify existing widgets and classes"
msgstr "修改现有的小部件和类"

#: ../../howtos/web.rst:1191
msgid ""
"The class system of the Odoo web framework allows direct modification of "
"existing classes using the :func:`~openerp.web.Class.include` method::"
msgstr "在Odoo Web框架的类系统允许使用现有类的直接修改 :func:`~openerp.web.Class.include` 方法 ::"

#: ../../howtos/web.rst:1209
msgid ""
"This system is similar to the inheritance mechanism, except it will alter "
"the target class in-place instead of creating a new class."
msgstr "这个系统类似于继承机制, 但是它会改变创建一类新的在就地目标类代替。"

#: ../../howtos/web.rst:1212
msgid ""
"In that case, ``this._super()`` will call the original implementation of a "
"method being replaced/redefined. If the class already had sub-classes, all "
"calls to ``this._super()`` in sub-classes will call the new implementations "
"defined in the call to :func:`~openerp.web.Class.include`. This will also "
"work if some instances of the class (or of any of its sub-classes) were "
"created prior to the call to :func:`~openerp.Widget.include`."
msgstr "在这种情况下, ``this._super（）`` 会调用一个方法的最初实现被替换/重新定义。如果类已经有子类, 所有调用 ``this._super（）`` 在子类将调用在调用中定义的新的实现 :func:`~openerp.web.Class.include` 。 :func: 如果类（任何其子类或）的某些情况下是之前调用创建这也将工作 `~openerp.Widget.include` 。"

#: ../../howtos/web.rst:1220
msgid "Translations"
msgstr "翻译"

#: ../../howtos/web.rst:1222
msgid ""
"The process to translate text in Python and JavaScript code is very similar."
" You could have noticed these lines at the beginning of the ``petstore.js`` "
"file::"
msgstr "的过程翻译文字在Python和JavaScript代码很相似。你可能已经注意到了这些线路的 ``petstore.js`` 文件的开头 ::"

#: ../../howtos/web.rst:1229
msgid ""
"These lines are simply used to import the translation functions in the "
"current JavaScript module. They are used thus::"
msgstr "这些线只是用来导入翻译功能在当前的JavaScript模块内。因此, 他们使用 ::"

#: ../../howtos/web.rst:1234
msgid ""
"In Odoo, translations files are automatically generated by scanning the "
"source code. All piece of code that calls a certain function are detected "
"and their content is added to a translation file that will then be sent to "
"the translators. In Python, the function is ``_()``. In JavaScript the "
"function is :func:`~openerp.web._t` (and also :func:`~openerp.web._lt`)."
msgstr "在Odoo, 自动扫描的源代码生成的翻译文件。所有一段代码调用特定功能的检测和它们的内容被添加到将被发送到翻译者翻译文件。在Python中, 函数是 ``_（）`` 。在JavaScript函数是 :func:`~openerp.web._t` （也 :func:`~openerp.web._lt` ）。"

#: ../../howtos/web.rst:1240
msgid ""
"``_t()`` will return the translation defined for the text it is given. If no"
" translation is defined for that text, it will return the original text as-"
"is."
msgstr " ``_T（）`` 会返回给它的文本中定义的翻译。如果没有翻译被定义为文本, 它将返回原文原样。"

#: ../../howtos/web.rst:1245
msgid ""
"To inject user-provided values in translatable strings, it is recommended to"
" use `_.str.sprintf "
"<http://gabceb.github.io/underscore.string.site/#sprintf>`_ with named "
"arguments *after* the translation::"
msgstr "为了在翻译的字符串注入用户提供的值, 建议使用 `_.str.sprintf <http ://gabceb.github.io/underscore.string.site/#sprintf>` _使用参数名 **后的翻译: :"

#: ../../howtos/web.rst:1255
msgid ""
"This makes translatable strings more readable to translators, and gives them"
" more flexibility to reorder or ignore parameters."
msgstr "这使得翻译字符串更具可读性翻译人员, 并让他们更灵活地重新排序或忽略的参数。"

#: ../../howtos/web.rst:1258
msgid ""
":func:`~openerp.web._lt` (\"lazy translate\") is similar but somewhat more "
"complex: instead of translating its parameter immediately, it returns an "
"object which, when converted to a string, will perform the translation."
msgstr ":func:`~openerp.web._lt` （'懒翻译'）相似, 但稍微复杂一些:而不是立即转换它的参数, 它返回一个对象, 当转换为字符串, 将执行转换。"

#: ../../howtos/web.rst:1262
msgid ""
"It is used to define translatable terms before the translations system is "
"initialized, for class attributes for instance (as modules are loaded before"
" the user's language is configured and translations are downloaded)."
msgstr "它是用来定义平移术语翻译系统被初始化之前, 用于例如类属性（如加载用户的语言被配置之前和翻译下载模块）。"

#: ../../howtos/web.rst:1267
msgid "Communication with the Odoo Server"
msgstr "与Odoo服务器通信"

#: ../../howtos/web.rst:1270
msgid "Contacting Models"
msgstr "联系模型"

#: ../../howtos/web.rst:1272
msgid ""
"Most operations with Odoo involve communicating with *models* implementing "
"business concern, these models will then (potentially) interact with some "
"storage engine (usually PostgreSQL_)."
msgstr "大多数操作与Odoo涉及与 *型号* 实现企业关注的通信, 这些模型之后, （可能）有一些存储引擎（通常PostgreSQL_）进行交互。"

#: ../../howtos/web.rst:1276
msgid ""
"Although jQuery_ provides a `$.ajax`_ function for network interactions, "
"communicating with Odoo requires additional metadata whose setup before "
"every call would be verbose and error-prone. As a result, Odoo web provides "
"higher-level communication primitives."
msgstr "虽然jQuery_提供了一个 `$ .ajax` _功能的网络交互, 与Odoo通信需要额外的元数据, 其设定每次通话前, 将冗长且容易出错。其结果是, Odoo网络提供更高级别的通信原语。"

#: ../../howtos/web.rst:1281
msgid ""
"To demonstrate this, the file ``petstore.py`` already contains a small model"
" with a sample method:"
msgstr "为了证明这一点, 该文件 ``petstore.py`` 已经包含了一个小的模型样本的方法:"

#: ../../howtos/web.rst:1296
msgid ""
"This declares a model with two fields, and a method ``my_method()`` which "
"returns a literal dictionary."
msgstr "声明一个模型有两个字段, 方法 ``my_method（）`` 返回文字字典。"

#: ../../howtos/web.rst:1299
msgid ""
"Here is a sample widget that calls ``my_method()`` and displays the result::"
msgstr "下面是一个简单的挂件, 电话 ``my_method（）`` , 并将结果显示 ::"

#: ../../howtos/web.rst:1312
msgid ""
"The class used to call Odoo models is :class:`openerp.Model`. It is "
"instantiated with the Odoo model's name as first parameter "
"(``oepetstore.message_of_the_day`` here)."
msgstr "用于调用Odoo模型类是 :class:`openerp.Model` 。它被实例化与Odoo模型的名称作为第一个参数（ ``oepetstore.message_of_the_day`` 这里）。"

#: ../../howtos/web.rst:1316
msgid ""
":func:`~openerp.web.Model.call` can be used to call any (public) method of "
"an Odoo model. It takes the following positional arguments:"
msgstr ":func:`~openerp.web.Model.call` 可以用来打电话的Odoo模型中的任何（公共）方法。它采用下列位置参数:"

#: ../../howtos/web.rst:1319
msgid "``name``"
msgstr "``name``"

#: ../../howtos/web.rst:1320
msgid "The name of the method to call, ``my_method`` here"
msgstr "该方法调用, ``这里my_method`` 的名称"

#: ../../howtos/web.rst:1336
msgid "``args``"
msgstr "``args``"

#: ../../howtos/web.rst:1322
msgid ""
"an array of `positional arguments`_ to provide to the method. Because the "
"example has no positional argument to provide, the ``args`` parameter is not"
" provided."
msgstr "的 `位置arguments` _阵列, 以提供给该方法。因为示例具有没有位置参数来提供, 不设置 ``args`` 参数。"

#: ../../howtos/web.rst:1326
msgid "Here is an other example with positional arguments:"
msgstr "下面是一个例子等与位置参数:"

#: ../../howtos/web.rst:1350
msgid "``kwargs``"
msgstr " ``kwargs`` "

#: ../../howtos/web.rst:1339
msgid ""
"a mapping of `keyword arguments`_ to pass. The example provides a single "
"named argument ``context``."
msgstr "的'关键字arguments `_映射通过。这个例子提供了一个单一命名参数 ``context`` 。"

#: ../../howtos/web.rst:1352
msgid ""
":func:`~openerp.Widget.call` returns a deferred resolved with the value "
"returned by the model's method as first argument."
msgstr ":func:`~openerp.Widget.call` 返回推迟解决与模型的方法, 第一个参数返回的值。"

#: ../../howtos/web.rst:1356
msgid "CompoundContext"
msgstr "CompoundContext"

#: ../../howtos/web.rst:1358
msgid ""
"The previous section used a ``context`` argument which was not explained in "
"the method call::"
msgstr "上一节使用这是不是在方法调用解释了 ``context`` 参数 ::"

#: ../../howtos/web.rst:1363
msgid ""
"The context is like a \"magic\" argument that the web client will always "
"give to the server when calling a method. The context is a dictionary "
"containing multiple keys. One of the most important key is the language of "
"the user, used by the server to translate all the messages of the "
"application. Another one is the time zone of the user, used to compute "
"correctly dates and times if Odoo is used by people in different countries."
msgstr "上下文就像是一个'神奇'的论点, 即调用方法时, Web客户端将永远给服务器。上下文是一个包含多个键的字典。其中最重要的关键的是, 用户的语言, 所使用的服务器来翻译应用程序的所有消息。另外一个是用户的时区, 用正确计算日期和时间, 如果Odoo是使用的人在不同的国家。"

#: ../../howtos/web.rst:1370
msgid ""
"The ``argument`` is necessary in all methods, otherwise bad things could "
"happen (such as the application not being translated correctly). That's why,"
" when you call a model's method, you should always provide that argument. "
"The solution to achieve that is to use :class:`openerp.web.CompoundContext`."
msgstr "该 ``argument`` 是必要的, 所有的方法, 否则, 不好的事情可能发生（如应用程序没有被正确翻译）。这就是为什么, 当你调用模型的方法, 你应该总是提供这样的说法。要实现这一目标的解决方案是使用 :class:`openerp.web.CompoundContext` 。"

#: ../../howtos/web.rst:1375
msgid ""
":class:`~openerp.web.CompoundContext` is a class used to pass the user's "
"context (with language, time zone, etc...) to the server as well as adding "
"new keys to the context (some models' methods use arbitrary keys added to "
"the context). It is created by giving to its constructor any number of "
"dictionaries or other :class:`~openerp.web.CompoundContext` instances. It "
"will merge all those contexts before sending them to the server."
msgstr ":class:`~openerp.web.CompoundContext` 是用来传递用户的上下文（与语言, 时区等）到服务器, 以及添加新键的背景下（部分机型“方法使用一个类任意键添加到上下文）。 :class:`~openerp.web.CompoundContext` 情况下, 它被赋予给它的构造任意数量的词典或其他创建的。将它们发送到服务器之前, 它会合并所有这些上下文。"

#: ../../howtos/web.rst:1393
msgid ""
"You can see the dictionary in the argument ``context`` contains some keys "
"that are related to the configuration of the current user in Odoo plus the "
"``new_key`` key that was added when instantiating "
":class:`~openerp.web.CompoundContext`."
msgstr "你可以看到在参数 `字典` context ``包含一些键都涉及到在Odoo当前用户以及实例化时所添加的`` new_key ``键的配置 :class:`~openerp.web。 CompoundContext` 。"

#: ../../howtos/web.rst:1399
msgid "Queries"
msgstr "查询"

#: ../../howtos/web.rst:1401
msgid ""
"While :func:`~openerp.Model.call` is sufficient for any interaction with "
"Odoo models, Odoo Web provides a helper for simpler and clearer querying of "
"models (fetching of records based on various conditions): "
":func:`~openerp.Model.query` which acts as a shortcut for the common "
"combination of :py:meth:`~openerp.models.Model.search` and "
"::py:meth:`~openerp.models.Model.read`. It provides a clearer syntax to "
"search and read models::"
msgstr "虽然 :func:`~openerp.Model.call` 足以满足任何与Odoo模型的交互, Odoo网络为更加简单和清晰的模型查询(基于各种条件获取记录)提供了一个帮手:func:`~openerp.Model.query` ， 它为通用的组合 :py:meth:`~openerp.models.Model.search` 和 ::py:meth:`~openerp.models.Model.read`充当快捷方式。它提供了一个更清晰的语法来搜索和读取模型 ::"

#: ../../howtos/web.rst:1416
msgid "versus::"
msgstr "与::"

#: ../../howtos/web.rst:1426
msgid ""
":func:`~openerp.web.Model.query` takes an optional list of fields as "
"parameter (if no field is provided, all fields of the model are fetched). It"
" returns a :class:`openerp.web.Query` which can be further customized before"
" being executed"
msgstr ":func:`~openerp.web.Model.query` 需要作为参数字段的可选列表（如果没有现场提供, 该模型的所有字段都取）。它返回一个 :class:`openerp.web.Query` 可被执行之前被进一步定制"

#: ../../howtos/web.rst:1430
msgid ""
":class:`~openerp.web.Query` represents the query being built. It is "
"immutable, methods to customize the query actually return a modified copy, "
"so it's possible to use the original and the new version side-by-side. See "
":class:`~openerp.web.Query` for its customization options."
msgstr ":class:`~openerp.web.Query` 表示正在构建的查询。它是不可变的, 方法自定义查询实际上返回一个修改后的副本, 所以它可以使用原有的和新的版本并排侧。参见 :class:`~openerp.web.Query` 其自定义选项。"

#: ../../howtos/web.rst:1435
msgid ""
"When the query is set up as desired, simply call "
":func:`~openerp.web.Query.all` to execute it and return a deferred to its "
"result. The result is the same as :py:meth:`~openerp.models.Model.read`'s, "
"an array of dictionaries where each dictionary is a requested record, with "
"each requested field a dictionary key."
msgstr "当查询被设置为需要, 只需拨打 :func:`~openerp.web.Query.all` 执行它并返回一个推迟到它的结果。其结果是一样的:PY :meth:`~openerp.models.Model.read` 的, 字典的数组, 其中每个字典是一个请求的记录, 每个请求字段的字典键。"

#: ../../howtos/web.rst:1442
msgid "Exercises"
msgstr "练习"

#: ../../howtos/web.rst:1444
msgid "Message of the Day"
msgstr "今日消息"

#: ../../howtos/web.rst:1446
msgid ""
"Create a ``MessageOfTheDay``  widget displaying the last record of the "
"``oepetstore.message_of_the_day`` model. The widget should fetch its record "
"as soon as it is displayed."
msgstr "创建一个 ``MessageOfTheDay`` 插件显示的 ``oepetstore.message_of_the_day`` 模型的最后一个记录。挂件应尽快, 因为它是显示其读取记录。"

#: ../../howtos/web.rst:1450
msgid "Display the widget in the Pet Store home page."
msgstr "显示在宠物商店主页的挂件。"

#: ../../howtos/web.rst:1510
msgid "Pet Toys List"
msgstr "宠物玩具名单"

#: ../../howtos/web.rst:1512
msgid ""
"Create a ``PetToysList`` widget displaying 5 toys (using their name and "
"their images)."
msgstr "创建一个 ``PetToysList`` 小部件显示5玩具（用他们的名字和他们的图像）。"

#: ../../howtos/web.rst:1515
msgid ""
"The pet toys are not stored in a new model, instead they're stored in "
"``product.product`` using a special category *Pet Toys*. You can see the "
"pre-generated toys and add new ones by going to :menuselection:`Pet Store "
"--> Pet Store --> Pet Toys`. You will probably need to explore "
"``product.product`` to create the right domain to select just pet toys."
msgstr "宠物玩具不存储在一个新的模式, 而不是它们存储在 ``使用一个特殊的类别 *宠物玩具* product.product`` 。你可以看到预先生成的玩具, 并会增加新的 :menuselection:`宠物商店 - >宠物商店 - >宠物Toys` 。你可能会需要探索 ``product.product`` 创造合适的字段只选择宠物玩具。"

#: ../../howtos/web.rst:1522
msgid ""
"In Odoo, images are generally stored in regular fields encoded as base64_, "
"HTML supports displaying images straight from base64 with :samp:`<img "
"src=\"data:{mime_type};base64,{base64_image_data}\"/>`"
msgstr "In Odoo, images are generally stored in regular fields encoded as base64_, HTML supports displaying images straight from base64 with :samp:`<img src= ``data :{mime_type};base64, {base64_image_data}`` />` "

#: ../../howtos/web.rst:1526
msgid ""
"The ``PetToysList`` widget should be displayed on the home page on the right"
" of the ``MessageOfTheDay`` widget. You will need to make some layout with "
"CSS to achieve this."
msgstr "该 ``PetToysList`` 部件应该在 ``MessageOfTheDay`` 部件的右侧显示在主页上。你需要做一些布局CSS来实现这一目标。"

#: ../../howtos/web.rst:1646
msgid "Existing web components"
msgstr "现有的网页组件"

#: ../../howtos/web.rst:1649
msgid "The Action Manager"
msgstr "动作管理器"

#: ../../howtos/web.rst:1651
msgid ""
"In Odoo, many operations start from an :ref:`action <reference/actions>`: "
"opening a menu item (to a view), printing a report, ..."
msgstr ":ref: 在Odoo, 很多操作从开始 `动作<reference/actions>` :打开一个菜单项（到一个视图）, 打印报告, ..."

#: ../../howtos/web.rst:1654
msgid ""
"Actions are pieces of data describing how a client should react to the "
"activation of a piece of content. Actions can be stored (and read through a "
"model) or they can be generated on-the fly (locally to the client by "
"javascript code, or remotely by a method of a model)."
msgstr "动作是描述一个客户端应如何处理发生的一段内容的激活数据的块。动作可以被存储（并通过模型读）, 或者它们可以产生上飞（本地到客户端通过JavaScript代码, 或者远程由模型的一个方法）。"

#: ../../howtos/web.rst:1659
msgid ""
"In Odoo Web, the component responsible for handling and reacting to these "
"actions is the *Action Manager*."
msgstr "在Odoo网络, 负责处理和反应, 以这些操作的组件是 *操作管理* 。"

#: ../../howtos/web.rst:1663
msgid "Using the Action Manager"
msgstr "使用动作管理器"

#: ../../howtos/web.rst:1665
msgid ""
"The action manager can be invoked explicitly from javascript code by "
"creating a dictionary describing :ref:`an action <reference/actions>` of the"
" right type, and calling an action manager instance with it."
msgstr "The action manager can be invoked explicitly from javascript code by creating a dictionary describing :ref:`an action <reference/actions>` of the right type, and calling an action manager instance with it."

#: ../../howtos/web.rst:1669
msgid ""
":func:`~openerp.Widget.do_action` is a shortcut of :class:`~openerp.Widget` "
"looking up the \"current\" action manager and executing the action::"
msgstr ":func:`~openerp.Widget.do_action` 是一条捷径 :class:`~openerp.Widget` 仰视'当前'动作经理和执行操作 ::"

#: ../../howtos/web.rst:1685
msgid ""
"The most common action ``type`` is ``ir.actions.act_window`` which provides "
"views to a model (displays a model in various manners), its most common "
"attributes are:"
msgstr "最常见的动作 ``type`` 是 ``ir.actions.act_window`` 提供意见, 以一种模式（显示模式以不同的方式）, 其最常见的属性有:"

#: ../../howtos/web.rst:1689
msgid "``res_model``"
msgstr " ``res_model`` "

#: ../../howtos/web.rst:1690
msgid "The model to display in views"
msgstr "该模型在视图中显示"

#: ../../howtos/web.rst:1691
msgid "``res_id`` (optional)"
msgstr " ``res_id`` (可选)"

#: ../../howtos/web.rst:1692
msgid "For form views, a preselected record in ``res_model``"
msgstr "对于形式的视图, 在 ``res_model`` 预选记录"

#: ../../howtos/web.rst:1697
msgid "``views``"
msgstr "``views``"

#: ../../howtos/web.rst:1694
msgid ""
"Lists the views available through the action. A list of ``[view_id, "
"view_type]``, ``view_id`` can either be the database identifier of a view of"
" the right type, or ``false`` to use the view by default for the specified "
"type. View types can not be present multiple times. The action will open the"
" first view of the list by default."
msgstr "列出可通过诉讼的意见。的 ``[view_id来, view_type来]`` 名单, ``view_id`` 可以是正确类型的视图的数据库标识符, 或 ``false`` 默认使用的视图指定类型。查看类型不能出现多次。该操作将打开列表中默认的第一个视图。"

#: ../../howtos/web.rst:1700
msgid "``target``"
msgstr "``target``"

#: ../../howtos/web.rst:1700
msgid ""
"Either ``current`` (the default) which replaces the \"content\" section of "
"the web client by the action, or ``new`` to open the action in a dialog box."
msgstr "无论是 ``current`` （默认值）, 它的作用取代了Web客户端的'内容'部分, 或 ``new`` 打开一个对话框的动作。"

#: ../../howtos/web.rst:1703
msgid "Additional context data to use within the action."
msgstr "附加的上下文数据的动作中使用。"

#: ../../howtos/web.rst:1705
msgid "Jump to Product"
msgstr "跳转到产品"

#: ../../howtos/web.rst:1707
msgid ""
"Modify the ``PetToysList`` component so clicking on a toy replaces the "
"homepage by the toy's form view."
msgstr "修改 ``PetToysList`` 组件, 以便点击一个玩具代替了网页的玩具的表单视图。"

#: ../../howtos/web.rst:1752
msgid "Client Actions"
msgstr "客户端动作"

#: ../../howtos/web.rst:1754
msgid ""
"Throughout this guide, we used a simple ``HomePage`` widget which the web "
"client automatically starts when we select the right menu item. But how did "
"the Odoo web know to start this widget? Because the widget is registered as "
"a *client action*."
msgstr "在本指南中, 我们用一个简单的 ``HomePage`` 控件, 它的Web客户端的时候, 我们选择右键菜单中的项目会自动启动。但究竟是怎么Odoo网络知道启动这个挂件？因为微件注册为客户 **动作。"

#: ../../howtos/web.rst:1759
msgid ""
"A client action is (as its name implies) an action type defined almost "
"entirely in the client, in javascript for Odoo web. The server simply sends "
"an action tag (an arbitrary name), and optionally adds a few parameters, but"
" beyond that *everything* is handled by custom client code."
msgstr "客户端操作是（顾名思义）动作类型定义几乎完全在客户端的JavaScript的Odoo网络。服务器只需发送一个动作标签（任意名称）, 以及可选增加了一些参数, 但除此之外, *所有* 由定制客户端代码处理。"

#: ../../howtos/web.rst:1764
msgid ""
"Our widget is registered as the handler for the client action through this::"
msgstr "我们的插件被注册为处理程序通过该客户端动作 ::"

#: ../../howtos/web.rst:1769
msgid ""
"``instance.web.client_actions`` is a :class:`~openerp.web.Registry` in which"
" the action manager looks up client action handlers when it needs to execute"
" one. The first parameter of :class:`~openerp.web.Registry.add` is the name "
"(tag) of the client action, and the second parameter is the path to the "
"widget from the Odoo web client root."
msgstr " ``instance.web.client_actions`` 是 :class:`~openerp.web.Registry` 在操作管理器中查找客户端动作处理程序时, 它需要执行一个。 :class: 第一个参数 `~openerp.web.Registry.add` 是客户行为的名称（标签）, 第二个参数是路径从Odoo Web客户端根目录下的部件。"

#: ../../howtos/web.rst:1775
msgid ""
"When a client action must be executed, the action manager looks up its tag "
"in the registry, walks the specified path and displays the widget it finds "
"at the end."
msgstr "必须在执行客户端动作, 动作管理器查找其标记在注册表中, 走指定的路​​径, 并显示它发现在最后的小部件。"

#: ../../howtos/web.rst:1779
msgid ""
"a client action handler can also be a regular function, in whch case it'll "
"be called and its result (if any) will be interpreted as the next action to "
"execute."
msgstr "客户端操作处理程序也可以是一个普通的功能, 在界河情况下, 它会被调用, 它的结果（如果有的话）将被解释为下一个动作去执行。"

#: ../../howtos/web.rst:1783
msgid ""
"On the server side, we had simply defined an ``ir.actions.client`` action:"
msgstr "在服务器端, 我们只是简单地定义了 ``ir.actions.client`` 行动:"

#: ../../howtos/web.rst:1791
msgid "and a menu opening the action:"
msgstr "以及一个菜单开启动作:"

#: ../../howtos/web.rst:1799
msgid "Architecture of the Views"
msgstr "视图的体系结构"

#: ../../howtos/web.rst:1801
msgid ""
"Much of Odoo web's usefulness (and complexity) resides in views. Each view "
"type is a way of displaying a model in the client."
msgstr "许多Odoo网络的有用性（和复杂性）的居住在意见。每个视图类型是显示在客户端一个模型的方式。"

#: ../../howtos/web.rst:1805
msgid "The View Manager"
msgstr "视图管理器"

#: ../../howtos/web.rst:1807
msgid ""
"When an ``ActionManager`` instance receive an action of type "
"``ir.actions.act_window``, it delegates the synchronization and handling of "
"the views themselves to a *view manager*, which will then set up one or "
"multiple views depending on the original action's requirements:"
msgstr "当 ``ActionManager`` 实例收到类型的 ``ir.actions.act_window`` 一个动作, 它代表了自己的意见, 一个 *视图管理器* , 这将然后建立一个或多个视图取决于同步和处理对原诉讼的要求:"

#: ../../howtos/web.rst:1817
msgid "The Views"
msgstr "该视图"

#: ../../howtos/web.rst:1819
msgid ""
"Most :ref:`Odoo views <reference/views>` are implemented through a subclass "
"of :class:`openerp.web.View` which provides a bit of generic basic structure"
" for handling events and displaying model information."
msgstr "Most :ref:`Odoo views <reference/views>` are implemented through a subclass of :class:`openerp.web.View` which provides a bit of generic basic structure for handling events and displaying model information."

#: ../../howtos/web.rst:1823
msgid ""
"The *search view* is considered a view type by the main Odoo framework, but "
"handled separately by the web client (as it's a more permanent fixture and "
"can interact with other views, which regular views don't do)."
msgstr "在 *搜索视图* 被认为是主要的Odoo框架视图类型, 而是通过Web客户端另案处理（因为它是一个更永久装置, 可以与其他意见, 这经常意见不这样做交互）。"

#: ../../howtos/web.rst:1827
msgid ""
"A view is responsible for loading its own description XML (using "
":py:class:`~openerp.models.Model.fields_view_get`) and any other data source"
" it needs. To that purpose, views are provided with an optional view "
"identifier set as the :attr:`~openerp.web.View.view_id` attribute."
msgstr "视图是负责加载自己的描述XML（使用:PY :class:`~openerp.models.Model.fields_view_get` ）, 它需要任何其它数据源。到该目的, 视图, 提供具有可选视图标识符设置为 :attr:`~openerp.web.View.view_id` 属性。"

#: ../../howtos/web.rst:1832
msgid ""
"Views are also provided with a :class:`~openerp.web.DataSet` instance which "
"holds most necessary model information (the model name and possibly various "
"record ids)."
msgstr "意见还配备有 :class:`~openerp.web.DataSet` 实例持有最需要的型号信息（型号名称和可能的各种记录ID）。"

#: ../../howtos/web.rst:1836
msgid ""
"Views may also want to handle search queries by overriding "
":func:`~openerp.web.View.do_search`, and updating their "
":class:`~openerp.web.DataSet` as necessary."
msgstr "意见还可能要通过覆盖处理搜索查询 :func:`~openerp.web.View.do_search` , 并更新他们的 :class:`必要时~openerp.web.DataSet` 。"

#: ../../howtos/web.rst:1841
msgid "The Form View Fields"
msgstr "表单视图字段"

#: ../../howtos/web.rst:1843
msgid ""
"A common need is the extension of the web form view to add new ways of "
"displaying fields."
msgstr "一个常见的​​需求是Web表单视图的分机来增加显示字段的新途径。"

#: ../../howtos/web.rst:1846
msgid ""
"All built-in fields have a default display implementation, a new form widget"
" may be necessary to correctly interact with a new field type (e.g. a "
":term:`GIS` field) or to provide new representations and ways to interact "
"with existing field types (e.g. validate :py:class:`~openerp.fields.Char` "
"fields which should contain email addresses and display them as email "
"links)."
msgstr "所有内置字段有一个默认的显示实现, 一种新形式的小部件可能需要正确地使用新的字段类型进行交互（如:词:`GIS` 场）或者提供新的表述, 以及如何与现有的字段类型互动（例如验证:PY :class:`~openerp.fields.Char` 字段, 它应该包含电子邮件地址和显示这些电子邮件的链接）。"

#: ../../howtos/web.rst:1853
msgid ""
"To explicitly specify which form widget should be used to display a field, "
"simply use the ``widget`` attribute in the view's XML description:"
msgstr "要明确指定哪些表单控件应该被用来显示一个字段, 只需使用视图的XML描述了 ``widget`` 属性:"

#: ../../howtos/web.rst:1862
msgid ""
"the same widget is used in both \"view\" (read-only) and \"edition\" modes "
"of a form view, it's not possible to use a widget in one and an other widget"
" in the other"
msgstr "相同的部件中都使用了'视图'（只读）和'编辑'表单视图模式, 它不可能在其他使用一个小部件在一个和其他挂件"

#: ../../howtos/web.rst:1865
msgid ""
"and a given field (name) can not be used multiple times in the same form"
msgstr "和一个给定场（名）不能以相同的形式被使用多次"

#: ../../howtos/web.rst:1866
msgid ""
"a widget may ignore the current mode of the form view and remain the same in"
" both view and edition"
msgstr "一个小部件可以忽略表单视图的当前模式和保持不变的同时查看和编辑"

#: ../../howtos/web.rst:1871
msgid ""
"Fields are instantiated by the form view after it has read its XML "
"description and constructed the corresponding HTML representing that "
"description. After that, the form view will communicate with the field "
"objects using some methods. These methods are defined by the "
"``FieldInterface`` interface. Almost all fields inherit the "
"``AbstractField`` abstract class. That class defines some default mechanisms"
" that need to be implemented by most fields."
msgstr "字段由表单视图实例化后, 已读取它的XML描述和建造代表该说明相应的HTML。在此之后, 表格视图将使用一些方法中, 字段的对象进行通信。这些方法是由 ``FieldInterface`` 接口中定义。几乎所有字段继承了 ``AbstractField`` 抽象类。这个类定义了需要由多数字段实现了一些默认的机制。"

#: ../../howtos/web.rst:1879
msgid "Here are some of the responsibilities of a field class:"
msgstr "这里有一些的字段类的职责:"

#: ../../howtos/web.rst:1881
msgid ""
"The field class must display and allow the user to edit the value of the "
"field."
msgstr "字段类必须显示, 并允许用户编辑该字段的值。"

#: ../../howtos/web.rst:1882
msgid ""
"It must correctly implement the 3 field attributes available in all fields "
"of Odoo. The ``AbstractField`` class already implements an algorithm that "
"dynamically calculates the value of these attributes (they can change at any"
" moment because their value change according to the value of other fields). "
"Their values are stored in *Widget Properties* (the widget properties were "
"explained earlier in this guide). It is the responsibility of each field "
"class to check these widget properties and dynamically adapt depending of "
"their values. Here is a description of each of these attributes:"
msgstr "它必须正确地实现Odoo的各个字段的3字段属性可用。该 ``AbstractField`` 类已经实现了一种算法, 动态计算这些属性的值（它们可以在任何时刻, 因为根据其他字段的值, 其值的变化而变化）。它们的值存储在 *挂件属性* （小部件性能进行了本指南前面的解释）。它是每个字段级有责任检查这些部件的属性, 动态地根据他们的价值观的适应。下面是每个属性的描述:"

#: ../../howtos/web.rst:1892
msgid ""
"``required``: The field must have a value before saving. If ``required`` is "
"``true`` and the field doesn't have a value, the method ``is_valid()`` of "
"the field must return ``false``."
msgstr " ``required`` :现场必须有保存之前的值。如果 ``required`` 是 ``True和字段没有一个值, 该方法`` is_valid（） ``字段必须返回`` false ``。"

#: ../../howtos/web.rst:1895
msgid ""
"``invisible``: When this is ``true``, the field must be invisible. The "
"``AbstractField`` class already has a basic implementation of this behavior "
"that fits most fields."
msgstr " ``invisible`` :如果这是 ``True`` , 那么该字段必须是不可见的。该 ``AbstractField`` 类已经有此行为, 适合大多数字段基本实现。"

#: ../../howtos/web.rst:1898
msgid ""
"``readonly``: When ``true``, the field must not be editable by the user. "
"Most fields in Odoo have a completely different behavior depending on the "
"value of ``readonly``. As example, the ``FieldChar`` displays an HTML "
"``<input>`` when it is editable and simply displays the text when it is "
"read-only. This also means it has much more code it would need to implement "
"only one behavior, but this is necessary to ensure a good user experience."
msgstr " ``readonly`` : When ``true`` , the field must not be editable by the user. Most fields in Odoo have a completely different behavior depending on the value of ``readonly`` . As example, the ``FieldChar`` displays an HTML ``<input>`` when it is editable and simply displays the text when it is read-only. This also means it has much more code it would need to implement only one behavior, but this is necessary to ensure a good user experience."

#: ../../howtos/web.rst:1906
msgid ""
"Fields have two methods, ``set_value()`` and ``get_value()``, which are "
"called by the form view to give it the value to display and get back the new"
" value entered by the user. These methods must be able to handle the value "
"as given by the Odoo server when a ``read()`` is performed on a model and "
"give back a valid value for a ``write()``.  Remember that the "
"JavaScript/Python data types used to represent the values given by "
"``read()`` and given to ``write()`` is not necessarily the same in Odoo. As "
"example, when you read a many2one, it is always a tuple whose first value is"
" the id of the pointed record and the second one is the name get (ie: ``(15,"
" \"Agrolait\")``). But when you write a many2one it must be a single "
"integer, not a tuple anymore. ``AbstractField`` has a default implementation"
" of these methods that works well for simple data type and set a widget "
"property named ``value``."
msgstr "域有两种方法, ``set_value（）`` 和 ``的get_value（）`` , 这是所谓的形式, 以便给它来显示, 并取回用户输入的新值。这些方法必须能够处理的值给定的Odoo服务器时 ``阅读（）`` 在模型上进行, 并给回一个有效的值的 ``写（）`` 。请记住, JavaScript的/ Python数据类型用来表示给出的值 ``阅读（）`` , 并给予 ``写（）`` 不一定是Odoo相同。作为例子, 当你读一个many2one, 它始终是一个元组的第一个值是尖的记录, 第二个的编号是名字的get（即:``（15'Agrolait'）`` ）。但是, 当你写一个many2one它必须是一个整数, 而不是一个元组了。 ``AbstractField`` 有这些方法的默认实现行之有效的简单数据类型和设置名为 ``value`` 挂件属性。"

#: ../../howtos/web.rst:1920
msgid ""
"Please note that, to better understand how to implement fields, you are "
"strongly encouraged to look at the definition of the ``FieldInterface`` "
"interface and the ``AbstractField`` class directly in the code of the Odoo "
"web client."
msgstr "请注意, 以更好地了解如何实施字段, 我们强烈建议你看一下 ``FieldInterface`` 接口和Odoo Web客户端的代码 ``AbstractField`` 直接类的定义。"

#: ../../howtos/web.rst:1926
msgid "Creating a New Type of Field"
msgstr "创建域的一种新类型"

#: ../../howtos/web.rst:1928
msgid ""
"In this part we will explain how to create a new type of field. The example "
"here will be to re-implement the ``FieldChar`` class and progressively "
"explain each part."
msgstr "在这一部分, 我们将解释如何创建一个新的类型的字段。这里的例子将是重新实现 ``FieldChar`` 类, 并逐步讲解每一个部分。"

#: ../../howtos/web.rst:1933
msgid "Simple Read-Only Field"
msgstr "简单的只读字段"

#: ../../howtos/web.rst:1935
msgid ""
"Here is a first implementation that will only display text. The user will "
"not be able to modify the content of the field."
msgstr "这里是只显示文本的第一实现。用户将不能够修改该字段的内容。"

#: ../../howtos/web.rst:1952
msgid ""
"In this example, we declare a class named ``FieldChar2`` inheriting from "
"``AbstractField``. We also register this class in the registry "
"``instance.web.form.widgets`` under the key ``char2``. That will allow us to"
" use this new field in any form view by specifying ``widget=\"char2\"`` in "
"the ``<field/>`` tag in the XML declaration of the view."
msgstr "In this example, we declare a class named ``FieldChar2`` inheriting from ``AbstractField`` . We also register this class in the registry ``instance.web.form.widgets`` under the key ``char2`` . That will allow us to use this new field in any form view by specifying ``widget=`` char2 ```` in the ``<field/>`` tag in the XML declaration of the view."

#: ../../howtos/web.rst:1958
msgid ""
"In this example, we define a single method: ``render_value()``. All it does "
"is display the widget property ``value``.  Those are two tools defined by "
"the ``AbstractField`` class. As explained before, the form view will call "
"the method ``set_value()`` of the field to set the value to display. This "
"method already has a default implementation in ``AbstractField`` which "
"simply sets the widget property ``value``. ``AbstractField`` also watch the "
"``change:value`` event on itself and calls the ``render_value()`` when it "
"occurs. So, ``render_value()`` is a convenience method to implement in child"
" classes to perform some operation each time the value of the field changes."
msgstr "在这个例子中, 我们定义了一个方法:``render_value（）`` 。它所做的就是显示的挂件属性 ``value`` 。这些都是由 ``AbstractField`` 类中定义的两个工具。如前所述, 表单视图将调用现场的方法 ``set_value（）`` 设置要显示的值。这种方法已经在 ``AbstractField`` 一个默认的实现, 它只是设置挂件属性 ``value`` 。 ``AbstractField`` 还观看了 ``变化:value`` 事件本身, 并调用 ``render_value（）`` 当它发生。所以, ``render_value（）`` 是一个方便的方法在子类来实现执行一些操作, 每次字段的变化值。"

#: ../../howtos/web.rst:1968
msgid ""
"In the ``init()`` method, we also define the default value of the field if "
"none is specified by the form view (here we assume the default value of a "
"``char`` field should be an empty string)."
msgstr "在 ``的init（）`` 方法, 我们还定义是否是由表单视图没有指定的字段的默认值（这里我们假设一个 ``char`` 字段的默认值应该是一个空字符串）。"

#: ../../howtos/web.rst:1973
msgid "Read-Write Field"
msgstr "读写字段"

#: ../../howtos/web.rst:1975
msgid ""
"Read-only fields, which only display content and don't allow the user to "
"modify it can be useful, but most fields in Odoo also allow editing. This "
"makes the field classes more complicated, mostly because fields are supposed"
" to handle both editable and non-editable mode, those modes are often "
"completely different (for design and usability purpose) and the fields must "
"be able to switch between modes at any moment."
msgstr "Read-only fields, which only display content and don't allow the user to modify it can be useful, but most fields in Odoo also allow editing. This makes the field classes more complicated, mostly because fields are supposed to handle both editable and non-editable mode, those modes are often completely different (for design and usability purpose) and the fields must be able to switch between modes at any moment."

#: ../../howtos/web.rst:1982
msgid ""
"To know in which mode the current field should be, the ``AbstractField`` "
"class sets a widget property named ``effective_readonly``. The field should "
"watch for changes in that widget property and display the correct mode "
"accordingly. Example::"
msgstr "要知道在哪种模式下电流场应该是, 在 ``AbstractField`` 类设置一个名为 ``effective_readonly`` 挂件属性。现场应注意有无变化, 该挂件属性, 并相应地显示正确的模式。例如 ::"

#: ../../howtos/web.rst:2030
msgid ""
"In the ``start()`` method (which is called immediately after a widget has "
"been appended to the DOM), we bind on the event "
"``change:effective_readonly``. That allows us to redisplay the field each "
"time the widget property ``effective_readonly`` changes. This event handler "
"will call ``display_field()``, which is also called directly in ``start()``."
" This ``display_field()`` was created specifically for this field, it's not "
"a method defined in ``AbstractField`` or any other class. We can use this "
"method to display the content of the field depending on the current mode."
msgstr "在 ``开始（）`` 方法（它是直接调用后, 一个小部件已经被添加到DOM）, 我们绑定的事件 ``变化:effective_readonly`` 。这使我们能够在每次挂件属性 ``effective_readonly`` 变化重新显示字段。此事件处理程序将调用 ``display_field（）`` , 也被称为直接在 ``开始（）`` 。这 ``display_field（）`` 是为这一字段的专门创建, 它不是在 ``AbstractField`` 或任何其它类中定义的方法。我们可以用这种方法来显示根据当前的模式字段的内容。"

#: ../../howtos/web.rst:2039
msgid ""
"From now on the conception of this field is typical, except there is a lot "
"of verifications to know the state of the ``effective_readonly`` property:"
msgstr "从现在起, 这一字段的概念是典型的, 除非有大量的核查知道 ``effective_readonly`` 财产的状态:"

#: ../../howtos/web.rst:2042
msgid ""
"In the QWeb template used to display the content of the widget, it displays "
"an ``<input type=\"text\" />`` if we are in read-write mode and nothing in "
"particular in read-only mode."
msgstr "In the QWeb template used to display the content of the widget, it displays an ``<input type=`` text ``/>`` if we are in read-write mode and nothing in particular in read-only mode."

#: ../../howtos/web.rst:2045
msgid ""
"In the ``display_field()`` method, we have to bind on the ``change`` event "
"of the ``<input type=\"text\" />`` to know when the user has changed the "
"value. When it happens, we call the ``internal_set_value()`` method with the"
" new value of the field. This is a convenience method provided by the "
"``AbstractField`` class. That method will set a new value in the ``value`` "
"property but will not trigger a call to ``render_value()`` (which is not "
"necessary since the ``<input type=\"text\" />`` already contains the correct"
" value)."
msgstr "In the ``display_field()`` method, we have to bind on the ``change`` event of the ``<input type=`` text ``/>`` to know when the user has changed the value. When it happens, we call the ``internal_set_value()`` method with the new value of the field. This is a convenience method provided by the ``AbstractField`` class. That method will set a new value in the ``value`` property but will not trigger a call to ``render_value()`` (which is not necessary since the ``<input type=`` text ``/>`` already contains the correct value)."

#: ../../howtos/web.rst:2053
msgid ""
"In ``render_value()``, we use a completely different code to display the "
"value of the field depending if we are in read-only or in read-write mode."
msgstr "在 ``render_value（）`` , 我们使用了完全不同的代码显示的字段的值取决于如果我们在只读或读写模式。"

#: ../../howtos/web.rst:2056
msgid "Create a Color Field"
msgstr "创建一个彩色场"

#: ../../howtos/web.rst:2058
msgid ""
"Create a ``FieldColor`` class. The value of this field should be a string "
"containing a color code like those used in CSS (example: ``#FF0000`` for "
"red). In read-only mode, this color field should display a little block "
"whose color corresponds to the value of the field. In read-write mode, you "
"should display an ``<input type=\"color\" />``. That type of ``<input />`` "
"is an HTML5 component that doesn't work in all browsers but works well in "
"Google Chrome. So it's OK to use as an exercise."
msgstr "Create a ``FieldColor`` class. The value of this field should be a string containing a color code like those used in CSS (example :``#FF0000`` for red). In read-only mode, this color field should display a little block whose color corresponds to the value of the field. In read-write mode, you should display an ``<input type=`` color ``/>`` . That type of ``<input />`` is an HTML5 component that doesn't work in all browsers but works well in Google Chrome. So it's OK to use as an exercise."

#: ../../howtos/web.rst:2066
msgid ""
"You can use that widget in the form view of the ``message_of_the_day`` model"
" for its field named ``color``. As a bonus, you can change the "
"``MessageOfTheDay`` widget created in the previous part of this guide to "
"display the message of the day with the background color indicated in the "
"``color`` field."
msgstr "您可以使用插件在 ``message_of_the_day`` 模式, 其名为 ``color`` 字段的表单视图。作为奖励, 你可以改变在本指南的前面部分创建, 以显示新的一天, 在 ``color`` 字段指示的背景颜色的消息 ``MessageOfTheDay`` 部件。"

#: ../../howtos/web.rst:2131
msgid "The Form View Custom Widgets"
msgstr "表单视图定制的挂件"

#: ../../howtos/web.rst:2133
msgid ""
"Form fields are used to edit a single field, and are intrinsically linked to"
" a field. Because this may be limiting, it is also possible to create *form "
"widgets* which are not so restricted and have less ties to a specific "
"lifecycle."
msgstr "表单字段用于编辑单个字段, 并有内在的联系到现场。因为这可能是限制性的, 也可以创建 *表单部件* 中未如此受限制, 并有较少的联系到特定的生命周期。"

#: ../../howtos/web.rst:2138
msgid ""
"Custom form widgets can be added to a form view through the ``widget`` tag:"
msgstr "自定义表单控件可以添加到通过 ``widget`` 标签的表单视图:"

#: ../../howtos/web.rst:2144
msgid ""
"This type of widget will simply be created by the form view during the "
"creation of the HTML according to the XML definition. They have properties "
"in common with the fields (like the ``effective_readonly`` property) but "
"they are not assigned a precise field. And so they don't have methods like "
"``get_value()`` and ``set_value()``. They must inherit from the "
"``FormWidget`` abstract class."
msgstr "这种类型的widget将简单地通过的形式视图创建的HTML期间根据XML定义创建。它们的共同点的属性与字段（如 ``effective_readonly`` 属性）, 但他们没有被分配一个精确字段。因此, 他们没有像 ``的get_value（）`` 和 ``set_value（）`` 方法。他们必须继承 ``FormWidget`` 抽象类。"

#: ../../howtos/web.rst:2151
msgid ""
"Form widgets can interact with form fields by listening for their changes "
"and fetching or altering their values. They can access form fields through "
"their :attr:`~openerp.web.form.FormWidget.field_manager` attribute::"
msgstr "表单控件可以与表单字段通过倾听他们的变化和读取或改变他们的价值观互动。 :attr: 他们可以通过他们获取表单字段 `~openerp.web.form.FormWidget.field_manager` 属性 ::"

#: ../../howtos/web.rst:2171
msgid ""
":attr:`~openerp.web.form.FormWidget` is generally the "
":class:`~openerp.web.form.FormView` itself, but features used from it should"
" be limited to those defined by "
":class:`~openerp.web.form.FieldManagerMixin`, the most useful being:"
msgstr ":attr:`~openerp.web.form.FormWidget` 一般是 :class:`~openerp.web.form.FormView` 本身, 而是使用的功能从应仅限于那些由定义 :class:`~OpenERP的。 web.form.FieldManagerMixin` , 最有用的存在:"

#: ../../howtos/web.rst:2176
msgid ""
":func:`~openerp.web.form.FieldManagerMixin.get_field_value(field_name)` "
"which returns the value of a field."
msgstr ":func:`~openerp.web.form.FieldManagerMixin.get_field_value（FIELD_NAME）` 返回一个字段的值。"

#: ../../howtos/web.rst:2178
msgid ""
":func:`~openerp.web.form.FieldManagerMixin.set_values(values)` sets multiple"
" field values, takes a mapping of ``{field_name: value_to_set}``"
msgstr ":func:`~openerp.web.form.FieldManagerMixin.set_values​​（值）'设置多个字段值, 需要 ``的一个映射{FIELD_NAME:value_to_set}`` "

#: ../../howtos/web.rst:2180
msgid ""
"An event :samp:`field_changed:{field_name}` is triggered any time the value "
"of the field called ``field_name`` is changed"
msgstr "事件 :samp:`field_changed:{FIELD_NAME}` 触发称为 ``字段的值field_name`` 改变任何时间"

#: ../../howtos/web.rst:2183
msgid "Show Coordinates on Google Map"
msgstr "坐标显示在谷歌地图"

#: ../../howtos/web.rst:2185
msgid ""
"Add two fields to ``product.product`` storing a latitude and a longitude, "
"then create a new form widget to display the latitude and longitude of a "
"product's origin on a map"
msgstr "添加两个字段 ``product.product`` 存储纬度和经度, 然后创建一个新的表单控件来显示产品的原产地的经度和纬度的地图"

#: ../../howtos/web.rst:2189
msgid "To display the map, use Google Map's embedding:"
msgstr "要显示地图, 使用谷歌地图的嵌入:"

#: ../../howtos/web.rst:2196
msgid ""
"where ``XXX`` should be replaced by the latitude and ``YYY`` by the "
"longitude."
msgstr "其中 ``XXX`` 应该由纬度和 ``YYY`` 由经度所取代。"

#: ../../howtos/web.rst:2199
msgid ""
"Display the two position fields and a map widget using them in a new "
"notebook page of the product's form view."
msgstr "显示这两个位置的字段, 并使用他们产品的表单视图的新的笔记本页面地图工具。"

#: ../../howtos/web.rst:2231
msgid "Get the Current Coordinate"
msgstr "获取当前坐标"

#: ../../howtos/web.rst:2233
msgid ""
"Add a button resetting the product's coordinates to the location of the "
"user, you can get these coordinates using the `javascript geolocation API`_."
msgstr "添加一个按钮复位该产品的坐标到用户的位置, 就可以得到这些坐标使用'javascript的地理位置API `_。"

#: ../../howtos/web.rst:2237
msgid ""
"Now we would like to display an additional button to automatically set the "
"coordinates to the location of the current user."
msgstr "现在我们想显示的附加按钮来自动设置的坐标到当前用户的位置。"

#: ../../howtos/web.rst:2240
msgid ""
"To get the coordinates of the user, an easy way is to use the geolocation "
"JavaScript API.  `See the online documentation to know how to use it`_."
msgstr "要得到用户的坐标, 一个简单的方法是使用地理位置的JavaScript API。 `请参阅联机文档了解如何使用it` _。"

#: ../../howtos/web.rst:2245
msgid ""
"Please also note that the user should not be able to click on that button "
"when the form view is in read-only mode. So, this custom widget should "
"handle correctly the ``effective_readonly`` property just like any field. "
"One way to do this would be to make the button disappear when "
"``effective_readonly`` is true."
msgstr "另请注意, 用户不应该能够在该按钮点击时, 表单视图是只读模式。因此, 这个自定义挂件应正确处理的 ``effective_readonly`` 物业就像任何字段。这样做的一个方法是使当 ``effective_readonly`` 是真实的按钮消失。"

#: ../../howtos/web.rst:2296
msgid ""
"as a separate concept from instances. In many languages classes are full-"
"fledged objects and themselves instance (of metaclasses) but there remains "
"two fairly separate hierarchies between classes and instances"
msgstr "从实例中一个单独的概念。在许多语言中类是成熟的对象和自己的实例（元类）, 但仍有类和实例之间的两个相当独立的层次结构"

#: ../../howtos/web.rst:2300
msgid ""
"as well as papering over cross-browser differences, although this has become"
" less necessary over time"
msgstr "以及掩盖了跨浏览器的差异, 虽然这已经随着时间的推移变得不那么必要"

#: ../../howtos/website.rst:7
msgid "Building a Website"
msgstr "建造网站"

#: ../../howtos/website.rst:11
msgid ""
"This guide assumes `basic knowledge of Python "
"<http://docs.python.org/2/tutorial/>`_"
msgstr "本指南假设'的Python的基本知识<http ://docs.python.org/2/tutorial/> `_"

#: ../../howtos/website.rst:13
msgid "This guide assumes :ref:`an installed Odoo <setup/install>`"
msgstr "This guide assumes :ref:`an installed Odoo <setup/install>` "

#: ../../howtos/website.rst:16
msgid "Creating a basic module"
msgstr "创建一个基本模块"

#: ../../howtos/website.rst:18
msgid "In Odoo, tasks are performed by creating modules."
msgstr "在Odoo, 任务是通过创建模块执行。"

#: ../../howtos/website.rst:20
msgid ""
"Modules customize the behavior of an Odoo installation, either by adding new"
" behaviors or by altering existing ones (including behaviors added by other "
"modules)."
msgstr "模块自定义Odoo安装的行为, 或者通过添加新的行为或通过改变现有的（包括由其他模块加入的行为）。"

#: ../../howtos/website.rst:24
msgid ""
":ref:`Odoo's scaffolding <reference/cmdline/scaffold>` can setup a basic "
"module. To quickly get started simply invoke:"
msgstr ":ref:`Odoo's scaffolding <reference/cmdline/scaffold>` can setup a basic module. To quickly get started simply invoke :"

#: ../../howtos/website.rst:31
msgid ""
"This will automatically create a ``my-modules`` *module directory* with an "
"``academy`` module inside. The directory can be an existing module directory"
" if you want, but the module name must be unique within the directory."
msgstr "这将自动创建一个 ``我-modules`` *模块目录* 用 ``academy`` 模块内。该目录可以是现有模块的目录, 如果你想要的, 但模块名称必须是目录中是唯一的。"

#: ../../howtos/website.rst:39
msgid "A demonstration module"
msgstr "演示模块"

#: ../../howtos/website.rst:41
msgid "We have a \"complete\" module ready for installation."
msgstr "我们有一个'完整'模块, 可随时安装。"

#: ../../howtos/website.rst:43
msgid "Although it does absolutely nothing we can install it:"
msgstr "虽然也绝对没有什么, 我们可以安装它:"

#: ../../howtos/website.rst:45
msgid "start the Odoo server"
msgstr "启动Odoo服务器"

#: ../../howtos/website.rst:51
msgid "go to http://localhost:8069"
msgstr "访问http://本地主机:8069"

#: ../../howtos/website.rst:52
msgid "create a new database including demonstration data"
msgstr "创建一个新的数据库, 包括演示数据"

#: ../../howtos/website.rst:53
msgid "to go :menuselection:`Settings --> Modules --> Modules`"
msgstr "去 :menuselection:`设置 - >模块 - > Modules` "

#: ../../howtos/website.rst:54
msgid ""
"in the top-right corner remove the *Installed* filter and search for "
"*academy*"
msgstr "在右上角删除 **安装过滤器和搜索 *学院*"

#: ../../howtos/website.rst:56
msgid "click the :guilabel:`Install` button for the *Academy* module"
msgstr "点击 :guilabel:`Install` 键的 *学院* 模块"

#: ../../howtos/website.rst:59
msgid "To the browser"
msgstr "浏览器"

#: ../../howtos/website.rst:61
msgid ""
":ref:`Controllers <reference/http/controllers>` interpret browser requests "
"and send data back."
msgstr ":ref:`Controllers <reference/http/controllers>` interpret browser requests and send data back."

#: ../../howtos/website.rst:64
msgid ""
"Add a simple controller and ensure it is imported by ``__init__.py`` (so "
"Odoo can find it):"
msgstr "添加一个简单的控制器, 并确保它是由 ``__init __进口py`` （这样Odoo可以找到它）:"

#: ../../howtos/website.rst:69
msgid "Shut down your server (:kbd:`^C`) then restart it:"
msgstr "关闭你的服务器（:大骨节病:`^ C` ）, 然后重新启动:"

#: ../../howtos/website.rst:75
msgid ""
"and open a page to http://localhost:8069/academy/academy/, you should see "
"your \"page\" appear:"
msgstr "并打开一个页面中输入http://本地主机:8069 /学院/学院/, 你应该看到你'页'的出现:"

#: ../../howtos/website.rst:81
msgid "Templates"
msgstr "模板"

#: ../../howtos/website.rst:83
msgid "Generating HTML in Python isn't very pleasant."
msgstr "在Python生成HTML是不是很愉快。"

#: ../../howtos/website.rst:85
msgid ""
"The usual solution is templates_, pseudo-documents with placeholders and "
"display logic. Odoo allows any Python templating system, but provides its "
"own :ref:`QWeb <reference/qweb>` templating system which integrates with "
"other features."
msgstr "The usual solution is templates_, pseudo-documents with placeholders and display logic. Odoo allows any Python templating system, but provides its own :ref:`QWeb <reference/qweb>` templating system which integrates with other features."

#: ../../howtos/website.rst:90
msgid ""
"Create a template and ensure the template file is registered in the "
"``__openerp__.py`` manifest, and alter the controller to use our template:"
msgstr "创建模板并确保模板文件被登记在 ``__openerp __ py`` 舱单, 并改变控制器使用我们的模板。:"

#: ../../howtos/website.rst:95
msgid ""
"The templates iterates (``t-foreach``) on all the teachers (passed through "
"the *template context*), and prints each teacher in its own paragraph."
msgstr "模板迭代（ ``t-foreach`` ）上的所有教师（通过 *模板中* 通过）, 并打印在自己的段每个教师。"

#: ../../howtos/website.rst:98
msgid ""
"Finally restart Odoo and update the module's data (to install the template) "
"by going to :menuselection:`Settings --> Modules --> Modules --> Academy` "
"and clicking :guilabel:`Upgrade`."
msgstr "最后, 重新启动Odoo和更新模块的数据（安装模板）转到 :menuselection:`设置 - >模块 - >模块 - > Academy` 和点击 :guilabel:`Upgrade` 。"

#: ../../howtos/website.rst:104
msgid ""
"Alternatively, Odoo can be restarted :option:`and update modules at the same"
" time<odoo.py -u>`:"
msgstr "或者, Odoo可以重新启动 :option:`和更新模块在同一时间<odoo.py -u>` :"

#: ../../howtos/website.rst:111
msgid "Going to http://localhost:8069/academy/academy/ should now result in:"
msgstr "访问http://本地主机:8069 /学院/学院/现在应该导致:"

#: ../../howtos/website.rst:116
msgid "Storing data in Odoo"
msgstr "存储数据"

#: ../../howtos/website.rst:118
msgid ":ref:`Odoo models <reference/orm/model>` map to database tables."
msgstr ":ref:`Odoo 模型 <reference/orm/model>` 映射到数据库表."

#: ../../howtos/website.rst:120
msgid ""
"In the previous section we just displayed a list of string entered "
"statically in the Python code. This doesn't allow modifications or "
"persistent storage so we'll now move our data to the database."
msgstr "在上一节中, 我们只是显示的字符串在Python代码静态地进入了名单。这不允许修改或持久存储, 所以我们现在要转移我们的数据到数据库中。"

#: ../../howtos/website.rst:125
msgid "Defining the data model"
msgstr "定义数据模型"

#: ../../howtos/website.rst:127
msgid ""
"Define a teacher model, and ensure it is imported from ``__init__.py`` so it"
" is correctly loaded:"
msgstr "定义一个老师的模型, 并确保它是从 ``__init __ py`` 进口, 因此正确装入:"

#: ../../howtos/website.rst:132
msgid ""
"Then setup :ref:`basic access control <reference/security/acl>` for the "
"model and add them to the manifest:"
msgstr "Then setup :ref:`basic access control <reference/security/acl>` for the model and add them to the manifest :"

#: ../../howtos/website.rst:137
msgid ""
"this simply gives read access (``perm_read``) to all users (``group_id:id`` "
"left empty)."
msgstr "这只是一种读访问（ ``perm_read`` ）的所有用户（ ``GROUP_ID:id`` 空）。"

#: ../../howtos/website.rst:142
msgid ""
":ref:`Data files <reference/data>` (XML or CSV) must be added to the module "
"manifest, Python files (models or controllers) don't but have to be imported"
" from ``__init__.py`` (directly or indirectly)"
msgstr ":ref:`Data files <reference/data>` (XML or CSV) must be added to the module manifest, Python files (models or controllers) don't but have to be imported from ``__init__.py`` (directly or indirectly)"

#: ../../howtos/website.rst:148
msgid ""
"the administrator user bypasses access control, they have access to all "
"models even if not given access"
msgstr "管理员用户绕过访问控制, 他们有机会获得所有车型即使没有获准进入"

#: ../../howtos/website.rst:152
msgid "Demonstration data"
msgstr "演示数据"

#: ../../howtos/website.rst:154
msgid ""
"The second step is to add some demonstration data to the system so it's "
"possible to test it easily. This is done by adding a ``demo`` :ref:`data "
"file <reference/data>`, which must be linked from the manifest:"
msgstr "The second step is to add some demonstration data to the system so it's possible to test it easily. This is done by adding a ``demo`` :ref:`data file <reference/data>` , which must be linked from the manifest :"

#: ../../howtos/website.rst:162
msgid ""
":ref:`Data files <reference/data>` can be used for demo and non-demo data. "
"Demo data are only loaded in \"demonstration mode\" and can be used for flow"
" testing and demonstration, non-demo data are always loaded and used as "
"initial system setup."
msgstr ":ref:`Data files <reference/data>` can be used for demo and non-demo data. Demo data are only loaded in ``demonstration mode`` and can be used for flow testing and demonstration, non-demo data are always loaded and used as initial system setup."

#: ../../howtos/website.rst:167
msgid ""
"In this case we're using demonstration data because an actual user of the "
"system would want to input or import their own teachers list, this list is "
"only useful for testing."
msgstr "在这种情况下, 我们使用演示数据, 因为该系统的实际用户希望输入或导入自己的教师名单, 这个名单只是用于测试。"

#: ../../howtos/website.rst:172
msgid "Accessing the data"
msgstr "读取数据"

#: ../../howtos/website.rst:174
msgid ""
"The last step is to alter model and template to use our demonstration data:"
msgstr "最后一步是改变模型和模板使用我们的示范数据:"

#: ../../howtos/website.rst:176
msgid "fetch the records from the database instead of having a static list"
msgstr "从数据库取得记录，而不是具有一个静态列表"

#: ../../howtos/website.rst:177
msgid ""
"Because :meth:`~openerp.models.Model.search` returns a set of records "
"matching the filter (\"all records\" here), alter the template to print each"
" teacher's ``name``"
msgstr "因为 :meth:`~openerp.models.Model.search` 返回一组记录匹配的过滤器（'的所有记录'在这里）, 更改模板打印每个老师的 ``name`` "

#: ../../howtos/website.rst:183
msgid ""
"Restart the server and update the module (in order to update the manifest "
"and templates and load the demo file) then navigate to "
"http://localhost:8069/academy/academy/. The page should look slightly "
"different: names should simply be prefixed by a number (the database "
"identifier for the teacher)."
msgstr "重新启动服务器, 更新模块（以更新的清单和模板和加载演示文件）, 然后导航到http://本地主机:8069 /学院/学院/。这个页面应该会略有不同:名称应该仅仅通过一个数字（教师数据库标识符）作为前缀。"

#: ../../howtos/website.rst:190
msgid "Website support"
msgstr "网站支持"

#: ../../howtos/website.rst:192
msgid "Odoo bundles a module dedicated to building websites."
msgstr "Odoo捆绑了专门为网站建设模块。"

#: ../../howtos/website.rst:194
msgid ""
"So far we've used controllers fairly directly, but Odoo 8 added deeper "
"integration and a few other services (e.g. default styling, theming) via the"
" ``website`` module."
msgstr "到目前为止, 我们已经相当直接使用控制器, 但Odoo 8通过 ``website`` 模块添加更深入的一体化和其他一些服务（如默认样式, 主题）。"

#: ../../howtos/website.rst:198
msgid "first, add ``website`` as a dependency to ``academy``"
msgstr "首先, 加 ``website`` 作为 ``academy`` 的一个依赖"

#: ../../howtos/website.rst:199
msgid ""
"then add the ``website=True`` flag on the controller, this sets up a few new"
" variables on :ref:`the request object <reference/http/request>` and allows "
"using the website layout in our template"
msgstr "then add the ``website=True`` flag on the controller, this sets up a few new variables on :ref:`the request object <reference/http/request>` and allows using the website layout in our template"

#: ../../howtos/website.rst:202
msgid "use the website layout in the template"
msgstr "使用模板中的网站布局"

#: ../../howtos/website.rst:206
msgid ""
"After restarting the server while updating the module (in order to update "
"the manifest and template) access http://localhost:8069/academy/academy/ "
"should yield a nicer looking page with branding and a number of built-in "
"page elements (top-level menu, footer, …)"
msgstr "//本地主机:重新启动服务器时更新模块（以更新的清单和模板）访问HTTP后8069 /学院/学院/应该得到一个更好看页面的品牌和一些内置的页面元素（顶-level菜单, 页脚, ...）"

#: ../../howtos/website.rst:213
msgid ""
"The website layout also provides support for edition tools: click "
":guilabel:`Sign In` (in the top-right), fill the credentials in (``admin`` /"
" ``admin`` by default) then click :guilabel:`Log In`."
msgstr "该网站的布局也提供了编辑工具, 支持:点击 :guilabel:`登录In` （在右上方）, 填写（ ``admin`` / ``默认admin`` ）, 然后单击凭据 :guilabel:`登录In` 。"

#: ../../howtos/website.rst:217
msgid ""
"You're now in Odoo \"proper\": the administrative interface. For now click "
"on the :guilabel:`Website` menu item (top-left corner."
msgstr "管理界面:您现在在Odoo'适当的'是。现在点击 :guilabel:`Website` 菜单项（左上角。"

#: ../../howtos/website.rst:220
msgid ""
"We're back in the website but as an administrator, with access to advanced "
"edition features provided by the *website* support:"
msgstr "我们回到网站, 但作为管理员, 可以访问由 *网站* 支持提供的高级版本功能:"

#: ../../howtos/website.rst:223
msgid ""
"a template code editor (:menuselection:`Customize --> HTML Editor`) where "
"you can see and edit all templates used for the current page"
msgstr "模板代码编辑器（ :menuselection:`自定义 - > HTML Editor` ）, 在这里你可以查看和编辑用于当前页面所有模板"

#: ../../howtos/website.rst:225
msgid ""
"the :guilabel:`Edit` button in the top-left switches to \"edition mode\" "
"where blocks (snippets) and rich text edition are available"
msgstr "中 :guilabel:`Edit` 按钮, 在左上角的切换到'出版模式', 其中块（片段）和富文本编辑可用"

#: ../../howtos/website.rst:227
msgid ""
"a number of other features such as mobile preview or :abbr:`SEO (Search "
"Engine Optimization)`"
msgstr "其他的一些功能, 如移动预览或 :abbr:`SEO（搜​​索引擎优化）` "

#: ../../howtos/website.rst:231
msgid "URLs and routing"
msgstr "网址和路由"

#: ../../howtos/website.rst:233
msgid ""
"Controller methods are associated with *routes* via the "
":func:`~openerp.http.route` decorator which takes a routing string and a "
"number of attributes to customise its behavior or security."
msgstr ":func: :控制器方法与 **路由经由关联的 `~openerp.http.route` 装饰这需要一个路由串和多个属性来定制其行为或安全性。"

#: ../../howtos/website.rst:237
msgid ""
"We've seen a \"literal\" routing string, which matches a URL section "
"exactly, but routing strings can also use `converter patterns`_ which match "
"bits of URLs and make those available as local variables. For instance we "
"can create a new controller method which takes a bit of URL and prints it "
"out:"
msgstr "我们已经看到了'直译'路径字符串, 它完全匹配的URL部分, 但路由字符串也可以使用相匹配的URL位 `器patterns` _, 并使这些可以作为局部变量。例如, 我们可以创建一个新的控制器方法, 需要的网址了一下, 打印出来:"

#: ../../howtos/website.rst:244
msgid ""
"restart Odoo, access http://localhost:8069/academy/Alice/ and "
"http://localhost:8069/academy/Bob/ and see the difference."
msgstr "重新启动Odoo, 访问http://本地主机:8069 /学院/爱丽丝/和http://本地主机:8069 /学院/鲍勃/, 看到了差距。"

#: ../../howtos/website.rst:247
msgid ""
"As the name indicates, `converter patterns`_ don't just do extraction, they "
"also do *validation* and *conversion*, so we can change the new controller "
"to only accept integers:"
msgstr "正如其名称所示,'转换器patterns `_不只是做提取, 他们也做 *验证* 和 *转换* , 所以我们可以改变新控制器只接受整数:"

#: ../../howtos/website.rst:253
msgid ""
"Restart Odoo, access http://localhost:8069/academy/2, note how the old value"
" was a string, but the new one was converted to an integers. Try accessing "
"http://localhost:8069/academy/Carol/ and note that the page was not found: "
"since \"Carol\" is not an integer, the route was ignored and no route could "
"be found."
msgstr "重新启动Odoo, 访问http://本地主机:8069 /学院/ 2, 注意旧值是怎样一个字符串, 但新一被转换为整数。尝试访问http://本地主机:8069 /学院/卡罗尔/并注意页面未找到:由于'卡罗尔'不是一个整数, 路线被忽视, 没有途径可寻。"

#: ../../howtos/website.rst:259
msgid ""
"Odoo provides an additional converter called ``model`` which provides "
"records directly when given their id. Let's use this to create a generic "
"page for teacher biographies:"
msgstr "Odoo提供所谓 ``model`` 一个额外的转换器, 它在给定的ID直接提供的记录。让我们用它来创建教师传记的通用页:"

#: ../../howtos/website.rst:265
msgid "then change the list of model to link to our new controller:"
msgstr "然后改变模型的列表, 链接到我们的新控制器:"

#: ../../howtos/website.rst:269
msgid ""
"Restart Odoo and upgrade the module, then you can visit each teacher's page."
" As an exercise, try adding blocks to a teacher's page to write a biography,"
" then go to another teacher's page and so forth. You will discover, that "
"your biography is shared between all teachers, because blocks are added to "
"the *template*, and the *biography* template is shared between all teachers,"
" when one page is edited they're all edited at the same time."
msgstr "重新启动Odoo和升级模块, 那么你就可以访问每个老师的页面。作为练习, 尝试添加块老师的页面写一本传记, 然后去另一个老师的页面等等。你会发现, 你的传记所有教师之间共享, 因为块添加到 *模板* 和 *传记* 模板所有教师, 当一个网页编辑, 他们都在编在同一时间共享。"

#: ../../howtos/website.rst:277
msgid "Field edition"
msgstr "字段编辑"

#: ../../howtos/website.rst:279
msgid ""
"Data which is specific to a record should be saved on that record, so let us"
" add a new biography field to our teachers:"
msgstr "数据是具体到一个记录应保存该记录, 所以让我们添加一个新的传记字段我们的老师:"

#: ../../howtos/website.rst:284
msgid ""
"Restart Odoo and update the views, reload the teacher's page and… the field "
"is invisible since it contains nothing."
msgstr "重新启动Odoo和更新的意见, 重新加载老师的页面, 并...字段是不可见的, 因为它包含了什么。"

#: ../../howtos/website.rst:290
msgid ""
"For record fields, templates can use a special ``t-field`` directive which "
"allows editing the field content from the website using field-specific "
"interfaces. Change the *person* template to use ``t-field``:"
msgstr "对于记录字段, 模板可以使用一个特殊的 ``t-field`` 指令, 它允许从网站使用字段特有的接口编辑字段内容。使用 ``t-field``更改 *person* 模板 :"

#: ../../howtos/website.rst:296
msgid ""
"Restart Odoo and upgrade the module, there is now a placeholder under the "
"teacher's name and a new zone for blocks in :guilabel:`Edit` mode. Content "
"dropped there is stored in the corresponding teacher's ``biography`` field, "
"and thus specific to that teacher."
msgstr "重新启动Odoo和升级模块, 现在在老师的名字一个占位符, 并在阻止新的区域 :guilabel:`Edit` 模式。含量下降存储有在相应的教师 ``biography`` 场, 因此特定于该教师。"

#: ../../howtos/website.rst:301
msgid ""
"The teacher's name is also editable, and when saved the change is visible on"
" the index page."
msgstr "在老师的名字也可编辑, 并保存在变化的索引页上可见。"

#: ../../howtos/website.rst:304
msgid ""
"``t-field`` can also take formatting options which depend on the exact "
"field. For instance if we display the modification date for a teacher's "
"record:"
msgstr " ``t-field`` 也可以格式化这取决于具体字段选择。举例来说, 如果我们显示修改日期老师的记录:"

#: ../../howtos/website.rst:309
msgid ""
"it is displayed in a very \"computery\" manner and hard to read, but we "
"could ask for a human-readable version:"
msgstr "它显示在一个非常'电脑系统'的方式, 难以阅读, 但我们可以要求一个人类可读的版本:"

#: ../../howtos/website.rst:314
msgid "or a relative display:"
msgstr "或相对显示:"

#: ../../howtos/website.rst:319
msgid "Administration and ERP integration"
msgstr "管理以及ERP集成"

#: ../../howtos/website.rst:322
msgid "A brief and incomplete introduction to the Odoo administration"
msgstr "odoo管理的简要介绍"

#: ../../howtos/website.rst:324
msgid ""
"The Odoo administration was briefly seen during the `website support`_ "
"section. We can go back to it using :menuselection:`Administrator --> "
"Administrator` in the menu (or :guilabel:`Sign In` if you're signed out)."
msgstr "该Odoo行政 `网站support` _节期间短暂地见过。我们可以使用回去吧 :menuselection:'管理员 - > Administrator `菜单（或 :guilabel:` 登录In `, 如果你退出了）。"

#: ../../howtos/website.rst:328
msgid "The conceptual structure of the Odoo backend is simple:"
msgstr "在Odoo后端的概念结构很简单:"

#: ../../howtos/website.rst:330
msgid ""
"first are menus, a tree (menus can have sub-menus) of records. Menus without"
" children map to…"
msgstr "首先是菜单, 一棵树（菜单可以有子菜单）的记录。菜单没有孩子映射到..."

#: ../../howtos/website.rst:332
msgid ""
"actions. Actions have various types: links, reports, code which Odoo should "
"execute or data display. Data display actions are called *window actions*, "
"and tell Odoo to display a given *model* according to a set of views…"
msgstr "动作。操作有多种类型:链接, 报告, Odoo应该执行或数据显示代码。数据显示动作称为 *窗口中的操作* , 并告诉Odoo显示给定 *模型* 根据一组视图..."

#: ../../howtos/website.rst:335
msgid ""
"a view has a type, a broad category to which it corresponds (a list, a "
"graph, a calendar) and an *architecture* which customises the way the model "
"is displayed inside the view."
msgstr "一个视图有一个类型, 其所对应一个大类（列表, 图表, 日历）和 *架构* 这customises显示在视图中的模型的方式。"

#: ../../howtos/website.rst:340
msgid "Editing in the Odoo administration"
msgstr "在Odoo管理进行编辑"

#: ../../howtos/website.rst:342
msgid ""
"By default, an Odoo model is essentially invisible to a user. To make it "
"visible it must be available through an action, which itself needs to be "
"reachable, generally through a menu."
msgstr "缺省情况下, Odoo模型本质不可见的用户。为了使其可见它必须通过一个行动, 这本身就需要被访问, 通常通过菜单可用。"

#: ../../howtos/website.rst:346
msgid "Let's create a menu for our model:"
msgstr "让我们来创建我们的模型菜单:"

#: ../../howtos/website.rst:350
msgid ""
"then accessing http://localhost:8069/web/ in the top left should be a menu "
":guilabel:`Academy`, which is selected by default, as it is the first menu, "
"and having opened a listing of teachers. From the listing it is possible to "
":guilabel:`Create` new teacher records, and to switch to the \"form\" by-"
"record view."
msgstr "然后访问http://本地主机:8069 /网络/左上方应该是一个菜单 :guilabel:`Academy` , 这是默认选中的, 因为它是第一个菜单, 并且已经打开教师的名单。从上市是可能的 :guilabel:`Create` 新老师的记录, 并通过记录视图切换到'的形式'。"

#: ../../howtos/website.rst:356
msgid ""
"If there is no definition of how to present records (a :ref:`view "
"<reference/views>`) Odoo will automatically create a basic one on-the-fly. "
"In our case it works for the \"list\" view for now (only displays the "
"teacher's name) but in the \"form\" view the HTML ``biography`` field is "
"displayed side-by-side with the ``name`` field and not given enough space. "
"Let's define a custom form view to make viewing and editing teacher records "
"a better experience:"
msgstr "If there is no definition of how to present records (a :ref:`view <reference/views>` ) Odoo will automatically create a basic one on-the-fly. In our case it works for the ``list`` view for now (only displays the teacher's name) but in the ``form`` view the HTML ``biography`` field is displayed side-by-side with the ``name`` field and not given enough space. Let's define a custom form view to make viewing and editing teacher records a better experience :"

#: ../../howtos/website.rst:369
msgid ""
"We have seen a pair of \"basic\" fields stored directly in the record. There"
" are :ref:`a number of basic fields <reference/orm/fields/basic>`. The "
"second broad categories of fields are :ref:`relational "
"<reference/orm/fields/relational>` and used to link records to one another "
"(within a model or across models)."
msgstr "We have seen a pair of ``basic`` fields stored directly in the record. There are :ref:`a number of basic fields <reference/orm/fields/basic>` . The second broad categories of fields are :ref:`relational <reference/orm/fields/relational>` and used to link records to one another (within a model or across models)."

#: ../../howtos/website.rst:375
msgid ""
"For demonstration, let's create a *courses* model. Each course should have a"
" ``teacher`` field, linking to a single teacher record, but each teacher can"
" teach many courses:"
msgstr "为了演示, 让我们创建一个 *课程* 模式。每门课程应该有一个 ``teacher`` 场, 链接到一个老师的记录, 但每个老师可以教许多课程:"

#: ../../howtos/website.rst:381
msgid "let's also add views so we can see and edit a course's teacher:"
msgstr "让我们也添加视图, 所以我们可以查看和编辑一门课程的老师:"

#: ../../howtos/website.rst:385
msgid ""
"It should also be possible to create new courses directly from a teacher's "
"page, or to see all the courses they teach, so add :class:`the inverse "
"relationship <openerp.fields.One2many>` to the *teachers* model:"
msgstr "它也应该可以直接从老师的页面创建新的课程, 还是要看他们所教的课程, 所以加 :class:`反向关系<openerp.fields.One2many>` 到 *老师* 型号:"

#: ../../howtos/website.rst:393
msgid "Discussions and notifications"
msgstr "讨论和通知"

#: ../../howtos/website.rst:395
msgid ""
"Odoo provides technical models, which don't directly fulfill business needs "
"but which add capabilities to business objects without having to build them "
"by hand."
msgstr "Odoo提供了技术模式, 不直接满足业务的需求, 但其中新增功能, 业务对象, 而不必手工打造他们。"

#: ../../howtos/website.rst:399
msgid ""
"One of these is the *Chatter* system, part of Odoo's email and messaging "
"system, which can add notifications and discussion threads to any model. The"
" model simply has to :attr:`~openerp.models.Model._inherit` ``mail.thread``,"
" and add the ``message_ids`` field to its form view to display the "
"discussion thread. Discussion threads are per-record."
msgstr "其中之一是在 **颤振系统, Odoo的电子邮件和消息系统的一部分, 它可以补充通知和讨论主题, 以任何模型。该模型只是有 :attr:`~openerp.models.Model._inherit ```mail.thread`` , 和 ``message_ids`` 字段添加到表单视图来显示话题。讨论主题是每个记录。"

#: ../../howtos/website.rst:405
msgid ""
"For our academy, it makes sense to allow discussing courses to handle e.g. "
"scheduling changes or discussions between teachers and assistants:"
msgstr "对于我们的学院, 这是有道理的, 允许讨论课程, 以处理如计划更改或教师和助理之间的讨论:"

#: ../../howtos/website.rst:410
msgid ""
"At the bottom of each course form, there is now a discussion thread and the "
"possibility for users of the system to leave messages and follow or unfollow"
" discussions linked to specific courses."
msgstr "在每个课程形式的底部, 现在有一个讨论话题, 并有可能对系统的用户离开的消息, 并跟随或停止关注与具体课程的讨论。"

#: ../../howtos/website.rst:415
msgid "Selling courses"
msgstr "销售课程"

#: ../../howtos/website.rst:417
msgid ""
"Odoo also provides business models which allow using or opting in business "
"needs more directly. For instance the ``website_sale`` module sets up an "
"e-commerce site based on the products in the Odoo system. We can easily make"
" course subscriptions sellable by making our courses specific kinds of "
"products."
msgstr "Odoo还提供了允许使用或选择加入的企业更需要直接的商业模式。比如 ``website_sale`` 模块建立基于产品在Odoo系统的电子商务网站。我们可以很容易地使课程可供出售的订阅通过我们的课程特定种类的产品。"

#: ../../howtos/website.rst:423
msgid ""
"Rather than the previous classical inheritance, this means replacing our "
"*course* model by the *product* model, and extending products in-place (to "
"add anything we need to it)."
msgstr "而不是以前经典的继承, 这意味着更换了 *课程* 模型由 *产品* 模型, 并延长产品就地（添加任何东西, 我们需要它）。"

#: ../../howtos/website.rst:427
msgid ""
"First of all we need to add a dependency on ``website_sale`` so we get both "
"products (via ``sale``) and the ecommerce interface:"
msgstr "首先, 我们需要添加一个依赖 ``website_sale`` ，这样，我们同时得到产品（通过 ``sale`` ）和电子商务界面:"

#: ../../howtos/website.rst:432
msgid ""
"restart Odoo, update your module, there is now a :guilabel:`Shop` section in"
" the website, listing a number of pre-filled (via demonstration data) "
"products."
msgstr "重新启动Odoo, 更新你的模块, 现在在网站的 :guilabel:`Shop` 部分，列出了一些预先填好的（通过演示数据）产品。"

#: ../../howtos/website.rst:435
msgid ""
"The second step is to replace the *courses* model by ``product.template``, "
"and add a new category of product for courses:"
msgstr "第二步是通过 ``product.template`` 更换 *课程* 模型, 并增加产品的新类别的课程:"

#: ../../howtos/website.rst:440
msgid ""
"With this installed, a few courses are now available in the "
":guilabel:`Shop`, though they may have to be looked for."
msgstr "有了这个安装, 几个疗程, 现已在 :guilabel:`Shop` , 虽然他们可能需要寻找。"

#: ../../howtos/website.rst:445
msgid ""
"to extend a model in-place, it's :attr:`inherited "
"<openerp.models.Model._inherit>` without giving it a new "
":attr:`~openerp.models.Model._name`"
msgstr "延长就地一个模型, 它是 :attr:`继承<openerp.models.Model._inherit>` 没有给它一个新的 :attr:`~openerp.models.Model._name` "

#: ../../howtos/website.rst:448
msgid ""
"``product.template`` already uses the discussions system, so we can remove "
"it from our extension model"
msgstr " ``product.template`` 已经使用了讨论系统, 所以我们可以从我们的推广模式中删除"

#: ../../howtos/website.rst:450
msgid ""
"we're creating our courses as *published* by default so they can be seen "
"without having to log in"
msgstr "我们正在创造我们的课程为 **发表默认情况下, 这样他们就可以无需登录可见"

#: ../../howtos/website.rst:454
msgid "Altering existing views"
msgstr "改变现有的视图"

#: ../../howtos/website.rst:456
msgid "So far, we have briefly seen:"
msgstr "到目前为止, 我们已经简要地看到:"

#: ../../howtos/website.rst:458
msgid "the creation of new models"
msgstr "新模型的创建"

#: ../../howtos/website.rst:459
msgid "the creation of new views"
msgstr "新视图的创建"

#: ../../howtos/website.rst:460
msgid "the creation of new records"
msgstr "新记录的创建"

#: ../../howtos/website.rst:461
msgid "the alteration of existing models"
msgstr "现有车型的改变"

#: ../../howtos/website.rst:463
msgid ""
"We're left with the alteration of existing records and the alteration of "
"existing views. We'll do both on the :guilabel:`Shop` pages."
msgstr "我们留下的现有记录的改变和现有视图的改变。 guilabel:`Shop` 页我们将在这两种操作。"

#: ../../howtos/website.rst:466
msgid ""
"View alteration is done by creating *extension* views, which are applied on "
"top of the original view and alter it. These alteration views can be added "
"or removed without modifying the original, making it easier to try things "
"out and roll changes back."
msgstr "查看变更是通过创建 *扩展名为* 的视图, 这是应用在原始视图的顶部, 改变它完成。这些改变视图可以添加或删除而不修改原始, 使其更容易尝试东西出来和辊变回。"

#: ../../howtos/website.rst:471
msgid ""
"Since our courses are free, there is no reason to display their price on the"
" shop page, so we're going to alter the view and hide the price if it's 0. "
"The first task is finding out which view displays the price, this can be "
"done via :menuselection:`Customize --> HTML Editor` which lets us read the "
"various templates involved in rendering a page. Going through a few of them,"
" \"Product item\" looks a likely culprit."
msgstr "因为我们的课程都是免费的, 没有任何理由来显示他们的价格在店铺页面上的, 所以我们要改变视图和隐藏的价格, 如果是0, 第一个任务是找出哪些视图显示的价格, 这可以menuselection:通过做'自定义 - > HTML Editor `它可以让我们读出涉及呈现页面的各种模板。在经历了几个人,'产品项目'看起来可能是罪魁祸首。"

#: ../../howtos/website.rst:478
msgid "Altering view architectures is done in 3 steps:"
msgstr "改变视图架构3个步骤就可以完成:"

#: ../../howtos/website.rst:480
msgid "Create a new view"
msgstr "创建一个新视图"

#: ../../howtos/website.rst:481
msgid ""
"Extend the view to modify by setting the new view's ``inherit_id`` to the "
"modified view's external id"
msgstr "扩展视图通过设置新的视图的 ``修改inherit_id`` 修改后的视图的外部ID"

#: ../../howtos/website.rst:483
msgid ""
"In the architecture, use the ``xpath`` tag to select and alter elements from"
" the modified view"
msgstr "在该架构中, 使用 ``xpath`` 标签来选择和修改, 从修改后的视图元素"

#: ../../howtos/website.rst:488
msgid ""
"The second thing we will change is making the product categories sidebar "
"visible by default: :menuselection:`Customize --> Product Categories` lets "
"you toggle a tree of product categories (used to filter the main display) on"
" and off."
msgstr "第二件事情, 我们将改变是使产品类别​​侧边栏默认可见 :menuselection:`自定义 - >产品Categories` , 您可以切换产品类别树（用于过滤主显示器）和关闭。"

#: ../../howtos/website.rst:493
msgid ""
"This is done via the ``customize_show`` and ``active`` fields of extension "
"templates: an extension template (such as the one we've just created) can be"
" *customize_show=True*. This choice will display the view in the "
":guilabel:`Customize` menu with a check box, allowing administrators to "
"activate or disable them (and easily customize their website pages)."
msgstr "这是通过 ``customize_show`` , 做 ``的扩展模板active`` 字段:一个扩展模板（比如我们刚刚创建的）可 * customize_show =真* 。此选项将显示在视图中 :guilabel: 与复选框 `Customize` 菜单, 允许管理员启用或禁用它们（和轻松定制自己的网站页面）。"

#: ../../howtos/website.rst:499
msgid ""
"We simply need to modify the *Product Categories* record and set its default"
" to *active=\"True\"*:"
msgstr "我们只需要修改 *产品类别* 记录并设置其默认为 *激活='真正的'* :"

#: ../../howtos/website.rst:504
msgid ""
"With this, the *Product Categories* sidebar will automatically be enabled "
"when the *Academy* module is installed."
msgstr "由此, *产品类别* 侧边栏会自动安装 *学院* 模块时启用。"
